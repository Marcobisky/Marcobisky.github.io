- **Binary Tree 二叉树**: 每个节点**最多**有两个子节点的树.
    - **Full 满二叉树**: 每个节点要么有 0, 要么有 2 个孩子.
    - **Complete 完全二叉树**: 按从上到下, 从左到右的顺序填充的树.
    - **Degenerate 退化二叉树**: 即链表 (有 total order).
    - **Perfect 完美二叉树**: 顾名思义, 没有更完美.
    - **Balanced 平衡二叉树**: 对于 **Every Node**, 左右子树高度差不超过 1.

    ![二叉树的分类](binary-tree-types.png)

- **Heap 堆**: 满足堆性质的**完全二叉树**.
    - **Max-Heap 最大堆**: 每个节点的值都大于等于其子节点的值.
    - **Min-Heap 最小堆**: 每个节点的值都小于等于其子节点的值.
    - 堆通常用数组实现.

- **BST 二叉搜索树**: 对于每个节点, 左子树的值都小于该节点的值, 右子树的值都大于该节点的值.
    - BST 支持高效的搜索、插入和删除操作, 平均时间复杂度为 $O(\log n)$, 最坏情况为 $O(n)$ (退化为链表).
    - 为了避免退化, 引入了**自平衡 BST**: 如 AVL 树, 红黑树等.

- **Search 搜索**
    - **BFS 广度优先**: 即 **Level-order 层序遍历** (队列实现)
    - **DFS 深度优先**: 分为 **Pre-order 先序, In-order 中序, Post-order 后序**: 指访问 **root** 的顺序.
        - 都是递归形式定义.

- 函数的 Limit behavior:
    - $f(x) = \mathcal{O}(g(x)) \iff \exists c>0, |f(x)| \le c|g(x)|$, eventually[^eventually].
    - $f(x) = \Omega(g(x)) \iff \exists c>0, |f(x)| \ge c|g(x)|$, eventually.
    - $f(x) = \Theta(g(x)) \iff \exists c_1, c_2>0, c_1 g(x) \le f(x) \le c_2 g(x)$, eventually.

[^eventually]: $f(x) > g(x)$, eventually 的意思是: $\exists x_0, \forall x > x_0, f(x) > g(x)$.

- 鉴于 $\mathcal{O}$ 记号是确定性函数的最终上界, 在 CS 中, 我们一般取最小的上界来代表复杂度, 而且复杂度也要分最坏、平均、最好三种情况的复杂度 (默认是平均复杂度).