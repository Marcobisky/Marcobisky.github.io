[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TinyML",
    "section": "",
    "text": "0.1 Hi there!\nThis is my graduation project titled System-Level Co-Design and AI-EDA of RISC-V Accelerators for TinyML at the Edge under my supervisor Prof. Yun Li. His PhD student Jintao Li also helps me greatly. This is a place where I record my learning journey into TinyML and RISC-V accelerators – from scratch. The contents are actively updating. Some of the content may be too basic or even technically incorrect up to now, but they are, hopefully, informative and motivation-boosting. English documentation will be available soon.\n本项目有关的代码主要存放在两个仓库:",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction 引入</span>"
    ]
  },
  {
    "objectID": "index.html#hi-there",
    "href": "index.html#hi-there",
    "title": "TinyML",
    "section": "",
    "text": "Correctness is the enemy of progress. – Myself\n\n\n\nMy TinyML Repo\nMy Forked CFU Playground",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction 引入</span>"
    ]
  },
  {
    "objectID": "index.html#intended-outcomes",
    "href": "index.html#intended-outcomes",
    "title": "TinyML",
    "section": "0.2 Intended Outcomes",
    "text": "0.2 Intended Outcomes\n\nDeveloping an intelligent co-design framework that integrates RISC-V architecture customization with TinyML workload characteristics to enable joint optimization.\nDesigning and implementing hardware-accelerated TinyML kernels that are adaptable and efficient for edge computing scenarios.\nExploring a large multi-dimensional design space using automated methods (such as heuristic or evolutionary algorithms) to identify optimal configurations balancing accuracy, energy, and latency.\nAdvancing the understanding of system-level TinyML accelerator optimization, pushing the boundary beyond traditional manual design methods.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction 引入</span>"
    ]
  },
  {
    "objectID": "index.html#motivation-动机",
    "href": "index.html#motivation-动机",
    "title": "TinyML",
    "section": "0.3 Motivation 动机",
    "text": "0.3 Motivation 动机\n大量应用程序都配备了图像处理的深度学习算法 (如 Animoji), 若想要利用服务器的算力资源, 则每秒至少需要输入 \\(30\\) 帧图片到网络当中, 对于 ResNet-50 这种小网络, 模型运行时也需要占用 \\(3\\text{ GB/s}\\) 的带宽 [1]. 因此, 需要 将云端的一部分计算任务下放到端设备, 以减轻云端和网络带宽的压力. 然而端设备大多采用嵌入式处理器 —— 嵌入式处理器受到功耗、体积、散热等多方客观因素的限制, 其性能远不如桌面平台. 我们可以利用 FPGA、ASIC 等 低功耗、高能效 的器件, 为相应的应用场景定制该领域所专用的加速器 [2].",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction 引入</span>"
    ]
  },
  {
    "objectID": "index.html#change-logs-更新日志",
    "href": "index.html#change-logs-更新日志",
    "title": "TinyML",
    "section": "0.4 🗓️ Change Logs 更新日志",
    "text": "0.4 🗓️ Change Logs 更新日志\n\n\n\n\n\n\n\n\nDate\nUpdate Message\n\n\n\n\n2025-08-08\n学习 APB 协议, 发现有时候工程学也需要一点数学思维, 要把每个存在物 (比如总线、decoder、switch hub, etc.) 当作某个抽象观点的特例! 不要背协议, 而是理解协议这样规定的本质原因.\n\n\n2025-08-05~07\n复习 IELTS.\n\n\n2025-08-04\n刷 Chisel 的时候感到很无力, 编程语言的本质到底是什么? 为什么 when() 在 Scala 里面是函数而在 C 语言里面是语句? 一定有一套统一的思维方式来思考所有的编程语言, 使得学某种特定语言的过程相当于把大脑中的这个思维方式实例化. I felt stuck in this path, maybe I need a little bit encouragement. This happens, I know.\n\n\n2025-08-03\n入门 CUDA 编程, 学习 NVIDIA 的 GPU 架构. 也学习了 Transformer 的原理, 加强了对注意力机制的理解.\n\n\n2025-08-01\n按照 汪辰老师的课程, 初步复习了操作系统的 Memory Management, Linker script, Control flow, exceptional control flow, interrupt处理等.\n\n\n2025-07-30~31\n在学习 ysyx 的过程中感到 extremely depressed, 我开始浏览 ysyx 入学之后的学习资料, 发现这些资料存在明显的平行性, 没有必要严格按照顺序来学习. 重新拾起烂尾的 my-riscv 项目, 决定退出依赖 ysyx 的学习方法.\n\n\n2025-07-29\n继续 ysyx 的 E4 (即 PA1), make run 成功运行\n\n\n2025-07-28\n开始 ysyx 的 E4 (即 PA1), 发现 ysyx PA 的思路是自顶向下的\n\n\n2025-07-27\n在 MacOS 和 Ubuntu 上完成了 ysyx 环境的配置, 可同时在两台设备上开发, man 这个命令感觉挺有用的.\n\n\n2025-07-24~26\n通过 HDLBits 刷了一些 verilog 题目.\n\n\n2025-07-23\n报名一生一芯 (ysyx), 准备先造个 CPU 出来, 再来加速 ML.\n\n\n2025-07-17\n准备进行 Vitis HLS 的学习, 初步学习了 YOLO V1 的原理.\n\n\n2025-07-12\n成功将 CFU-playground 的 proj_template 烧到 Arty 开发板上. 认识到开发环境的搭建和理解是一项较大的工程, 但是实际有用的信息并不多, 所以打算并行地学习环境的搭建和 CPU、GPU、Cuda 的知识.\n\n\n2025-07-11\n大致了解了各大 submodule 的功能.\n\n\n2025-07-10\n在 Ubuntu 24.04 和 MacOS 上成功搭建 iCESugar-UP5K 开发环境, 并成功烧录! 完善了教程内容, 建立了 My TinyML Repo 用来存放 iCESugar-UP5K 开发板的例子代码和 ML 加速器的代码.\n\n\n2025-07-09\n在 Ubuntu 24.04 上成功构建 CFU-Playground 的 /proj/proj_template 实例工程. 并且发现 MacOS 上也可以用 Docker 成功生成比特流文件.\n\n\n2025-07-08\n喜提新 Thinkbook, 由于显卡和网卡驱动找不到安装 Debian 失败特别狂躁, Tonic 上报复性狂练 3 小时降 E 大调音阶. 后来安装 Ubuntu 24.04 实体机成功编译. btw, Spark 推荐的 AtlasOS 太好用啦, Synergy 同步 Win, Mac, IOS, Linux 剪切板太方便啦 (就是没有安卓hh)\n\n\n2025-07-07\n发现在 M 芯片 MacOS 上无法安装 linux-64 架构, 改用 Docker 搭建环境成功 … 了一半, 最后因为 Docker 无法连接访问 MacOS 连接的 USB 而构建实例工程失败.\n\n\n2025-07-06\n尝试在 MacOS 上原生搭建和用 Docker 搭建, 无果, 遂改用 Parallel Desktop 上安装 Ubuntu 24.04.\n\n\n2025-06-29\nInitial commit.\n\n\n\n\n\n\n\n\n\n1. 电子H (2025) 哈工大深度学习体系结构课程 | 实验2：YOLO算法量化加速-CSDN博客\n\n\n2. (2021) Deep learning architecture",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction 引入</span>"
    ]
  },
  {
    "objectID": "resources/resources.html",
    "href": "resources/resources.html",
    "title": "Resources 学习资料汇总",
    "section": "",
    "text": "CPU",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#cpu",
    "href": "resources/resources.html#cpu",
    "title": "Resources 学习资料汇总",
    "section": "",
    "text": "An Introduction to Computing Systems Yale Patt: ★★★★★ 如果你大一想认真学一下计算机组成原理, 信我的, 读它准没错 (wetABQ 大佬推荐的).\n\n本书详细讲了一个简单的 16-bit LC-3 CPU 的设计, 包括指令集、汇编语言、机器语言、微架构等内容.\n\nBilibili: RISCV-MCU: ★★★★★ 一个基于 Digital 和 verilog 的 RISC-V CPU 仿真教程, 讲得非常好, 强推!\n\n本人基于这个项目做了一个 my-riscv.\n\nThe “Basic” Pipelined CPU: ★★★★★ 讲了 CPU 流水线 5 个阶段的工作原理.\n\nDr. Chun Yan Cheung Lectures: ★★★★★ 强推!!!",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#neural-network",
    "href": "resources/resources.html#neural-network",
    "title": "Resources 学习资料汇总",
    "section": "Neural Network",
    "text": "Neural Network\n\nAnimated AI: ★★★★★ 可视化了以下概念: Convolution, Padding, Stride, Groups, Depthwise, Depthwise-Separable, Pixel shuffle. 图像处理肯定会用到.\nYOLO V1 Bilibili 讲解: ★★★★★ 非常清楚, 强推.\nA Gentle Introduction to GNN: 图神经网络入门.\n\nUnderstanding Convolutions on Graphs\n\nword2vec: ★★★★☆ Youtube 视频, 讲解了 word2vec 的原理.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#fpga-理论",
    "href": "resources/resources.html#fpga-理论",
    "title": "Resources 学习资料汇总",
    "section": "FPGA 理论",
    "text": "FPGA 理论\n\nHDLBits: ★★★★★ 一个在线的 HDL 练习网站. 如果你对 verilog 一无所知, 直接上这个网站绝对没错.\nChisel Bootcamp: ★★☆☆☆ 可通过在线的练习来学习 Chisel 语言 (只需做前几章即可)\nFPGA: ★☆☆☆☆ 用来学习 FPGA 的资料库.\n\nVerilog 语法 (Artix7修炼秘籍)\n\nFPGA: Architecture, Programmability and Advantageous: ★★★★☆ 一个讲解 FPGA 结构的视频, 很清楚.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#hls-design-fpga-并行编程",
    "href": "resources/resources.html#hls-design-fpga-并行编程",
    "title": "Resources 学习资料汇总",
    "section": "HLS Design FPGA 并行编程",
    "text": "HLS Design FPGA 并行编程\n\nParallel Programming for FPGAs: ★★★★☆ Xilinx 研究院的 Steve 首席工程师与 UCSD 的 Ryan Kastner 教授团队合作, 推出了这本开源书, 全书通过 10 个算法实现案例完整的介绍了通过 HLS 工具利用 C/C++ 语言快速实现高性能 FPGA 实现的过程.\n\nFPGA 并行编程中文版, 中文版 github repo",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#gpu",
    "href": "resources/resources.html#gpu",
    "title": "Resources 学习资料汇总",
    "section": "GPU",
    "text": "GPU\n\ntiny-gpu: ★★☆☆☆ 一个小型的 GPU 实现.\nVeriGPU: ★☆☆☆☆ 一个复杂点的 GPU 实现, 不适合用来入门.\nStanford CS336: ★★★★★ Stanford 的 Language Modeling from Scratch 课程.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html",
    "href": "glossary/glossary.html",
    "title": "Glossary 名词解释",
    "section": "",
    "text": "General Terms",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#general-terms",
    "href": "glossary/glossary.html#general-terms",
    "title": "Glossary 名词解释",
    "section": "",
    "text": "CFU: Custom Function Unit (自定义功能单元). 为 ML 某些耗时的计算 (如卷积、矩阵乘法、位操作等) 定制的指令加速硬件模块.\n\n一旦主处理器执行到特定的 CFU 指令，就会将数据发送给 CFU 处理，然后 CFU 返回结果.\nFPU: Floating Point Unit (浮点运算单元), 是 CPU 中专门处理浮点数运算的硬件组件.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#fpga-terms",
    "href": "glossary/glossary.html#fpga-terms",
    "title": "Glossary 名词解释",
    "section": "FPGA Terms",
    "text": "FPGA Terms\n\nGeneral\n\nTfLM: TensorFlow Lite for Microcontrollers.\n\nPDTI8: Person DeTection Int 8\n\nGateware: 用软件编写的硬件电路. (既不是 Software, 也不是 Hardware).\nHPS: High Performance System.\n\nPLATFORMS=common_soc sim hps, 三个平台. common_soc 指标准的 FPGA 开发平台; sim 指用 Verilator 进行软件仿真.\n\nSoC (System on Chip) 片上系统: 比如 ZYNQ, 一块硅芯片 就可以实现整个系统的功能 (而不是要组合多个芯片).\nIP Core: Intellectual Property Core. 由一方 (开发者或公司) 设计，并通过许可授权给其他设计者使用。常见的 IP 核包括 CPU 内核、以太网控制器、内存控制器等.\n\nSoft IP: 软核\nHard IP: 硬核\n\n.vcd, fst: 波形文件格式, 后者占空间更小, 但只受 GTKWave 支持 [1].\n\n\n\nInterface\n\nPMOD (Peripheral Module) 接口: 一组 2*6 排针的引脚 PMOD. 定义了电源、地线、以及最多 8 条可用于通信的信号线. PMOD模块通常通过 SPI、I2C 或 GPIO (通用数字输入输出) 与主控通信. 你可以买到很多支持 PMOD 的模块, 如传感器、显示屏、存储器等.\nJTAG 接口: 一种用于调试和编程的标准接口.\nAXI (Advanced eXtensible Interface) 接口: CPU 与外设 (内存控制器, DMA, CFU, IP 核) 之间的通信协议.\n\n比如 ZYNQ 的 PS (Processing System) 和 PL (Programmable Logic) 之间的通信就是通过 AXI 接口 (见 FPGA 原理速成).\n\n\n\n\nFile formats\n\n.pcf 文件: Physical Constraints File. .pcf 文件告诉工具：Verilog 中的某个逻辑信号，物理上应该接到 FPGA 的哪个 pin. 比如:\nset_io D1 B5\n表示把 D1 (在 .v 文件中定义的) 信号连接到 FPGA 的 B5 引脚.\n\n.xdc 文件: Xilinx Design Constraints File (Vivado 工具使用的约束文件, a.k.a., Master Constraints File 主约束文件). Arty 35T xdc 文件\n\n\n\n\nHDL\n\nHLS: High-Level Synthesis. 用 C/C++ 等高级语言来写硬件电路设计.\n\nScala: 一种专门生成其它 DSL (Domain Specific Language) 的语言. 生成的语言包括:\n\nSpinalHDL: 一种 Hardware Description Language (HDL). 可用来生成更底层的 Verilog 代码.\n\nVexRiscv Soft CPU: 用 SpinalHDL 写的一个 高度可配置的 RISC-V soft CPU 内核 (soft 的意思就是 CPU 不是硬件焊死的 (“hard CPU”) , 而是部署在 FPGA 上可以改变结构的).\n\nChisel: 另一种 HDL.\nScalac: Scala 编译器.\nsbt: Scala Build Tool. 配置依赖、插件和调用 scalac.\nMill: 跟 sbt 类似, 但更轻量.\n\nAmaranth: 一个 Python 库, 也是用于硬件描述和设计. 可生成 Verilog 代码.\n\nRTL: Register Transfer Level. 通俗说就是 verilog 代码的抽象程度水平.\n\n\n\n\nFPGA Principles\n\nPAR： Place and Route. 布局布线.\n\n\n\nFPGA Structure 结构\n\nBLE, CLB (Slice, LAB, ALM), SB: 见 FPGA 原理速成.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#submodules-项目中用到的核心子模块",
    "href": "glossary/glossary.html#submodules-项目中用到的核心子模块",
    "title": "Glossary 名词解释",
    "section": "Submodules 项目中用到的核心子模块",
    "text": "Submodules 项目中用到的核心子模块\n\n该项目重度使用了以下开源项目, FPGA 开源是一个很大的工程, 感谢所有开源者!\n\n\nverilator: 将 verilog 代码变成 C++ 代码, 然后编译并运行在 CPU 上进行仿真, 模拟出时钟、寄存器逻辑、外设交互等行为.\nverilator -cc blink.v # 生成 obj_dir/ 其中含有转换好的 C++ 代码\niverilog (Icarus Verilog): 也是仿真 (但不输出 C 代码):\niverilog -o blink.vvp blink.v blink_tb.v\n# 生成 vcd 文件可配合 GTKWave 查看波形\nvvp blink.vvp\nopenFPGALoader: 用于将比特流烧录到 FPGA (但不能调试).\n# 示例：\nopenFPGALoader -b arty arty_bitstream.bit      # SRAM 加载\nopenFPGALoader -b arty -f arty_bitstream.bit   # 写入 flash\nopenocd: Open On-Chip Debugger. 用于调试 FPGA 的工具. 支持 JTAG 接口.\n三个端到端的工具链:\n\nVivado: IDE, 闭源.\nyosysHQ (Yosys Open SYnthesis Suite Headquarters): yyds!! 一个开源的 EDA 工具链. 子项目包括:\n\nicestorm: 用于针对 Lattice iCE40 FPGA 实现完全的端到端开源流程, 从 Verilog 到 bitstream, 再烧写到 FPGA 板卡上. 以下每一个命令都是一个单独的 repo!!\n# yosys 综合 (将 verilog 转换为网表 .json)\nyosys -p 'synth_ice40 -top blink -json blink.json' blink.v\n# nextpnr 布局布线 (生成 bitstream 的中间文件 .asc)\nnextpnr-ice40 --up5k --json blink.json --pcf blink.pcf --asc blink.asc\n# icepack 打包 (生成 bitstream .bin)\nicepack blink.asc blink.bin\n# icesprog 烧写 (将 bitstream 写入 FPGA)\nsudo icesprog blink.bin\n\nF4PGA: 以前叫 Symbiflow, 旨在为多家 FPGA 供应商 (Xilinx 7 系列、Lattice iCE40/ECP5、QuickLogic EOS S3 等) 提供统一、功能完备、可扩展且无需专有软件的端到端开发流程.\n\n里面大量使用了 YosysHQ 的工具.\n\n\nSpinalHDL: 一个基于 Scala 的硬件描述语言 (HDL), 用于生成 Verilog 代码. SpinalHDL 提供了更高级的抽象和更强大的功能, 使得硬件设计更加灵活和可扩展.\n\nVexRiscv:\n\nLitex: 支持用 Python 脚本拼装出完整的 SoC.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#ml-terms",
    "href": "glossary/glossary.html#ml-terms",
    "title": "Glossary 名词解释",
    "section": "ML Terms",
    "text": "ML Terms\n\nMSE (Mean Squared Error): 可用作 Loss function.\nAUC (Area Under Curve): 二分类模型的性能评估指标, 越大越好.\nF-score: 二分类 (正类、负类) 模型的性能评估指标.\n\nTP (True Positive): 正类被正确分类为正类.\nFP (False Positive): 负类被错误分类为正类.\nFN (False Negative): 正类被错误分类为负类.\nRecall 召回率: \\(TP/TP+FP\\)\nPrecision 精确率: \\(TP/TP+FN\\)\nF1-score: Recall 和 Precision 的调和平均 (F-\\(\\beta\\) score 的特例)\nF-\\(\\beta\\) score: 仅仅是给 recall 加了权重.\n\n\nHyperparameter 超参数: 模型训练前需要设置的参数, 如学习率、batch size、层数, etc.\nA/B Test: 类似双盲实验, 比如研究修改按钮颜色能否提升点击率? 新模型是否真的比旧模型好? 可以用这种方法进行对比实验.\nTensorflow, JAX, PyTorch: 机器学习框架. 其实就是一些 Python 库.\nimport tensorflow as tf\nimport torch\nimport jax.numpy as jnp\n\nRISCV 上有 TfLM (TensorFlow Lite for Microcontrollers),\n\nTVM, XLA (Accelerated Linear Algebra): 机器学习编译器, 在以上三个框架内都有 python 的接口函数.\nAI 幻觉: AI 编造事实的现象.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#cpu-terms",
    "href": "glossary/glossary.html#cpu-terms",
    "title": "Glossary 名词解释",
    "section": "CPU Terms",
    "text": "CPU Terms\n\nPSR (Program Status Register): 程序状态寄存器. 有 NZVC (Negative, Zero, Overflow, Carry) 四个标志位.\nHart (Hardware Thread): 硬件线程, 指一个独立的处理器核心, 包括一套流水线, 寄存器, PC 等等 (今后将不提处理器核心这个概念, 只提 Hart).\nBenchmark: 基准测试. 用于测试系统或工具的功能/性能.\nQEMU (Quick Emulator): 开源的模拟器, 可模拟多种 CPU 架构 (如 ARM, x86, RISCV 等).\nRenode: 开源的模拟器, 主要面向嵌入式系统.\nEndianness1:\n\n\n\n大端与小端 [2]\n\n\n\n1 记忆: 小端是自然的, 因为大部分人喜欢洗小头 (",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#riscv",
    "href": "glossary/glossary.html#riscv",
    "title": "Glossary 名词解释",
    "section": "RISCV",
    "text": "RISCV\n\nABI (Abstract Binary Interface): 抽象二进制接口. 比如寄存器的使用约定 (比如函数传参用 a0~a7), 数据类型大小 (char 占几个字节等), 函数调用约定, 内存对齐等.\nHart (Hardware Thread): 硬件线程, 指一个独立的处理器核心, 包括一套流水线, 寄存器, PC 等等 (今后将不提处理器核心这个概念, 只提 Hart).\nPMP (Physical Memory Protection): 物理内存保护.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#c-compile-terms",
    "href": "glossary/glossary.html#c-compile-terms",
    "title": "Glossary 名词解释",
    "section": "C Compile Terms",
    "text": "C Compile Terms\n\ngcc (GNU Compiler Collection): GNU 编译器集合, 包括 C、C++、Go 等编程语言的编译器.\n\ngcc = clang (前端) + LLVM (后端) (在功能上)\n\nIR (Intermediate Representation): 一种中间表达式, 用于编译器优化和代码生成.\n\nGIMPLE: gcc 生成的中间表示\nLLVM IR: clang 生成的中间表示\n\nGDB (GNU Debugger): GNU 调试器. 支持 Assembly, C/C++, Go, Rust 等.\nelf (Executable Linkable Format): 可执行链接格式. 包含 .o, a.out, .so 等文件.\n\nBinutils (Binary Utilities): elf 文件处理相关工具, 包括:\n\nobjdump: 反汇编工具.\nobjcopy: 执行文件格式转换. elf 中还包含了很多运行时不需要的信息, objcopy 可将这些信息去掉生成 bin 文件.\nreadelf: 显示更多 elf 格式文件的信息.\nar: tar, 将多个文件打包成一个大文件.\n\n\n\n\n\n\n\n\nELF 文件格式 [2]\n\n\n\nCross Compilation: 交叉编译, 即在另一台机器上面开发手里面的这台机器 (嵌入式开发, 或在 MacOS 编写 RISCV 的操作系统).\n\n构建 (build) 系统: 生成可执行程序的计算机.\n主机 (host) 系统: 运行可执行程序的计算机.\n目标 (target) 系统: 可执行程序运行的计算机架构\n\n\n\n\n\n\n\n交叉编译",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#operating-system-terms",
    "href": "glossary/glossary.html#operating-system-terms",
    "title": "Glossary 名词解释",
    "section": "Operating System Terms",
    "text": "Operating System Terms\n\nRTOS (Real-Time Operating System): 实时操作系统, 用于嵌入式系统.\n\nFreeRTOS: 设计小巧, 核心代码只有 3 到 4 个 C 文件, 支持 ARM, x86, RISCV [2].\nRT-Thread: 也是一个 RTOS",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#ysyx-terms",
    "href": "glossary/glossary.html#ysyx-terms",
    "title": "Glossary 名词解释",
    "section": "YSYX Terms",
    "text": "YSYX Terms\n\nAM (Abstraction Machine): 抽象机, 用程序模拟的硬件计算机.\nNPC (New Processor Core): 指我们自己设计的处理器.\n\n\n\n\n\n1. YSYX (2025) E5 从 RTL 代码到可流片版图 | 官方文档\n\n\n2. Lazyparser (2025) Compilation and linker",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html",
    "href": "env-setup/env-setup.html",
    "title": "FPGA 开发环境配置",
    "section": "",
    "text": "Arty A7-100T CFU-playground 环境配置\n资料:",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html#arty-a7-100t-cfu-playground-环境配置",
    "href": "env-setup/env-setup.html#arty-a7-100t-cfu-playground-环境配置",
    "title": "FPGA 开发环境配置",
    "section": "",
    "text": "官方 CFU Playground Setup Guide, 官方 CFU Github\nMy Forked CFU Playground\n\n\nMacOS Docker 部署\n以下是本人在 MacOS 试过的两种失败的方法, 供参考:\n\n\n\n\n\n\n\nMacOS 原生部署 (未成功)\n\n\n\n\n\n官方 Setup Guide 不适用于 MacOS, 本教程可以配合官方教程. 以下是在 14-inch MacBook Pro (M2 pro) 上我执行过的命令, 可能有不必要的步骤. 另外我之前安装过一些工具如 make, brew, openocd 等, 如有漏掉的步骤请用 brew 自行安装.\n\nCFU 环境配置\ngit clone https://github.com/google/CFU-Playground.git\ncd CFU-Playground\n# Check necessary tools\nwhich gcc\nwhich make\nwhich brew\nbrew install openocd ccache verilator ninja libusb libftdi\nwhich expect\n将 scripts/setup 中的 line 58-60 替换为:\n# Check for libusb development libraries\nif [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n    # macOS: check for Homebrew libusb\n    if ! brew list libusb &gt;/dev/null 2&gt;&1 || ! brew list libftdi &gt;/dev/null 2&gt;&1; then\n        missing+=(libusb libftdi)\n    fi\nelse\n    # Linux: check for apt packages\n    if ! (apt list -i | grep libusb-1.0-0-dev) ; then\n        missing+=(libusb-1.0-0-dev libftdi1-dev)\n    fi\nfi\n再运行:\n# Should end up \"Setup complete\"\n./scripts/setup\nAmaranth 能让你用 Python 写硬件描述语言, 我们暂时不安装.\nFPGA 开源工具链 SymbiFlow 配置\nSymbiFlow 是一个开源的 FPGA 工具链, 支持我们用的 Arty A7-35T 开发板. F4PGA (Framework for FPGA) 是它的下一代.\nMacOS 上会遇到以下问题:\n\ndfu-util 包不可用\nflterm 包不可用\nPython 3.7 不支持\n\n执行:\nbrew install dfu-util yosys\n将 conf/environment-symbiflow.yml 中替换为:\nname: cfu-symbiflow\nchannels:\n- defaults\n- conda-forge\ndependencies:\n# Basic Python packages that should be available\n- lxml\n- simplejson\n- intervaltree\n- json-c\n- libevent\n- python=3.9\n- pip\n- pip:\n    - -r ./requirements-symbiflow.txt\n然后运行:\nrm -rf env/symbiflow && make install-sf\n出现以下输出时表示安装成功:\nDone installing SymbiFlow.  To enter the environment, type 'make enter-sf', which creates a new subshell, and 'exit' when done.\n测试环境:\nmake enter-sf\nexit\n以上方法会在执行 zsh  make prog TARGET=digilent_arty USE_SYMBIFLOW=1\n时出现错误, 因为我们删掉了很多 python 依赖. 这些依赖在 litex-hub 源里面没有 osx-arm64 的版本!!!\n\n\n\n\n\n\n\n\n\n\n\n\nMacOS 虚拟机部署 (未成功)\n\n\n\n\n\nCFU playground 里的 environment-symbiflow 里的很多依赖 (比如 dfu-util 和 flterm 等, 可以在 Anaconda 里面搜索你需要的包) 只支持 linux-64 版本, M 芯片的 MacOS 上的 PD 好像只能安装 linux-aarch64 架构的虚拟机.\n\n\n\ngcc-riscv32-elf-newlib 只支持 linux-64\n\n\n在你安装的虚拟机终端执行:\narch\n不能是 aarch64 才行, 需要是 x86_64 才能安装 linux-64 架构的包!!!\n\n\n\n\n我们利用 Docker 来搭建 CFU Playground 环境, 这样可以避免 MacOS 上的架构问题. 自行安装 Docker, 然后需要稍微改一下 scripts/Dockerfile 和 scripts/setup 脚本. 可以直接 clone 我的 fork:\ngit clone https://github.com/Marcobisky/CFU-Playground.git\n然后切换到 macos-env 分支, 在 CFU-Playground 目录下执行:\n# Takes around 20 min\ndocker build -t cfu-playground --platform linux/amd64 ./scripts\n查看镜像:\ndocker images\n逐条执行, 其中 -v $(pwd):/workspace 表示当前目录 (宿主机)挂载到容器的 /workspace 目录中 (数据共享通道). 但是以下命令不要在 /workspace 里面执行:\ndocker run -it -v $(pwd):/workspace cfu-playground bash\n./scripts/setup\n# Takes around 9 min\nmake install-sf\nmake enter-sf\ncd proj/proj_template\nmake clean\nmake bitstream TARGET=digilent_arty USE_SYMBIFLOW=1\n如果没报错, 恭喜你成功生成了比特流文件! 当你没插上板子的时候如果按照官方运行 make prog TARGET=digilent_arty USE_SYMBIFLOW=1 会报错:\nError: libusb_init() failed with LIBUSB_ERROR_OTHER\n\nTraceback (most recent call last):\n  File \"./common_soc.py\", line 57, in &lt;module&gt;\n    main()\n  File \"./common_soc.py\", line 53, in main\n    workflow.run()\n  File \"/CFU-Playground/soc/board_specific_workflows/general.py\", line 127, in run\n    self.load(soc, soc_builder)\n  File \"/CFU-Playground/soc/board_specific_workflows/general.py\", line 116, in load\n    prog.load_bitstream(bitstream_filename)\n  File \"/CFU-Playground/third_party/python/litex/litex/build/openocd.py\", line 27, in load_bitstream\n    self.call([\"openocd\", \"-f\", config, \"-c\", script])\n  File \"/CFU-Playground/third_party/python/litex/litex/build/generic_programmer.py\", line 101, in call\n    raise OSError(msg)\nOSError: Error occured during OpenOCD's call, please check:\n- OpenOCD installation.\n- Access permissions.\n- Hardware and cable.\n- Bitstream presence.\n即 libusb_init() 函数初始化错误. 事实上不可能通过 Docker 给开发版烧录, MacOS 环境有一个隔离层, GPT 如是说:\n\n\n\n不可能通过 Docker 给开发版烧录\n\n\n可以用两次 exit 退出容器 (第一次只会退出 enter-sf 的子 shell).\n如果要交互式运行已经存在的容器 (例如叫 romantic_austin), 运行:\ndocker start -ai romantic_austin\n\n\nUbuntu 24.04 实体机部署\n我们用 Arty A7-100T 开发板.\n具体运行步骤几乎与 MacOS 一样, 直接按照 Setup Guide 执行即可. 如果 make install-sf 报错:\nwget -qO- https://storage.googleapis.com/symbiflow-arch-defs/artifacts/prod/foss-fpga-tools/symbiflow-arch-defs/continuous/install/20220729-181657/symbiflow-arch-defs-install-xc7-7833050.tar.xz | tar -xJC env/symbiflow/xc7/install\nxz: (stdin): File format not recognized\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now\nmake: *** [Makefile:58: install-sf] Error 2\n仅仅是网络连接的问题, 请把科学上网 (如 Clash Verge) 安装上 Service Mode, 然后打开 Tun Mode. 把 Makefile 中 63-65 行的三个 wget 改成 curl 的写法. 在我的 fork 上已经更改, 直接 clone 即可:\ngit clone https://github.com/Marcobisky/CFU-Playground.git\n让后切换到 ubuntu-env 分支, 即可跑通 make install-sf.\n如果没插入开发板, 运行:\nmake bitstream TARGET=digilent_arty USE_SYMBIFLOW=1\n即可跑通. 若已经插入开发板, 则运行:\nmake prog TARGET=digilent_arty USE_SYMBIFLOW=1 EXTRA_LITEX_ARGS='--variant=a7-100'\nmake load BUILD_JOBS=4 TARGET=digilent_arty EXTRA_LITEX_ARGS='--variant=a7-100'\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\n如果你跟我一样用的是 Arty A7-100T 而不是 35T, 必须加上 EXTRA_LITEX_ARGS='--variant=a7-100' 参数 (见 CFU Wiki), 否则程序会卡在 make load 这一步, 并且会一直卡在这里 (按 enter 也没有用, 只能两下 Ctrl+C 退出):\n/home/merlin/fpga/CFU-Playground/soc/bin/litex_term --speed 3686400  --kernel /home/merlin/fpga/CFU-Playground/proj/proj_template/build/software.bin /dev/ttyUSB1\n当然卡在这里还有可能是其它问题: 见 Issue #787, Issue #775.",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html#icesugar-up5k-开发环境配置",
    "href": "env-setup/env-setup.html#icesugar-up5k-开发环境配置",
    "title": "FPGA 开发环境配置",
    "section": "iCESugar-UP5K 开发环境配置",
    "text": "iCESugar-UP5K 开发环境配置\n资料:\n\n官方 icesugar: 重要! 用它来学习 iCESugar-UP5K 开发板.\nMy TinyML Repo\n\n\nMacOS 部署\n如果你没有安装 Homebrew 包管理器, 请先安装 (会自动先安装 Xcode 命令行工具, 输入密码的过程不可见, 装完了要按照提示将 brew 添加到 PATH 中):\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n直接按 nextpnr 中的 next-pnr-ice40 的说明安装即可. 大致为以下几个命令 (可能有遗漏), 逐条执行:\ngit clone https://github.com/YosysHQ/nextpnr.git\ncd nextpnr\n# May not be successful immediately\nbrew install cmake python boost eigen\ngit submodule update --init --recursive\nbrew install boost\n# These two lines just to make sure dependencies are installed\nbrew install eigen\nmkdir -p build && cd build\ncmake .. -DARCH=ice40 -DICESTORM_INSTALL_PREFIX=/usr -DICEBOX_DATADIR=/usr/share/fpga-icestorm/chipdb\n# May be some error, please solve by yourself using GPT.\nmake -j$(nproc)\n# Check if nextpnr-ice40 is built\nls -la nextpnr-ice40\n# Install placing, routing and binary database format files\nsudo make install\n\n\nUbuntu 24.04 实体机部署\n按 nextpnr 中的 next-pnr-ice40 的说明安装即可. i.e., 逐条执行:\ngit clone https://github.com/YosysHQ/nextpnr.git\nsudo apt update\nsudo apt install libboost-all-dev libboost-filesystem-dev libboost-program-options-dev libboost-iostreams-dev libboost-system-dev libboost-thread-dev libeigen3-dev\ngit submodule update --init --recursive\nmkdir -p build && cd build\nsudo apt install fpga-icestorm\ncmake .. -DARCH=ice40 -DICESTORM_INSTALL_PREFIX=/usr -DICEBOX_DATADIR=/usr/share/fpga-icestorm/chipdb\nmake -j$(nproc)\n# Check if nextpnr-ice40 is built\nls -la nextpnr-ice40\n# Install placing, routing and binary database format files\nsudo make install\n\n\nblink 例子测试\n用 My TinyML Repo 的 blink 例子测试一下. 将 iCESugar 开发板连接到电脑 (注意不要用 JTAG 调试器, 直接用 C 口连接电脑). 按以下方式生成比特流 blink.bin:\ncd iCESugar/examples/blink\nmake\n在 Ubuntu 上可通过以下方式烧录:\nsudo icesprog blink.bin\n在 MacOS 上, 好像安装不上 icesprog, 直接将 blink.bin 拷贝到 iCESugar 虚拟磁盘上即可烧录.\n\n\n\n\n\n\n\n烧录方法注意\n\n\n\n\n\n\nUbuntu\n一定要用 sudo icesprog! 单用 iceprog 会报错:\ninit..\nCan't find iCE FTDI USB device (vendor_id 0x0403, device_id 0x6010 or 0x6014).\nABORT.\nMacOS\n注意 MacOS 上 iceprog 和 icesprog 烧录工具都不能用!\nMacOS 上的烧录工具 iceprog 不能识别到 FTDI 设备, 这可能是 MacOS 上的 USB 设备权限问题, 本人尝试过安装 FTDI 驱动, 安装手册见这里. 安装的时候如果不小心点了 OK, 安装程序会提示 “awaiting approval”, 解决方法见这里. 但是安装好了, Mac 还是识别不到开发板.",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html#vivado-vitis-hls-安装-ubuntu-24.04",
    "href": "env-setup/env-setup.html#vivado-vitis-hls-安装-ubuntu-24.04",
    "title": "FPGA 开发环境配置",
    "section": "Vivado & Vitis HLS 安装 (Ubuntu 24.04)",
    "text": "Vivado & Vitis HLS 安装 (Ubuntu 24.04)\n\n这个是备选项, 不严格要求. 有一说一 Vivado 的 block diagram 界面还是挺好的 (\n\n\n去官网下载最新的 Vivado 2025.1 即可.\n注意 Vitis HLS 工具和 Vivado 软件是分开的! 安装软件的时候我们可以先选择 Vivado ML Enterprise, 装完之后用它的 Add Design Tools or Devices 工具来 upgrade:\n\n\n\nupgrade 的时候要选择 Vitis Unified Software Platform!!\n\n\n安装完成后, 会发现 Vitis 2025.1 GUI (Figure fig-vitis-gui) 打不开, 我们需要换这个库: libstdc++, 解决方法参考 这里. 大致的步骤就是:\ncd &lt;installation_path&gt;/Xilinx/2025.1/Vitis/lib/lnx64.o/Ubuntu\nsudo -s\napt update && apt install libstdc++6:amd64\nmv libstdc++.so libstdc++.so.origin\nmv libstdc++.so.6 libstdc++.so.6.origin\nln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6\nln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6 libstdc++.so\n\n\n\n\n\n\n\n\n\nFigure 1: Vitis 的 GUI 在 Ubuntu 24.04 上打不开\n\n\n\n\nFigure fig-vitis-gui 打开后的界面:\n\n\n\nVitis 界面\n\n\nHLS 开发界面 (好像还能接受?)\n\n\n\nHLS 界面",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html#sbt-安装-ubuntu-24.04",
    "href": "env-setup/env-setup.html#sbt-安装-ubuntu-24.04",
    "title": "FPGA 开发环境配置",
    "section": "SBT 安装 (Ubuntu 24.04)",
    "text": "SBT 安装 (Ubuntu 24.04)\nVexRiscv 是 CFU-Playground 的一个重要子模块, 它是一个 RISC-V 软核 CPU 内核, 用 SpinalHDL 写的. 我们需要安装 Scala Build Tool (SBT) 来将 .scala 文件转换为 RTL 代码. 但官方文档会安装很多不必要的工具, 如果只要装 SBT 的话, 可以在 Ubuntu 24.04 执行:\n# 更新包管理器\nsudo apt-get update\n\n# 安装Java JDK 8 (SpinalHDL需要)\nsudo apt-get install openjdk-8-jdk -y\n\n# 设置Java版本（如果系统有多个Java版本）\nsudo update-alternatives --config java\nsudo update-alternatives --config javac\n\n# 安装SBT (Scala构建工具)\necho \"deb https://repo.scala-sbt.org/scalasbt/debian all main\" | sudo tee /etc/apt/sources.list.d/sbt.list\ncurl -sL \"https://keyserver.ubuntu.com/pks/lookup?op=get&search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823\" | sudo apt-key add\nsudo apt-get update\nsudo apt-get install sbt\n验证安装:\nsbt --version\n生成 VexRiscv 的 RTL 代码:\ngit clone https://github.com/SpinalHDL/VexRiscv.git\ncd VexRiscv\nsbt \"runMain vexriscv.demo.GenFull\"\n运行完会在根目录产生 VexRiscv.v 文件, 导入 Vivado 即可.",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html#ysyx-环境搭建",
    "href": "env-setup/env-setup.html#ysyx-环境搭建",
    "title": "FPGA 开发环境配置",
    "section": "YSYX 环境搭建",
    "text": "YSYX 环境搭建\n\n跟踪环境搭建 (MacOS 和 Ubuntu 24.04)\n为了同时在 MacOS 和 Ubuntu 24.04 进行 YSYX 作业的提交, 先在 MacOS 上生成一堆密钥:\nssh-keygen\n名字可以随便起, 比如: ~/.ssh/id_ysyx_ed25519 和 ~/.ssh/id_ysyx_ed25519.pub 即可, 私钥不要设置密码 (按 Enter 即可). 公钥添加到 GitHub 的 SSH keys 中. 执行:\nnslookup github.com\n如果输出类似:\nServer:     198.18.0.2\nAddress:    198.18.0.2#53\n\nNon-authoritative answer:\nName:   github.com\nAddress: 198.18.0.57\n说明网络环境存在 DNS 劫持 (可能是梯子把 把 github.com 映射成了假的 IP 地址 198.18.0.57, 所以你的设备根本没法访问 GitHub 的真实服务器 (导致 SSH 失败)). 解决方法: 配置 ~/.ssh/config 走端口 443:\n\n\n~/.ssh/config\n\n# Add this to your ~/.ssh/config file\nHost github.com\n    HostName ssh.github.com\n    Port 443\n    User git\n    IdentityFile ~/.ssh/id_ysyx_ed25519\n    IdentitiesOnly yes\n\n运行:\nssh -T git@github.com\n如果输出:\nHi &lt;YourName&gt;! You've successfully authenticated, but GitHub does not provide shell access.\n说明 SSH 连接成功. 然后按照 YSYX E3 执行:\ngit clone -b master git@github.com:OSCPU/ysyx-workbench.git\n即可. 按照官方的说法先玩一下, 把该执行的都执行了, 比如:\ngit branch -m master\nbash init.sh nemu\nbash init.sh abstract-machine\n等等 (让他先有一些 git log). 然后创建一个 Private 的 GitHub Repo, 与你本地的 ysyx-workbench 目录关联:\n# 先把原来的 origin 改个名字，比如 oscpu\ngit remote rename origin oscpu\n\n# 然后添加你自己的仓库为新的 origin\ngit remote add origin https://github.com/&lt;Yourname&gt;/ysyx-workbench.git\n然后 push 到 origin (不是 oscpu) 即可.\n在 Ubuntu 24.04 上, 同样将文件 ~/.ssh/id_ysyx_ed25519 复制过去, 然后执行:\nchmod 600 ~/.ssh/id_ysyx_ed25519\nls -la ~/.ssh/id_ysyx_ed25519\nchmod 700 ~/.ssh\nls -ld ~/.ssh\nssh -T git@github.com\n如果成功, 将你自己的 ysyx-workbench 仓库 clone 到 Ubuntu 上:\ngit clone git@github.com:&lt;Yourname&gt;/ysyx-workbench.git\n可以通过\ngit log tracer-ysyx\n查看系统跟踪日志.\n\n\nNEMU 环境搭建 (Ubuntu 24.04)\n如果 make run 失败, 则可能需要:\necho $NEMU_HOME # 如果没有输出, 则需要设置 NEMU_HOME 环境变量\necho \"export NEMU_HOME=/home/marcobisky/LocalFiles/LIYUN/proj/ysyx-workbench/nemu\" &gt;&gt; ~/.bashrc # 换成你的 nemu 路径\nsource ~/.bashrc && echo $NEMU_HOME\n\nmake menuconfig # 如果失败, 则安装缺失的库然后重新运行.\nsudo apt update && sudo apt install bison flex\n\nmake run # 如果失败, 则需要检查错误信息并安装缺失的库, 比如:\nsudo apt install libreadline-dev\nmake run 运行后会有一个断言失败, 这是故意的练习提示:\nWelcome to riscv32-NEMU!\nFor help, type \"help\"\n[src/monitor/monitor.c:35 welcome] Exercise: Please remove me in the source code and compile NEMU again.\nriscv32-nemu-interpreter: src/monitor/monitor.c:36: welcome: Assertion `0' failed.\nmake: *** [/home/marcobisky/LocalFiles/LIYUN/proj/ysyx-workbench/nemu/scripts/native.mk:38: run] Aborted (core dumped)\n删除以下行即可:\n\n\nsrc/monitor/monitor.c\n\n    assert(0);",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "c-riscv-asm/c-riscv-asm.html",
    "href": "c-riscv-asm/c-riscv-asm.html",
    "title": "C 和 RISCV 汇编",
    "section": "",
    "text": "C 编译过程\n装好 RISCV 编译工具链, 创建一个简单的 C 语言程序 hello.c:\n运行:\n用 riscv32-unknown-elf-readelf 查看生成的 .o 文件:\n得到:\n再查看 Section 信息:\n得到:\n对 .o 文件进行反汇编:\n得到:",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C 和 RISCV 汇编</span>"
    ]
  },
  {
    "objectID": "c-riscv-asm/c-riscv-asm.html#c-编译过程",
    "href": "c-riscv-asm/c-riscv-asm.html#c-编译过程",
    "title": "C 和 RISCV 汇编",
    "section": "",
    "text": "Compiler, Assembler, Linker:\n\nWatch this video\n\n\ngcc 编译选项:\n\n-E: 只预处理, 不编译.\n-S: 生成汇编代码 (.s 文件)\n-c: 只编译, 不链接. (生成 .o 文件)\n-o &lt;file&gt;: 指定输出文件名.\n-g: 在输出的文件中加入支持调试的信息.\n-v (verbose): 显示编译过程中的详细信息.\n\n\n\n\n\n\n\n编译过程\n\n\n\n\n\nhello.c\n\n#include &lt;stdio.h&gt;\n\nint global_init = 0x11111111;\nconst int global_const = 0x22222222;\n\nvoid main()\n{\n    static int static_var = 0x33333333;\n    static int static_var_uninit;\n    int auto_var = 0x44444444;\n    printf(\"hello world!\\n\");\n    return;\n}\n\n\nriscv32-unknown-elf-gcc -c hello.c -o hello.o # 只编译, 不链接\n\nriscv32-unknown-elf-readelf -h hello.o &gt; header_info.log # 查看 Header 信息, 并输出到文件\n\n\n\nheader_info.log\n\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              REL (Relocatable file)\n  Machine:                           RISC-V\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          0 (bytes into file)\n  Start of section headers:          916 (bytes into file)\n  Flags:                             0x5, RVC, double-float ABI\n  Size of this header:               52 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           40 (bytes)\n  Number of section headers:         14\n  Section header string table index: 13\n\n\n\nriscv32-unknown-elf-readelf -S hello.o &gt; section_info.log # 查看 Section 信息, 并输出到文件\n\n\n\nsection_info.log\n\nThere are 14 section headers, starting at offset 0x394:\n\nSection Headers:\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\n  [ 1] .text             PROGBITS        00000000 000034 00002e 00  AX  0   0  2\n  [ 2] .rela.text        RELA            00000000 0002d8 000048 0c   I 11   1  4\n  [ 3] .data             PROGBITS        00000000 000062 000000 00  WA  0   0  1\n  [ 4] .bss              NOBITS          00000000 000064 000004 00  WA  0   0  4\n  [ 5] .sdata            PROGBITS        00000000 000064 000008 00  WA  0   0  4\n  [ 6] .srodata          PROGBITS        00000000 00006c 000004 00   A  0   0  4\n  [ 7] .rodata           PROGBITS        00000000 000070 00000d 00   A  0   0  4\n  [ 8] .comment          PROGBITS        00000000 00007d 00001a 01  MS  0   0  1\n  [ 9] .note.GNU-stack   PROGBITS        00000000 000097 000000 00      0   0  1\n  [10] .riscv.attributes RISCV_ATTRIBUTE 00000000 000097 000066 00      0   0  1\n  [11] .symtab           SYMTAB          00000000 000100 000130 10     12  15  4\n  [12] .strtab           STRTAB          00000000 000230 0000a7 00      0   0  1\n  [13] .shstrtab         STRTAB          00000000 000320 000074 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  D (mbind), p (processor specific)\n\n\n\nriscv32-unknown-elf-objdump -S hello.o &gt; disassembly.s # 反汇编, 并输出到文件\n\n\n\ndisassembly.s\n\n\nhello.o:     file format elf32-littleriscv\n\n\nDisassembly of section .text:\n\n00000000 &lt;main&gt;:\n   0:   1101                    addi    sp,sp,-32\n   2:   ce06                    sw  ra,28(sp)\n   4:   cc22                    sw  s0,24(sp)\n   6:   1000                    addi    s0,sp,32\n   8:   444447b7            lui a5,0x44444\n   c:   44478793            addi    a5,a5,1092 # 44444444 &lt;static_var.0+0x44444440&gt;\n  10:   fef42623            sw  a5,-20(s0)\n  14:   000007b7            lui a5,0x0\n  18:   00078513            mv  a0,a5\n  1c:   00000097            auipc   ra,0x0\n  20:   000080e7            jalr    ra # 1c &lt;main+0x1c&gt;\n  24:   0001                    nop\n  26:   40f2                    lw  ra,28(sp)\n  28:   4462                    lw  s0,24(sp)\n  2a:   6105                    addi    sp,sp,32\n  2c:   8082                    ret",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C 和 RISCV 汇编</span>"
    ]
  },
  {
    "objectID": "c-riscv-asm/c-riscv-asm.html#riscv-汇编语言",
    "href": "c-riscv-asm/c-riscv-asm.html#riscv-汇编语言",
    "title": "C 和 RISCV 汇编",
    "section": "RISCV 汇编语言",
    "text": "RISCV 汇编语言\n\n基本格式:\n&lt;label&gt;: &lt;operation&gt; # &lt;comment&gt;\n\n&lt;operation&gt; 的类型 [1]:\n\ninstruction (指令)\npseudo-instruction (伪指令): li x6, 5, nop, RISCV 中有定义\ndirective (伪操作): .macro ... .endm, .end, .text, .global _start 告知汇编器的指示, 与 RISCV 规范无关.\nmacro (宏):\n.macro do_nothing\n    nop\n.endm\n\n_start: do_nothing # 调用宏, 汇编器会将它展开\n\n\n标签其实表示地址:\n_start: li x6, 5 # _start 标签其实就是这条指令的地址\n\n\n\n\n\n1. Lazyparser (2025) Compilation and linker",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C 和 RISCV 汇编</span>"
    ]
  },
  {
    "objectID": "riscv/riscv.html",
    "href": "riscv/riscv.html",
    "title": "RISCV ISA",
    "section": "",
    "text": "RISCV Extensions\nIn RISC-V, extensions are optional instruction sets that extend the base ISA (RV32I, 32-bit integer instructions) to add extra functionality.\nSome extensions are listed here:\nFor example, RV32IMAC → A 32-bit RISC-V CPU with Integer (I), Multiply (M), Atomic (A), and Compressed (C) extensions. RV32IMAFD can be reduced to written as RV32G.",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>RISCV ISA</span>"
    ]
  },
  {
    "objectID": "riscv/riscv.html#riscv-extensions",
    "href": "riscv/riscv.html#riscv-extensions",
    "title": "RISCV ISA",
    "section": "",
    "text": "Extension\nMeaning\nPurpose\n\n\n\n\nM\nInteger Multiplication & Division\nAdds mul, div, rem instructions\n\n\nA\nAtomic Instructions\nAdds atomic memory operations (e.g., amoadd.w)\n\n\nF\nSingle-Precision Floating Point\nSupports float (32-bit) operations\n\n\nD\nDouble-Precision Floating Point\nSupports double (64-bit) operations\n\n\nC\nCompressed Instructions\nReduces code size (e.g., c.add, c.sw)\n\n\n\n\n\nZicsr: Z (Standard), I (Integer), CSR (Support read and write to CSRs)",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>RISCV ISA</span>"
    ]
  },
  {
    "objectID": "riscv/riscv.html#指令类型",
    "href": "riscv/riscv.html#指令类型",
    "title": "RISCV ISA",
    "section": "指令类型",
    "text": "指令类型\n\nALU 运算\n\nOne category of instructions is arithmetic operations (abbr. aluop), which is just doing things between GPRs.\nCommonly Used aluop instructions:\nlui t0, 0x40000     ;t0 = 0x40000 &lt;&lt; 12 (load upper 20 bits of the imm)\n\nadd t0, t1, t2      ;t0 = t1 + t2\nsub t0, t1, t2      ;t0 = t1 - t2 (no imm version)\nor t0, t1, t2       ;t0 = t1 | t2\nand t0, t1, t2      ;t0 = t1 & t2\nxor t0, t1, t2      ;t0 = t1 ^ t2\n\naddi t0, t1, 10     ;t0 = t1 + 10 (decimal)\nori t0, t1, 0xF     ;t0 = t1 | 0xF\nandi t0, t1, 0xF    ;t0 = t1 & 0xF\nxori t0, t1, 0xF    ;t0 = t1 ^ 0xF\n\nsll t0, t1, t2      ;t0 = t1 &lt;&lt; t2 (shift left logical)\nsrl t0, t1, t2      ;t0 = t1 &gt;&gt; t2 (shift right logical)\nsra t0, t1, t2      ;t0 = t1 &gt;&gt; t2 (shift right arithmetic, preserve sign)\n\nslli t0, t1, 2      ;t0 = t1 &lt;&lt; 2\nsrli t0, t1, 2      ;t0 = t1 &gt;&gt; 2\nsrai t0, t1, 2      ;t0 = t1 &gt;&gt; 2 (preserve sign)\n\nslt t0, t1, t2      ;t0 = (t1 &lt; t2) (set if less than signed)\nsltu t0, t1, t2     ;t0 = (t1 &lt; t2) (set if less than unsigned)\n\nslti t0, t1, -5     ;t0 = (t1 &lt; -5) (imm signed)\nsltiu t0, t1, 10    ;t0 = (t1 &lt; 10) (imm unsigned)\n\n\n\nCSR 寄存器及其操作\n\nIntroduction\n\nCSR (Control and Status Registers)\nAre accessed using CSR instructions, not via memory-mapped I/O like GPIO registers.\nGPRs can be accessed at any privilege level, while CSRs are defined at a specific privilege level and can only be accessed by that level and any levels of higher privilege.\nEvery CSR has a unique address, each 32 bits share one address (instead of 8 bits).\nCSR addresses are 12-bits, meaning that up to 4,096 CSRs can be implemented (\\(2^12 = 4096\\)). The bits in a CSR address define its accessibility, use, and CSR number. \nWhile GPRs are used for storing data used to perform operations, CSRs typically modify the behavior of a hart (i.e. “Control”) or inform of its state and attributes (i.e. “Status”), or both.\nWARL (Write any, read legal): Some field in a CPU register that allows any value to be written, but when read back, it returns only a valid (legal) value. For example, in MPP[12:11] field in mstatus register, we have:\n\n\n\n\nWrite Attempt (MPP)\nStored Value (MPP field)\n\n\n\n\n00 (User)\n✅ 00 (User mode)\n\n\n11 (Machine)\n✅ 11 (Machine mode)\n\n\n01 (Illegal)\n🔄 Returns 00 or 11 (Legal)\n\n\n10 (Illegal)\n🔄 Returns 00 or 11 (Legal)\n\n\n\n\nCSRs related intimitely to interrupts and exceptions (interrupts are external (“asynchronise”), exceptions are internal (“synchronise”, usually through software or timer), some place confuse them though, but it’s okay).\n\n\n\nCommonly Used CSRs and their sub-fields\nThe registers are labelled in this format: reg (addr, reset_val).\n\n\n\nPart of the registers\n\n\n\nmstatus (0x300, 0x00001800): Machine Status (lower 32 bits), controls global interrupt enable and privilege modes.\n\n\nmstatus.MPP[12:11]: Machine Previous Priviledge mode. When an mret is executed, the privilege mode is change to this value.\nmstatus.MIE[3]: Machine (global) Interrupt Enable.\nmstatus.MPIE[7]: Machine previous Interrupt Enable. When an interrupt occurs, the content in mstatus.MIE is loaded into this bit (and for simplicity, mstatus.MIE is changed to 0, so no other interrupts is allowed to come in), and after the interrupt is processed (after mret), this bit is restored into mstatus.MIE again.\n\n\nmisa (0x301, depends on RV32 and M_EXT):\nmie (0x304, 0x00000000): Machine Interrupt Enable, enables specific interrupts (not global). Also you should have a look at mip (0x344).\nmip (0x344): Machine Interrupt Pending Register, indicates which specific interrupts are pending. \n\nMSIP/MSIE[3]: Machine Software Interrupt Pending/Enable\nMTIP/MTIE[7]: Machine Timer Interrupt Pending/Enable\nMEIP/MEIE[11]: Machine External Interrupt Pending/Enable\n\nmtvec (0x305, ): Machine Trap-Handler Base Address, specifies where the CPU jumps on an interrupt/exception. \n\nMODE[1:0]:\n\n00: Direct. All traps (either interrupts or exceptions) set PC directly to BASE.\n01: Vectored. Exceptions will set PC directly to BASE, while (asynchronous) interrupts will set PC to BASE+4*mcause.Exception Code (See mcause register.)\nothers: invalid.\n\n\nmepc (0x341, 0x00000000): Machine Exception Program Counter, saves the address of the interrupted instruction.\n\nWhen an interrupt occurs, the current PC + 1 is saved in mepc.\nWhen an exception is encountered, the current PC is saved in mepc. (Why? The exception may triggered by the instruction at the current PC, maybe we solve the exception in the interrupt handler, so give it another chance to execute that instruction again.)\n\nand the core jumps to the exception address. When a mret instruction is executed, the value from mepc replaces the current program counter.\nmcause (0x342): Machine Trap Cause, identifies the cause of the interrupt/exception. \n\nInterrupt[31]:\n\n1: Exceptions\n0: Interrupts\n\nException Code[30:0]: (pay special attention to the number 3/7/11)\n\n\n\n\n\n\n\n\nInterrupt[31]\nException Code[30:0]\nDescription\n\n\n\n\n1\n0, 2, 4, 6, 8, 10, 12, 14-15\nReserved\n\n\n1\n1 / 3\nSupervisor/Machine software interrupt\n\n\n1\n5 / 7\nSupervisor/Machine timer interrupt\n\n\n1\n9 / 11\nSupervisor/Machine external interrupt\n\n\n1\n13\nCounter-overflow interrupt\n\n\n1\n≥16\nDesignated for platform use\n\n\n0\n0\nInstruction address misaligned\n\n\n0\n1\nInstruction access fault\n\n\n0\n2\nIllegal instruction\n\n\n0\n3\nBreakpoint\n\n\n0\n4\nLoad address misaligned\n\n\n0\n5\nLoad access fault\n\n\n0\n6 / 7\nStore/AMO address/access fault\n\n\n0\n8 / 9 / 11\nEnvironment call from U/S/M-mode\n\n\n0\n10, 14, 17, 20-23, 32-47, ≥64\nReserved\n\n\n0\n12\nInstruction page fault\n\n\n0\n13\nLoad page fault\n\n\n0\n15\nStore/AMO page fault\n\n\n0\n16\nDouble trap\n\n\n0\n18\nSoftware check\n\n\n0\n19\nHardware error\n\n\n0\n24-31, 48-63\nDesignated for custom use\n\n\n\n\nmtval (0x343): Machine Trap Value, provides extra information about exceptions (their addresses and so on)\n\n\n\nCommonly Used CSR instructions\n;register version:\ncsrrw x5, mstatus, x10  ;x5 = mstatus (read), mstatus = x10 (write)\ncsrw mtvec, t0          ;mtvec = t0 (write only)\ncsrrs x5, mie, x10      ;x5 = mie (read), mie |= x10 (set)\ncsrrc x5, mie, x10      ;x5 = mie (read), mie &= x10 (clear)\n\n;imm version:\ncsrrwi x5, mstatus, 0x1 ;x5 = mstatus (read), mstatus = 0x1 (write imm)\ncsrrsi x5, mie, 0x1     ;x5 = mie (read), mie |= 0x1 (set imm)\ncsrrc x5, mie, 0x1      ;x5 = mie (read), mie &= 0x1 (clear imm)\nConvenient pseudo-instructions:\ncsrr rd, csr    ;csrrs rd, csr, x0\ncsrw csr, rs    ;csrrw x0, csr, rs\ncsrs csr, rs    ;csrrs x0, csr, rs\ncsrc csr, rs    ;csrrc x0, csr, rs\ncsrwi csr, imm  ;csrrwi x0, csr, imm\ncsrsi csr, imm  ;csrrsi x0, csr, imm\ncsrci csr, imm  ;csrrci x0, csr, imm\n\n\n\nGPRs 通用寄存器\n\nIntroduction\nThe 32 registers in RISC-V are called general-purpose registers (GPRs, or “integer registers”). They are used for various purposes, such as holding data, addresses, or temporary values during program execution. These registers are 32 bits wide in the RV32I ISA and are identified as x0 to x31.\nEach register has a conventional name that indicates its intended usage, although these names are just conventions, and you can use them for other purposes if needed.\n\n\n\n通用寄存器的 ABI 规范\n\n\n\n\nPartial Explanations\n\nra\nPurpose: Stores the return address for function calls.\njal ra, function_label  # Jump to function_label and store return address in ra\nret                     # Return to the address in ra\nsp\nPurpose: Points to the top of the stack (used for dynamic memory allocation during function calls).\naddi sp, sp, -16      # Allocate 16 bytes on the stack\nsw t0, 0(sp)          # Store t0 at the top of the stack\nlw t0, 0(sp)          # Retrieve t0 from the stack\naddi sp, sp, 16       # Deallocate 16 bytes\ngp\nPurpose: Points to global and static data in memory.\nlw t0, 0(gp)         # Load a value from the global data section\ntp\nPurpose: Points to thread-local storage (used in multi-threaded programs).\nlw t0, 0(tp)         # Load a thread-specific value\nt0-t6\nPurpose: Temporary values, not preserved across function calls.\n\n\n\n\n跳转指令\n\nIntroduction\nOne category of instructions is jump operations (abbr. jmpop), which is just changing the value of PC (or some GPRs by the way)\n\n\nCommonly Used aluop instructions\n; unconditional:\njal ra, 0x10        ;ra = PC + 4, PC += 0x10 (link and jump, should be laj)\njalr ra, 8(t0)      ;ra = PC + 4, PC += t0+8 (wrt a register)\n\n; conditional:\nbeq t0, t1, 0x8     ;PC += 0x8 if t0 == t1 (branch if equal)\nbne t0, t1, 0x8     ;PC += 0x8 if t0 != t1 (branch if not equal)\nblt t0, t1, 0x8     ;PC += 0x8 if t0 &lt; t1 (signed less than)\nbge t0, t1, 0x8     ;PC += 0x8 if t0 &gt;= t1 (signed greater or equal)\nbltu t0, t1, 0x8    ;PC += 0x8 if t0 &lt; t1 (unsigned less than)\nbgeu t0, t1, 0x8    ;PC += 0x8 if t0 &gt;= t1 (unsigned greater or equal)\n\nauipc t0, 0x1000    ;t0 = PC + (0x1000 &lt;&lt; 12) (add upper imm and PC to a reg)\n\n\nNotes\nload:\n    lbu a1, 0(t1)\n    sb a1, 0(t2)\n    addi t1, t1, 1\n    addi t2, t2, 1\n    bltu t2, t3, load\nIf lbu a1, 0(t1) is at location 0x8000001a, then this line: bltu t2, t3, load does NOT mean\nPC += 0x8000001a if t2 &lt; t3\nbut\nPC = 0x8000001a if t2 &lt; t3\n(done by the smart compiler!)\n\n\n\nMachine Mode\n\nIntroduction\nOne category of instructions is machine operations (abbr. machineop), which is a set of privileged instructions in the RISC-V privileged architecture. These instructions are all related to the CSRs, so make sure you are familiar with those registers first.\n\n\nRISCV Privilege Levels from High to Low\n\nDebug (D)\nMachine (M): “must-have”\nSupervisor (S)\n\nHypervisor-extended Supervisor (HS)\nVirtual Supervisor (VS)\nVirtual User (VU)\n\nUser (U)\n\n\n\nCommonly Used machineop instructions\n\nmret: Return from Machine-mode to Supervisor-mode (or User-mode). Steps:\n\nRestore the privilege mode:\n\nThe processor sets the current privilege mode based on MPP from mstatus.\nMPP is cleared to user mode (00) or supervisor mode (01) if applicable.\n\nRestore the interrupt enable status:\n\nThe MIE bit in mstatus is set to MPIE.\nThe MPIE bit is cleared (0).\n\nRestore the program counter (PC):\n\nThe PC is set to the value stored in mepc, resuming execution where it was interrupted.\n\n\n\n\n\n\n内存操作\n\nIntroduction\nOne category of instructions is memory operations (abbr. memop), which is just exchanging data between GPRs to memory locations.\nSo naturally, these signals are crucial for storing a data into memory:\n\nWE: Write enable. Whenever a memop intruction is detected, the memory block needs to be enabled.\n[31:0] data_mem: the 32-bit data to be stored.\n[31:0] mem_addr: where to be stored.\n[3:0] storebytes_size: Store a byte (0001), half word (0011), or a word (1111)?\n\n\n\nCommonly Used memop instructions\nlui t0, 0x40000 ;t0 = 0x40000 &lt;&lt; 12b (load unsigned imm)\nlb t0, 1(a0)    ;t0 = mem[a0 + 1] (load byte)\nlh t0, 2(a0)    ;t0 = mem[a0 + 2] (load half word)\nlw t0, 4(a0)    ;t0 = mem[a0 + 4] (load word)\nlbu t0, 1(a0)   ;unsigned (zero extending)\nlhu t0, 2(a0)   ;unsigned (zero extending)\n\nsb t0, 1(a0)    ;mem[a0 + 1] = t0 (store byte)\nsh t0, 2(a0)    ;mem[a0 + 2] = t0 (store half word)\nsw t0, 4(a0)    ;mem[a0 + 4] = t0 (store word)",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>RISCV ISA</span>"
    ]
  },
  {
    "objectID": "cc-os/cc-os.html",
    "href": "cc-os/cc-os.html",
    "title": "OS 操作系统原理",
    "section": "",
    "text": "操作系统:\n\n狭义: 内核\n广义: 发行版",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>OS 操作系统原理</span>"
    ]
  },
  {
    "objectID": "hdl/hdl.html",
    "href": "hdl/hdl.html",
    "title": "HDL 硬件描述语言",
    "section": "",
    "text": "Change of Mind",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "hdl/hdl.html#change-of-mind",
    "href": "hdl/hdl.html#change-of-mind",
    "title": "HDL 硬件描述语言",
    "section": "",
    "text": "Hardware does not “execute” the lines of code in sequence.",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "hdl/hdl.html#verilog",
    "href": "hdl/hdl.html#verilog",
    "title": "HDL 硬件描述语言",
    "section": "Verilog",
    "text": "Verilog\n\nassign\n\n多个 assign 执行没有顺序, 同时进行.\nassign 是 “continuous assignment”, 右值变化时, 左值跟着变化.\n\nOperation 运算符: ~, ! (logical), &, && (logical), |, || (logical), ^ (XOR).\nif, else if 是有顺序的!!!\n(procedure 一定要放在 always 块中吗?)\n(为什么 wire 类型不能在 always 里面被赋值?)\nalways 块中的代码是顺序执行的 (但在 always 块外的代码是并行执行的).\nmodule top (input my_in, output reg my_out);\n    always @(*) begin\n        my_out = 0;\n        my_out = 1; // This is valid! (Always block 按顺序执行)\n    end\nendmodule\n\nLatch 推断: 下面如果 cpu_overheated = 0 则默认会让 shut_off_computer 保持上一个值, 这就是 latch 推断.\nalways @(*) begin\n    if (cpu_overheated)\n        shut_off_computer = 1;\nend\n有时我们就是需要这种推断, 但为了避免, 可以利用always 的顺序性先提前赋值:\nalways @(*) begin\n    shut_off_computer = 0; // 先提前赋值\n    if (cpu_overheated)\n        shut_off_computer = 1;\nend\n\nConcatenation:\nassign out = {tmp, {3{3'b100}}}; // Concatenation, out = 0000011 100 100 100\nindex 可以是负数:\nreg [5:-1] my_reg; // index 可以是负数.\nwire [0:3] my_wire; // Big-endian, mywire[0] is MSB, use my_wire[3:0] later is illegal!\ninput a 默认为 wire.\nbegin end 在只有一行代码时可以省略 (相当于 C 中的 {}).\nwire 不能在 always 块中被赋值. reg 才能在 always 中被赋值.\nwire a;\nalways @(*) begin\n    assign a = 1; // Error!\nend\nwire a;\nalways @(*) begin\n    a &lt;= 1; // Not an error, `a` is viewed as a reg.\nend\nSynchronous and Asynchronous Reset:\n\nsynchronous reset:\nalways @(posedge clk) begin\n    if (reset)\n        ...\nend\nasynchronous reset:\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        ...\nend\n\nor 只能在 always 块中使用, if () 中要用 ||.\nInference 和 Instantiation:\n\nInference: 通过 always 块的内容推断出一个模块的功能.\nInstantiation: 显式地实例化一个模块, 通过 module_name instance_name (port_map) 的方式.\n\n循环群结构 (Torus, etc) 如果用 % 运算符来处理会消耗大量资源, 尽量用 if 语句:\nif (mm == 8'd59) begin\n    mm &lt;= 8'd0;\nend\n\n如果用 % 运算符来处理:\n\n-1 % 16 的结果是 -1, 而不是 15 (所以 (a-1)%16 应该写成 (a+15)%16).\n1~12 的循环先转换为 0~11 的循环, 再换元.\n\n\nBCD (Binary-Coded Decimal): 一种从 0 到 9 的计数器, 输出是四位二进制编码的十进制数.\nBlocking 和 Non-blocking assignments:\n\n=: Blocking assignment, 若在 always 块中使用, 则必须按照顺序执行!\n&lt;=: Non-blocking assignment, 在 always 块中使用时, 会同时执行所有赋值. (一般 always 里面都用这个!)\n\n\n\nVerilog Testbench\n`timescale 1ns / 1ps // #1 代表 1ns, 最精确可以到 #1.001\n`timescale 1ns / 1ns // #1 代表 1ns, #1.01 等是不合法的\n\n$stop //停下来",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "hdl/hdl.html#chisel",
    "href": "hdl/hdl.html#chisel",
    "title": "HDL 硬件描述语言",
    "section": "Chisel",
    "text": "Chisel\n\n+&: 如果 io.in_a 和 io.in_b 为 4.W 时, 则 sum 为 5.W (带溢出).\nval sum = io.in_a +& io.in_b\n允许多个 := 赋值到同一个输出:\nio.out := 0.U\nio.out := 1.U // 覆盖上一个\nif 和 when 的区别:\n\nif 用来在编译阶段决定电路是哪一种\nwhen 用来生成固定的 verilog 电路, 相当于 verilog 的 if.",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "cc-fpga/cc-fpga.html",
    "href": "cc-fpga/cc-fpga.html",
    "title": "FPGA 原理速成",
    "section": "",
    "text": "FPGA Structure 结构",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>FPGA 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-fpga/cc-fpga.html#fpga-structure-结构",
    "href": "cc-fpga/cc-fpga.html#fpga-structure-结构",
    "title": "FPGA 原理速成",
    "section": "",
    "text": "PL (Programmable Logic) 可编程部分\n这个部分是一个 FPGA 开发板 “软” 的部分, 即可以通过 verilog 来控制硬件电路的部分. 要理清一下几个概念:\n\nBLE (Basic Logic Element): 基本逻辑单元. LUT 和 FF 的「经典」的组合.\n\n见 Figure fig-ble, 方框代表 LUT (Look up Table), 本质上就是一个 Mux (Multiplexer, 多路选择器).\n红色的位置将来的 bitstream 会写入 (用来配置这个 BLE 的功能), i0-i3 是这个 BLE 的输入, 右边是输出.\n\n\n\n\n\n\nFigure 1: 这个 BLE 由 LUT-4 和 D-FF 组成\n\n\n\n\nCLB (Configurable Logic Block, Xilinx) 可配置逻辑块: 一个或者多个 BLE 的组合.\n\n也叫 Slice (Vivado HLS) 或 LAB (Logic Array Block) 或 ALM (Adaptive Logic Module, Intel).\n\n\n\n\n\n\n\n\n由 1 个 BLE 构成的 CLB (e.g. Xilinx Spartan 6)\n\n\n\n\n\n\n\n由 4 个 BLE 构成的 CLB\n\n\n\n\n\n\nSB (SwitchBox): 连接不同 CLB 的开关盒.\n\n\n\n\n\n\nFigure 2: Slice (蓝色) 和其周围的 SB (SwitchBox) [1]\n\n\n\n\n\n\n\n\n\nFigure fig-slice-sb 的放大结构\n\n\n\n\nPS (Processing System) 处理器部分\n不要认为一个开发板只有 “软” 部分, 有些经常用的模块会用硬件 “焊死” 在板子上 (Heterogenous 异构). 这些硬件通过 I/O 口与 PL 部分通信, 比如:\n\n\n\nZYNQ PS 和 PL 通过 AXI 通信",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>FPGA 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-fpga/cc-fpga.html#编译过程",
    "href": "cc-fpga/cc-fpga.html#编译过程",
    "title": "FPGA 原理速成",
    "section": "编译过程",
    "text": "编译过程\n\nSynthesis 综合\n\n动机: FPGA 不懂 “行为”, 它需要的是 “你想用哪些门, 怎么连线”. 所以 Synthesis 是将你写的 .v 逻辑翻译成各种 Logic gates 应该如何连接 (门级网表) 的过程 (以 .json 格式输出).\n\n\n\n\n\n1. Kastner R, Matai J, Neuendorffer S (2018) Parallel Programming for FPGAs. ArXiv e-prints",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>FPGA 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-cpu/cc-cpu.html",
    "href": "cc-cpu/cc-cpu.html",
    "title": "CPU 原理速成",
    "section": "",
    "text": "Change of Mind",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>CPU 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-cpu/cc-cpu.html#change-of-mind",
    "href": "cc-cpu/cc-cpu.html#change-of-mind",
    "title": "CPU 原理速成",
    "section": "",
    "text": "对于有时钟的电路, 我们应该想象成: 电路的状态只在时钟的上升沿「瞬间」变化. 时钟的上升沿发生时电路做了两件事情:\n\n前一个时钟周期的计算结果该锁存的 锁存到寄存器 中.\n下一个时钟周期的结果瞬间计算出来并 放在线上 (他们目前还不能被 CPU “看到”).",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>CPU 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-cpu/cc-cpu.html#cpu-是如何成为现在这个样子的",
    "href": "cc-cpu/cc-cpu.html#cpu-是如何成为现在这个样子的",
    "title": "CPU 原理速成",
    "section": "CPU 是如何成为现在这个样子的?",
    "text": "CPU 是如何成为现在这个样子的?\n\nThe following is a critical path towards understanding CPU. You can’t drop any of them. 以下是理解 CPU 的必经之路.\n\n\n分而治之, 穷举 + 控制信号\n\n分而治之: 一条指令的执行可以拆分为这几个阶段 (phase):\n\nIF (Instruction Fetch): 取指.\nID (Instruction Decode): 译码.\n\nID 后面有些地方 [1] 后面还细分了 Evaluate Address 和 Fetch Operands.\n\nEX (Execute): 执行.\nME (Memory Access): 访存.\nWB (Write Back): 写回.\n每个 phase 都可以有固定的输入和输出, 所以每个 phase 都对应一个 (或多个) 电路模块.\n\n\n\n这个 phase 的 CPU 可以通过我的 my-riscv 项目 可视化地理解\n\n\n\n\n\n\n\n\n\n\n\nRISC-V 指令分类\n\n\n\n\n\n\nArithmetic 运算: 读取某些寄存器的值, 运算之后再放回某个寄存器中 (不能读写内存)\nLoad/Store 访存: 唯一能访问内存的指令. 将某个寄存器的值写到某个内存地址 (或者反过来)\nControl 控制流: 跳转 (其实就是改变 pc 寄存器的值 (还有顺带改变一下 ra 寄存器))\n\n\n\n\n\n\n穷举 + 控制信号 思想: 每个电路模块用硬件写死, 以 ALU 单元 (Execute 的其中一个模块) 为例, 所有可能的输出都计算出来 (说是计算, 其实就是一个数字电路通了而已, 电路通了结果自然就在输出端口显示出来了, 没有「计算」的过程. 比如 ALU), 只不过在输出之前用控制信号来决定哪个计算结果才是我们要的 (一般控制信号都由 Decoder 产生, 因为 Decoder 的作用就是 (根据 Opcode) 将一条指令解读为如何控制各个模块应该输出什么结果).\n\n\n\n穷举 + 控制信号 思想在 ALU 内部的体现\n\n\n一条指令的执行的那几个 phase 可以设计成:\n\nSingle-Cycle: 在一个时钟周期内完成所有 phases. 由于电路有延迟, 所有 phase 的电路很长, 要求时钟频率不能很高.\nMulti-Cycle: 每个时钟周期只执行一个 phase.\n\n\n\n\n\n\nFigure 1: 为了提升指令执行效率引入了 Pipeline [2]\n\n\n\n\n这样的 CPU: simple, general, 但是 not efficient!\n\n\n\n流水线\n\nPipeline 流水线: 见 Figure fig-single-mult-pipelined.\n在每两个 phase 之间插入一些受始终控制的寄存器:\n\nIF-ID 之间: 当前指令, PC 值 (jal 要用)\nID-EX 之间: 指令类型, rs1, rs2, rd, imm.\n\n\n\n\n第三阶段\n\n总线\n\nAXI4, AHB, APB\n\n\nCache\n\n\nMemory\n\n内存: working memory, main memory\nDRAM & SSD 内存与硬盘\n\n读写速度 (3000 倍): 17 ns vs 50 ms, 超音速飞机和龟速\n容量: 16GB vs 4TB\n\nSIMM & DIMM\n\nDIMM (Dual In-line Memory Module)\n\n\n\n\n\n\n1. Patt YN, Patel SJ (2020) Introduction to computing systems : From bits and gates to c/c++ & beyond. Mcgraw-Hill\n\n\n2. Slchoi (2025) Multi-cycle implementation & pipelining",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>CPU 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-gpu/cc-gpu.html",
    "href": "cc-gpu/cc-gpu.html",
    "title": "GPU 原理速成",
    "section": "",
    "text": "CUDA",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>GPU 原理速成</span>"
    ]
  },
  {
    "objectID": "open-src-tools/open-src-tools.html",
    "href": "open-src-tools/open-src-tools.html",
    "title": "Open Source 开源工具",
    "section": "",
    "text": "Behavioral Simulation 行为仿真",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Open Source 开源工具</span>"
    ]
  },
  {
    "objectID": "open-src-tools/open-src-tools.html#behavioral-simulation-行为仿真",
    "href": "open-src-tools/open-src-tools.html#behavioral-simulation-行为仿真",
    "title": "Open Source 开源工具",
    "section": "",
    "text": "即: NOT board-specific 的仿真.\n\n\n用到的工具:\n\n\nVerilator\n先创建一个 Verilog 文件:",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Open Source 开源工具</span>"
    ]
  },
  {
    "objectID": "open-src-tools/open-src-tools.html#makefile",
    "href": "open-src-tools/open-src-tools.html#makefile",
    "title": "Open Source 开源工具",
    "section": "Makefile",
    "text": "Makefile\n\n格式:\ntarget: prerequisites\n    recipe\n缺省规则\n.DEFAULT_GOAL := all\nall: ...\n伪规则\n.PHONY: all clean\nAppend:\nCFLAGS += -Wall -O2\n改后缀名:\nSRCS_ASM = start.S\nOBJS = $(SRCS_ASM:.S=.o)\n冒号前面和后面:\n%.o : %.c\n    $(CC) $(CFLAGS) -c $&lt; -o $@\n\n% 为通配符, 意思是每当你需要一个 .o 文件, 并且当前目录下有对应的 .c 文件时, 就用下面的命令来生成它\n$&lt;: 第一个依赖文件\n$@: 目标文件\n$^: 所有依赖文件\n$?: 所有比目标文件新的依赖文件",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Open Source 开源工具</span>"
    ]
  },
  {
    "objectID": "open-src-tools/open-src-tools.html#qemu-模拟器",
    "href": "open-src-tools/open-src-tools.html#qemu-模拟器",
    "title": "Open Source 开源工具",
    "section": "QEMU 模拟器",
    "text": "QEMU 模拟器",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Open Source 开源工具</span>"
    ]
  },
  {
    "objectID": "yolo/yolo.html",
    "href": "yolo/yolo.html",
    "title": "YOLO Object Detection 目标检测",
    "section": "",
    "text": "Task Objective 任务目标",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>YOLO Object Detection 目标检测</span>"
    ]
  },
  {
    "objectID": "yolo/yolo.html#task-objective-任务目标",
    "href": "yolo/yolo.html#task-objective-任务目标",
    "title": "YOLO Object Detection 目标检测",
    "section": "",
    "text": "识别东西是什么\n将东西的位置框起来\n\n\n两类方法\n解决这个问题的方法有两类:\n\nOne-stage: 推理速度快, 可实时\n\nE.g., YOLO, SSD, RetinaNet\n\nTwo-stage: 准确率高\n\nRegion Proposal 候选区: 先从图片中提取出可能包含目标的 1000-2000 个区域, 然后对每个候选区进行目标对象识别操作.\nE.g., Faster R-CNN, Mask R-CNN, Cascade R-CNN\n\n\n\n\n\nOne stage 和 Two stage 流程框图对比\n\n\n\n\n\n\n\nMSCOCO 数据集有物体名字和位置标注\n\n\n\n\n损失函数\n\n\n\n交并比用来衡量预测地好不好",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>YOLO Object Detection 目标检测</span>"
    ]
  },
  {
    "objectID": "yolo/yolo.html#yolo-v1",
    "href": "yolo/yolo.html#yolo-v1",
    "title": "YOLO Object Detection 目标检测",
    "section": "YOLO V1",
    "text": "YOLO V1\n\nNetwork Structure 网络结构\n\n\n\n\n\n\nFigure 1: YOLO V1 的网络结构 [1]\n\n\n\n\n\n\n\n\n\nFigure 2: Figure fig-yolo-v1 的 Back-Bone 网络其实是若干的卷积网络 [2]\n\n\n\n说明:\n\nFigure fig-back-bone: -s-2 表示 stride 步长为 2.\n输入输出:\n\n输入是一张正方形的图片 (长宽像素各为 \\(448\\), 有 3 个通道: RGB).\n输出的 tensor 大小为 \\(7 \\times 7 \\times 30\\)\n\n\n\n\nLabel Tensor 标签张量\n\nMSCOCO 数据集需要先转换成另外一种形式 (Figure fig-yolo-v1-data-labeling) 再喂给 TOLO V1 神经网络 (即换一种形式打标签而已).\n\n\n\n\n\n\nFigure 3: YOLO V1: \\(S = 7\\), 总共\n\n\n\n每张图片都有 \\(S \\times S = 49\\) 个 grid cell, 每一个 grid cell 都被一个 \\(30 \\times 1\\) 的向量描述, 相当于一张图片都对应了一个 \\(7 \\times 7 \\times 30\\) 的 label tensor.\n\nFigure fig-back-bone 中网络的输出也是一个 \\(7 \\times 7 \\times 30\\) 的 tensor, 但这是 Prediction Tensor 预测张量 (sec-prediction-tensor), 不能混为一谈.\n\n如果有两个物体的中心点都落在同一个 grid cell 中, YOLO V1 只会保留其中一个.\n\n\n\nPrediction Tensor 预测张量\n\n\n\n\n1. 上下求索电子Er (2025) [YOLO V1] 数据标注和输出张量_哔哩哔哩_bilibili\n\n\n2. Redmon J, Divvala S, Girshick R, Farhadi A (2016) You only look once: Unified, real-time object detection",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>YOLO Object Detection 目标检测</span>"
    ]
  },
  {
    "objectID": "hls-design/HLS-design.html",
    "href": "hls-design/HLS-design.html",
    "title": "HLS Design FPGA 并行编程",
    "section": "",
    "text": "Test\nOngoing",
    "crumbs": [
      "ML Accelerators",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>HLS Design FPGA 并行编程</span>"
    ]
  },
  {
    "objectID": "cfu-proj-struct/cfu-proj-struct.html",
    "href": "cfu-proj-struct/cfu-proj-struct.html",
    "title": "CFU-Playground 工程结构",
    "section": "",
    "text": "Folder 文件夹描述",
    "crumbs": [
      "CFU Playground",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>CFU-Playground 工程结构</span>"
    ]
  },
  {
    "objectID": "cfu-proj-struct/cfu-proj-struct.html#folder-文件夹描述",
    "href": "cfu-proj-struct/cfu-proj-struct.html#folder-文件夹描述",
    "title": "CFU-Playground 工程结构",
    "section": "",
    "text": "soc: 存放一个完整的 CPU 的 verilog 设计.\n\n有很多种 CPU, 比如带或不带 CFU 接口的.",
    "crumbs": [
      "CFU Playground",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>CFU-Playground 工程结构</span>"
    ]
  },
  {
    "objectID": "cc-gpu/cc-gpu.html#cuda",
    "href": "cc-gpu/cc-gpu.html#cuda",
    "title": "GPU 原理速成",
    "section": "",
    "text": "2026 年之前 GPU 只能做特定的函数运算, 2026 年之后引入了 GPGPU (General Purpose GPU), 有一整套库函数来对 GPU 进行编程.\n\nCUDA: Compute Unified Device Architecture (NVIDIA, 闭源)\nOpenCL: Open Computing Language (开源)\n\nGPU device memory 可以被所有 CUDA 核心共享:\n\n\n\nNVidia GPU 架构 [1]\n\n\n连接有 GPU 的 CPU 二者的 memory 是不共享的 [1], 二者之间的数据由 DMA 搬运.\n\n\n\nSeperate memory systems [1]\n\n\nKernel functions [1]:\n\n__host__: 默认在 CPU (host) 上运行的函数.\n__global__: 在 GPU 上运行, 可被 CPU 调用的函数.\n__device__: 在 GPU 上运行, 只能被 GPU 调用的函数.\n\n全局变量: 可以被 CPU 和 GPU 访问的变量, 不能用 local variable 的方式声明!\n__managed__ int x;\n\n\n\n\n\n1. Cheung SY (2025) Lecture notes on computer science courses: Computer architecture (CS355)",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>GPU 原理速成</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#gpu-terms",
    "href": "glossary/glossary.html#gpu-terms",
    "title": "Glossary 名词解释",
    "section": "GPU Terms",
    "text": "GPU Terms\n\nKernel: 在 GPU 上运行的函数.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "nn-essence/nn-essence.html",
    "href": "nn-essence/nn-essence.html",
    "title": "The Essence of NN 神经网络的本质",
    "section": "",
    "text": "Change of Mind",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The Essence of NN 神经网络的本质</span>"
    ]
  },
  {
    "objectID": "nn-essence/nn-essence.html#change-of-mind",
    "href": "nn-essence/nn-essence.html#change-of-mind",
    "title": "The Essence of NN 神经网络的本质",
    "section": "",
    "text": "I don’t think view neural networks as black boxes does any help towards understanding and inventing new networks.\n对一个神经网络来说, 我们要站在它的角度考虑 up to what extend it could tell the difference of data? 比如图像处理的神经网络, 它肯定不知道输入的是一张图, 如果是一段文字呢? 如果对于很多类型的数据它都不能区分, 说明这个网络非常 general 但性能肯定很差.",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The Essence of NN 神经网络的本质</span>"
    ]
  },
  {
    "objectID": "nn-essence/nn-essence.html#questions",
    "href": "nn-essence/nn-essence.html#questions",
    "title": "The Essence of NN 神经网络的本质",
    "section": "Questions",
    "text": "Questions\n\n梯度下降和反向传播的关系是什么?\n我们算梯度是在什么空间里面?\n梯度下降在 Transformer 里面是如何工作的?",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The Essence of NN 神经网络的本质</span>"
    ]
  },
  {
    "objectID": "nn-essence/nn-essence.html#neural-network-is-not-so-different",
    "href": "nn-essence/nn-essence.html#neural-network-is-not-so-different",
    "title": "The Essence of NN 神经网络的本质",
    "section": "Neural Network is Not So Different",
    "text": "Neural Network is Not So Different\n\n目标: 找一个映射.\n\n世界上很多问题其实就是一个复杂的映射, 比如图像识别就是输入是图片, 输出是图片中的各种内容. 只不过这个函数存在于人类的大脑中, 无法写出显式的表达式. 人类想要强行把这个函数的表达式找到! 怎么找呢? 我们看到一棵树, 它为什么是一棵树呢? 每个像素都对它是一棵树做出了贡献, 但好像整体是一棵树又与单个像素毫无关系. 如果这个表达式存在, 那么它肯定非常复杂 (这里不能追求所谓的 “简洁与优美”). 但我们可以缩小一点范围, 用某种特定形式的函数来逼近所求. 也就是:\n\n在一堆某种形式的映射里面 (参数化的函数空间 \\(\\mathcal{\\hat{F}}\\)) 找到一个映射 \\(\\hat{f}\\) 来拟合一个复杂的映射 \\(f: \\mathcal{X}\\to \\mathcal{Y}\\)\n\n人们首先发现长成 Equation eq-fcnn 这种样子的映射仿佛有很强的拟合能力, 也就是不管你人脑中的模型有多复杂, 总是可以在下面形式的映射中找到合适的拟合.\n\\[\n\\hat{f}(x) = \\sigma (W^{[L]} \\cdots \\sigma (W^{[2]} \\sigma (W^{[1]} x + b^{[1]}) + b^{[2]}) + \\cdots + b^{[L]})\n\\tag{1}\\]\nEquation eq-fcnn 很复杂对吧. 但是它可以用下面的图可视化出来:\n\n\n\n\n\n\nFigure 1: 仅仅是 Equation eq-fcnn 的可视化\n\n\n\n这张图放在这里太 cliché 了, 但是我想说的是: 我们对它太过熟悉了, 以至于认为选择这种参数化方法是理所应当、独一无二的.\n(FCNN, CNN, Transformer是同一层面上的概念? FCNN 能做到的事情很多, 但是太general 了, 所以先猜测什么样的结构能更好地揭示规律 (比如卷积 (尊重了 \\(\\mathcal{X}\\) 结构从而很可能能加速神经网络发现规律的过程?), 再比如 GNN), 然后加入它们来 帮助神经网络发现规律? “Differential Model” 我感觉 FCNN 和 CNN 的本质是一样的? CNN 的本质是 pre-trained FCNN (或者说?))\n\n事实证明形如神经网络的那些参数化函数空间能够拟合绝大多数的复杂映射, 所以无脑选择这样的 \\(\\mathcal{\\hat{F}}\\) 就行了.\n\n\n如果一个问题可以用以下的框架里面描述, 那么这个问题就可以用神经网络来解决!\n\n\n「复杂的映射」\n「复杂的映射」这个思想可以刻画和描述所有以下问题:\n\nClassification 分类问题: \\(\\mathcal{Y}\\) 仅仅是没有任何结构的集合.\n\n请说出下面例子的 \\(\\mathcal{X}\\) 和 \\(\\mathcal{Y}\\):\n\nImage Classification: 输入一张图片, 判断是猫还是狗还是其它的.\nFace Detection: 输入一张图片, 判断有没有人脸.\nHandwriting Recognition: 输入一张手写的数字, 判断是几. (虽然 \\(\\mathcal{Y}\\) 有序结构, 但不关心)\n\n\\(\\mathcal{X}\\) 是所有图片的集合, \\(\\mathcal{Y}\\) 是所有类别的集合.\n\nRegression 回归问题: \\(\\mathcal{Y}\\) 有序结构. (Generally speaking, 有拓扑结构1)\n\n请说出下面例子 [1] 的 \\(\\mathcal{X}\\) 和 \\(\\mathcal{Y}\\):\n\nLinear Regression: 给定一个标量场, 用线性标量场来拟合. (相当于指定了 \\(\\mathcal{\\hat{F}}\\))\nQuantization: 根据市场情况、历史数据等, 预测明天的股票价格.\n预测某个视频观看者年龄.\n根据发送的控制信号, 预测机械臂在三维空间的坐标.\n根据历史湿度、温度等天气信息, 预测某地明天的温度.\n\n\n\n1 序结构诱导的拓扑称为 Alexandrov 拓扑.\n\n参数化\n\n如果一个函数空间的所有元素都能用形式上相同的式子表达 (这个式子里面有一些可变的参数), 那么这个函数空间就是参数化的.\n\n\nLinear Regression 的参数化函数空间同构2于 \\(\\mathbb{R}^2\\):\n\n\n\n同构的 Mental picture\n\n\n\n2 在拓扑向量空间的意义上: \\[\\{f: \\mathbb{R}\\to \\mathbb{R} \\mid f(x) = wx + b, w, b \\in \\mathbb{R}\\} \\simeq \\{(w, b) \\mid w, b \\in \\mathbb{R}\\}\\]\n某个 CNN 的参数化函数空间同构于 \\(\\mathbb{R}^{200}\\):",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The Essence of NN 神经网络的本质</span>"
    ]
  },
  {
    "objectID": "nn-essence/nn-essence.html#如何设计-mathcalhatf",
    "href": "nn-essence/nn-essence.html#如何设计-mathcalhatf",
    "title": "The Essence of NN 神经网络的本质",
    "section": "如何设计 \\(\\mathcal{\\hat{F}}\\) ?",
    "text": "如何设计 \\(\\mathcal{\\hat{F}}\\) ?\n\n即如何「设计」神经网络.\n\n\n尊重 \\(\\mathcal{X}, \\mathcal{Y}\\) 中元素的结构\n(升维、ask a lot of binary questions、编解码器、激活函数用什么类型 这些的联系是什么?)\n(\\(\\mathcal{X}\\) 为图片集合、文字、电路板、声音时分别有什么结构?)\n(curse of dimension怎么解决?)\n如果 \\(\\mathcal{X}\\) 是一张图片的话, 我们有 “相邻” 点这种概念, 也就是说输入进 \\(\\hat{f}\\) 的对象内部是有某些结构的, 但是 FCNN (a.k.a., MLP) 并不知道这些结构.\n(引出 CNN 和 GNN)",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The Essence of NN 神经网络的本质</span>"
    ]
  },
  {
    "objectID": "nn-essence/nn-essence.html#如何找到-hatf",
    "href": "nn-essence/nn-essence.html#如何找到-hatf",
    "title": "The Essence of NN 神经网络的本质",
    "section": "如何找到 \\(\\hat{f}\\) ?",
    "text": "如何找到 \\(\\hat{f}\\) ?\n\n即如何「训练」神经网络.\n\n(梯度下降, 各种优化器)\n(梯度消失问题怎么解决、正则化、ResNet, 为什么ResNet有效等等话题)",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The Essence of NN 神经网络的本质</span>"
    ]
  },
  {
    "objectID": "nn-essence/nn-essence.html#杂项",
    "href": "nn-essence/nn-essence.html#杂项",
    "title": "The Essence of NN 神经网络的本质",
    "section": "杂项",
    "text": "杂项\n\n我发现要以线性的顺序来写这篇 blog 的话会增加很多不必要的复杂性, 所以接下来我直接按照本人的学习顺序进行整理.\n\n\nCNN Padding:\n为了解决输入输出大小不一致的问题, 可以引入 Padding.\n\n\n\n不同的 Padding, Pytorch 的默认为 zero padding (最常用 [2])\n\n\n要将各种问题设计成用机器学习的方法的 idea 非常重要. 它往往是一篇论文的核心 idea. 比如 word2vec 中提到的方法.\n\n\n\n\n\n1. Murphy KP (2012) Machine learning : A probabilistic perspective. Mit Press\n\n\n2. Lab MH (2025) Lecture 2 - basics of neural networks (MIT 6.5940, fall 2023)",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The Essence of NN 神经网络的本质</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#riscv",
    "href": "resources/resources.html#riscv",
    "title": "Resources 学习资料汇总",
    "section": "RISCV",
    "text": "RISCV\n\nCS61C: ★★★☆☆ UC Berkeley 的 Great Ideas in Computer Architecture.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  }
]