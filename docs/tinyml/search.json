[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TinyML",
    "section": "",
    "text": "0.1 Hi there!\nThis is my graduation project titled System-Level Co-Design and AI-EDA of RISC-V Accelerators for TinyML at the Edge under my supervisor Prof. Yun Li. His PhD student Jintao Li also helps me greatly. This is a place where I record my learning journey into TinyML and RISC-V accelerators – from scratch. The contents are actively updating. Some of the content may be too basic or even technically incorrect up to now, but they are, hopefully, informative and motivation-boosting. English documentation will be available soon.\n本项目有关的代码主要存放在两个仓库:",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction 引入</span>"
    ]
  },
  {
    "objectID": "index.html#hi-there",
    "href": "index.html#hi-there",
    "title": "TinyML",
    "section": "",
    "text": "Correctness is the enemy of progress. – Myself\n\n\n\nMy TinyML Repo\nMy Forked CFU Playground",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction 引入</span>"
    ]
  },
  {
    "objectID": "index.html#intended-outcomes",
    "href": "index.html#intended-outcomes",
    "title": "TinyML",
    "section": "0.2 Intended Outcomes",
    "text": "0.2 Intended Outcomes\n\nDeveloping an intelligent co-design framework that integrates RISC-V architecture customization with TinyML workload characteristics to enable joint optimization.\nDesigning and implementing hardware-accelerated TinyML kernels that are adaptable and efficient for edge computing scenarios.\nExploring a large multi-dimensional design space using automated methods (such as heuristic or evolutionary algorithms) to identify optimal configurations balancing accuracy, energy, and latency.\nAdvancing the understanding of system-level TinyML accelerator optimization, pushing the boundary beyond traditional manual design methods.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction 引入</span>"
    ]
  },
  {
    "objectID": "index.html#motivation-动机",
    "href": "index.html#motivation-动机",
    "title": "TinyML",
    "section": "0.3 Motivation 动机",
    "text": "0.3 Motivation 动机\n大量应用程序都配备了图像处理的深度学习算法 (如 Animoji), 若想要利用服务器的算力资源, 则每秒至少需要输入 \\(30\\) 帧图片到网络当中, 对于 ResNet-50 这种小网络, 模型运行时也需要占用 \\(3\\text{ GB/s}\\) 的带宽 [1]. 因此, 需要 将云端的一部分计算任务下放到端设备, 以减轻云端和网络带宽的压力. 然而端设备大多采用嵌入式处理器 —— 嵌入式处理器受到功耗、体积、散热等多方客观因素的限制, 其性能远不如桌面平台. 我们可以利用 FPGA、ASIC 等 低功耗、高能效 的器件, 为相应的应用场景定制该领域所专用的加速器 [2].",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction 引入</span>"
    ]
  },
  {
    "objectID": "index.html#change-logs-更新日志",
    "href": "index.html#change-logs-更新日志",
    "title": "TinyML",
    "section": "0.4 🗓️ Change Logs 更新日志",
    "text": "0.4 🗓️ Change Logs 更新日志\n\n\n\n\n\n\n\n\nDate\nUpdate Message\n\n\n\n\n2025-08-01\n按照 汪辰老师的课程, 初步复习了操作系统的 Memory Management, Linker script, Control flow, exceptional control flow, interrupt处理等.\n\n\n2025-07-30~31\n在学习 ysyx 的过程中感到 extremely depressed, 我开始浏览 ysyx 入学之后的学习资料, 发现这些资料存在明显的平行性, 没有必要严格按照顺序来学习. 重新拾起烂尾的 my-riscv 项目, 决定退出依赖 ysyx 的学习方法.\n\n\n2025-07-29\n继续 ysyx 的 E4 (即 PA1), make run 成功运行\n\n\n2025-07-28\n开始 ysyx 的 E4 (即 PA1), 发现 ysyx PA 的思路是自顶向下的\n\n\n2025-07-27\n在 MacOS 和 Ubuntu 上完成了 ysyx 环境的配置, 可同时在两台设备上开发, man 这个命令感觉挺有用的.\n\n\n2025-07-24~26\n通过 HDLBits 刷了一些 verilog 题目.\n\n\n2025-07-23\n报名一生一芯 (ysyx), 准备先造个 CPU 出来, 再来加速 ML.\n\n\n2025-07-17\n准备进行 Vitis HLS 的学习, 初步学习了 YOLO V1 的原理.\n\n\n2025-07-12\n成功将 CFU-playground 的 proj_template 烧到 Arty 开发板上. 认识到开发环境的搭建和理解是一项较大的工程, 但是实际有用的信息并不多, 所以打算并行地学习环境的搭建和 CPU、GPU、Cuda 的知识.\n\n\n2025-07-11\n大致了解了各大 submodule 的功能.\n\n\n2025-07-10\n在 Ubuntu 24.04 和 MacOS 上成功搭建 iCESugar-UP5K 开发环境, 并成功烧录! 完善了教程内容, 建立了 My TinyML Repo 用来存放 iCESugar-UP5K 开发板的例子代码和 ML 加速器的代码.\n\n\n2025-07-09\n在 Ubuntu 24.04 上成功构建 CFU-Playground 的 /proj/proj_template 实例工程. 并且发现 MacOS 上也可以用 Docker 成功生成比特流文件.\n\n\n2025-07-08\n喜提新 Thinkbook, 由于显卡和网卡驱动找不到安装 Debian 失败特别狂躁, Tonic 上报复性狂练 3 小时降 E 大调音阶. 后来安装 Ubuntu 24.04 实体机成功编译. btw, Spark 推荐的 AtlasOS 太好用啦, Synergy 同步 Win, Mac, IOS, Linux 剪切板太方便啦 (就是没有安卓hh)\n\n\n2025-07-07\n发现在 M 芯片 MacOS 上无法安装 linux-64 架构, 改用 Docker 搭建环境成功 … 了一半, 最后因为 Docker 无法连接访问 MacOS 连接的 USB 而构建实例工程失败.\n\n\n2025-07-06\n尝试在 MacOS 上原生搭建和用 Docker 搭建, 无果, 遂改用 Parallel Desktop 上安装 Ubuntu 24.04.\n\n\n2025-06-29\nInitial commit.\n\n\n\n\n\n\n\n\n\n1. 电子H (2025) 哈工大深度学习体系结构课程 | 实验2：YOLO算法量化加速-CSDN博客\n\n\n2. (2021) Deep learning architecture",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction 引入</span>"
    ]
  },
  {
    "objectID": "resources/resources.html",
    "href": "resources/resources.html",
    "title": "Resources 学习资料汇总",
    "section": "",
    "text": "CPU",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#cpu",
    "href": "resources/resources.html#cpu",
    "title": "Resources 学习资料汇总",
    "section": "",
    "text": "An Introduction to Computing Systems Yale Patt: ★★★★★ 如果你大一想认真学一下计算机组成原理, 信我的, 读它准没错 (wetABQ 大佬推荐的).\n\n本书详细讲了一个简单的 16-bit LC-3 CPU 的设计, 包括指令集、汇编语言、机器语言、微架构等内容.\n\nBilibili: RISCV-MCU: ★★★★★ 一个基于 Digital 和 verilog 的 RISC-V CPU 仿真教程, 讲得非常好, 强推!\n\n本人基于这个项目做了一个 my-riscv.\n\nThe “Basic” Pipelined CPU: ★★★★★ 讲了 CPU 流水线 5 个阶段的工作原理.\n\nDr. Chun Yan Cheung Lectures: ★★★★★ 强推!!!",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#neural-network",
    "href": "resources/resources.html#neural-network",
    "title": "Resources 学习资料汇总",
    "section": "Neural Network",
    "text": "Neural Network\n\nAnimated AI: ★★★★★ 可视化了以下概念: Convolution, Padding, Stride, Groups, Depthwise, Depthwise-Separable, Pixel shuffle. 图像处理肯定会用到.\nYOLO V1 Bilibili 讲解: ★★★★★ 非常清楚, 强推.\nA Gentle Introduction to GNN: 图神经网络入门.\n\nUnderstanding Convolutions on Graphs",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#fpga-理论",
    "href": "resources/resources.html#fpga-理论",
    "title": "Resources 学习资料汇总",
    "section": "FPGA 理论",
    "text": "FPGA 理论\n\nHDLBits: ★★★★★ 一个在线的 HDL 练习网站. 如果你对 verilog 一无所知, 直接上这个网站绝对没错.\nFPGA: ★☆☆☆☆ 用来学习 FPGA 的资料库.\n\nVerilog 语法 (Artix7修炼秘籍)\n\nFPGA: Architecture, Programmability and Advantageous: ★★★★☆ 一个讲解 FPGA 结构的视频, 很清楚.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#hls-design-fpga-并行编程",
    "href": "resources/resources.html#hls-design-fpga-并行编程",
    "title": "Resources 学习资料汇总",
    "section": "HLS Design FPGA 并行编程",
    "text": "HLS Design FPGA 并行编程\n\nParallel Programming for FPGAs: ★★★★☆ Xilinx 研究院的 Steve 首席工程师与 UCSD 的 Ryan Kastner 教授团队合作, 推出了这本开源书, 全书通过 10 个算法实现案例完整的介绍了通过 HLS 工具利用 C/C++ 语言快速实现高性能 FPGA 实现的过程.\n\nFPGA 并行编程中文版, 中文版 github repo",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "resources/resources.html#gpu",
    "href": "resources/resources.html#gpu",
    "title": "Resources 学习资料汇总",
    "section": "GPU",
    "text": "GPU\n\ntiny-gpu: ★★☆☆☆ 一个小型的 GPU 实现.\nVeriGPU: ★☆☆☆☆ 一个复杂点的 GPU 实现, 不适合用来入门.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resources 学习资料汇总</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html",
    "href": "glossary/glossary.html",
    "title": "Glossary 名词解释",
    "section": "",
    "text": "General Terms",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#general-terms",
    "href": "glossary/glossary.html#general-terms",
    "title": "Glossary 名词解释",
    "section": "",
    "text": "CFU: Custom Function Unit (自定义功能单元). 为 ML 某些耗时的计算 (如卷积、矩阵乘法、位操作等) 定制的指令加速硬件模块.\n\n一旦主处理器执行到特定的 CFU 指令，就会将数据发送给 CFU 处理，然后 CFU 返回结果.\nFPU: Floating Point Unit (浮点运算单元), 是 CPU 中专门处理浮点数运算的硬件组件.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#fpga-terms",
    "href": "glossary/glossary.html#fpga-terms",
    "title": "Glossary 名词解释",
    "section": "FPGA Terms",
    "text": "FPGA Terms\n\nGeneral\n\nTfLM: TensorFlow Lite for Microcontrollers.\n\nPDTI8: Person DeTection Int 8\n\nGateware: 用软件编写的硬件电路. (既不是 Software, 也不是 Hardware).\nHPS: High Performance System.\n\nPLATFORMS=common_soc sim hps, 三个平台. common_soc 指标准的 FPGA 开发平台; sim 指用 Verilator 进行软件仿真.\n\nSoC (System on Chip) 片上系统: 比如 ZYNQ, 一块硅芯片 就可以实现整个系统的功能 (而不是要组合多个芯片).\nIP Core: Intellectual Property Core. 由一方 (开发者或公司) 设计，并通过许可授权给其他设计者使用。常见的 IP 核包括 CPU 内核、以太网控制器、内存控制器等.\n\nSoft IP: 软核\nHard IP: 硬核\n\n.vcd, fst: 波形文件格式, 后者占空间更小, 但只受 GTKWave 支持 [1].\n\n\n\nInterface\n\nPMOD (Peripheral Module) 接口: 一组 2*6 排针的引脚 PMOD. 定义了电源、地线、以及最多 8 条可用于通信的信号线. PMOD模块通常通过 SPI、I2C 或 GPIO (通用数字输入输出) 与主控通信. 你可以买到很多支持 PMOD 的模块, 如传感器、显示屏、存储器等.\nJTAG 接口: 一种用于调试和编程的标准接口.\nAXI (Advanced eXtensible Interface) 接口: CPU 与外设 (内存控制器, DMA, CFU, IP 核) 之间的通信协议.\n\n比如 ZYNQ 的 PS (Processing System) 和 PL (Programmable Logic) 之间的通信就是通过 AXI 接口 (见 FPGA 原理速成).\n\n\n\n\nFile formats\n\n.pcf 文件: Physical Constraints File. .pcf 文件告诉工具：Verilog 中的某个逻辑信号，物理上应该接到 FPGA 的哪个 pin. 比如:\nset_io D1 B5\n表示把 D1 (在 .v 文件中定义的) 信号连接到 FPGA 的 B5 引脚.\n\n.xdc 文件: Xilinx Design Constraints File (Vivado 工具使用的约束文件, a.k.a., Master Constraints File 主约束文件). Arty 35T xdc 文件\n\n\n\n\nHDL\n\nHLS: High-Level Synthesis. 用 C/C++ 等高级语言来写硬件电路设计.\n\nScala: 一种专门生成其它 DSL (Domain Specific Language) 的语言. 生成的语言包括:\n\nSpinalHDL: 一种 Hardware Description Language (HDL). 可用来生成更底层的 Verilog 代码.\n\nVexRiscv Soft CPU: 用 SpinalHDL 写的一个 高度可配置的 RISC-V soft CPU 内核 (soft 的意思就是 CPU 不是硬件焊死的 (“hard CPU”) , 而是部署在 FPGA 上可以改变结构的).\n\nChisel: 另一种 HDL.\nScalac: Scala 编译器.\nsbt: Scala Build Tool. 配置依赖、插件和调用 scalac.\nMill: 跟 sbt 类似, 但更轻量.\n\nAmaranth: 一个 Python 库, 也是用于硬件描述和设计. 可生成 Verilog 代码.\n\nRTL: Register Transfer Level. 通俗说就是 verilog 代码的抽象程度水平.\n\n\n\n\nFPGA Principles\n\nPAR： Place and Route. 布局布线.\n\n\n\nFPGA Structure 结构\n\nBLE, CLB (Slice, LAB, ALM), SB: 见 FPGA 原理速成.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#submodules-项目中用到的核心子模块",
    "href": "glossary/glossary.html#submodules-项目中用到的核心子模块",
    "title": "Glossary 名词解释",
    "section": "Submodules 项目中用到的核心子模块",
    "text": "Submodules 项目中用到的核心子模块\n\n该项目重度使用了以下开源项目, FPGA 开源是一个很大的工程, 感谢所有开源者!\n\n\nverilator: 将 verilog 代码变成 C++ 代码, 然后编译并运行在 CPU 上进行仿真, 模拟出时钟、寄存器逻辑、外设交互等行为.\niverilog (Icarus Verilog): 也是仿真 (但不输出 C 代码):\niverilog -o blink.vvp blink.v blink_tb.v\n# 生成 vcd 文件可配合 GTKWave 查看波形\nvvp blink.vvp\nopenFPGALoader: 用于将比特流烧录到 FPGA (但不能调试).\n# 示例：\nopenFPGALoader -b arty arty_bitstream.bit      # SRAM 加载\nopenFPGALoader -b arty -f arty_bitstream.bit   # 写入 flash\nopenocd: Open On-Chip Debugger. 用于调试 FPGA 的工具. 支持 JTAG 接口.\n三个端到端的工具链:\n\nVivado: IDE, 闭源.\nyosysHQ (Yosys Open SYnthesis Suite Headquarters): yyds!! 一个开源的 EDA 工具链. 子项目包括:\n\nicestorm: 用于针对 Lattice iCE40 FPGA 实现完全的端到端开源流程, 从 Verilog 到 bitstream, 再烧写到 FPGA 板卡上. 以下每一个命令都是一个单独的 repo!!\n# yosys 综合 (将 verilog 转换为网表 .json)\nyosys -p 'synth_ice40 -top blink -json blink.json' blink.v\n# nextpnr 布局布线 (生成 bitstream 的中间文件 .asc)\nnextpnr-ice40 --up5k --json blink.json --pcf blink.pcf --asc blink.asc\n# icepack 打包 (生成 bitstream .bin)\nicepack blink.asc blink.bin\n# icesprog 烧写 (将 bitstream 写入 FPGA)\nsudo icesprog blink.bin\n\nF4PGA: 以前叫 Symbiflow, 旨在为多家 FPGA 供应商 (Xilinx 7 系列、Lattice iCE40/ECP5、QuickLogic EOS S3 等) 提供统一、功能完备、可扩展且无需专有软件的端到端开发流程.\n\n里面大量使用了 YosysHQ 的工具.\n\n\nSpinalHDL: 一个基于 Scala 的硬件描述语言 (HDL), 用于生成 Verilog 代码. SpinalHDL 提供了更高级的抽象和更强大的功能, 使得硬件设计更加灵活和可扩展.\n\nVexRiscv:\n\nLitex: 支持用 Python 脚本拼装出完整的 SoC.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#ml-terms",
    "href": "glossary/glossary.html#ml-terms",
    "title": "Glossary 名词解释",
    "section": "ML Terms",
    "text": "ML Terms\n\nMSE (Mean Squared Error): 可用作 Loss function.\nAUC (Area Under Curve): 二分类模型的性能评估指标, 越大越好.\nF-score: 二分类 (正类、负类) 模型的性能评估指标.\n\nTP (True Positive): 正类被正确分类为正类.\nFP (False Positive): 负类被错误分类为正类.\nFN (False Negative): 正类被错误分类为负类.\nRecall 召回率: \\(TP/TP+FP\\)\nPrecision 精确率: \\(TP/TP+FN\\)\nF1-score: Recall 和 Precision 的调和平均 (F-\\(\\beta\\) score 的特例)\nF-\\(\\beta\\) score: 仅仅是给 recall 加了权重.\n\n\nHyperparameter 超参数: 模型训练前需要设置的参数, 如学习率、batch size、层数, etc.\nA/B Test: 类似双盲实验, 比如研究修改按钮颜色能否提升点击率? 新模型是否真的比旧模型好? 可以用这种方法进行对比实验.",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#cpu-terms",
    "href": "glossary/glossary.html#cpu-terms",
    "title": "Glossary 名词解释",
    "section": "CPU Terms",
    "text": "CPU Terms\n\nPSR (Program Status Register): 程序状态寄存器. 有 NZVC (Negative, Zero, Overflow, Carry) 四个标志位.\nABI (Application Binary Interface): 应用二进制接口. 比如寄存器的使用约定等.\nHart (Hardware Thread): 硬件线程, 指一个独立的处理器核心, 包括一套流水线, 寄存器, PC 等等 (今后将不提处理器核心这个概念, 只提 Hart).\nBenchmark: 基准测试. 用于测试系统或工具的功能/性能.\nQEMU (Quick Emulator): 开源的模拟器, 可模拟多种 CPU 架构 (如 ARM, x86, RISCV 等).",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#c-compile-terms",
    "href": "glossary/glossary.html#c-compile-terms",
    "title": "Glossary 名词解释",
    "section": "C Compile Terms",
    "text": "C Compile Terms\n\ngcc (GNU Compiler Collection): GNU 编译器集合, 包括 C、C++、Go 等编程语言的编译器.\nGDB (GNU Debugger): GNU 调试器. 支持 Assembly, C/C++, Go, Rust 等.\nLLVM IR (Intermediate Representation): 一种中间表或式, 用于编译器优化和代码生成.\n\ngcc 和 clang 都是 C 语言的编译器, 但是他们的 IR 不一样. gcc: GIMPLE, clang: LLVM IR.\n\nelf (Executable Linkable Format): 可执行链接格式. 包含 .o, a.out, .so 等文件.\n\nBinutils (Binary Utilities): elf 文件处理相关工具, 包括:\n\nobjdump: 查看 elf 文件的内容.\nobjcopy: 执行文件格式转换.\nreadelf: 显示更多 elf 格式文件的信息.\nar: tar, 将多个文件打包成一个大文件.\n\n\n\n\n\n\n\n\nELF 文件格式 [2]\n\n\n\nCross Compilation: 交叉编译, 即在另一台机器上面开发手里面的这台机器 (嵌入式开发, 或在 MacOS 编写 RISCV 的操作系统).\n\n构建 (build) 系统: 生成可执行程序的计算机.\n主机 (host) 系统: 运行可执行程序的计算机.\n目标 (target) 系统: 可执行程序运行的计算机架构\n\n\n\n\n\n\n\n交叉编译",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#ysyx-terms",
    "href": "glossary/glossary.html#ysyx-terms",
    "title": "Glossary 名词解释",
    "section": "YSYX Terms",
    "text": "YSYX Terms\n\nAM (Abstraction Machine): 抽象机, 用程序模拟的硬件计算机.\nNPC (New Processor Core): 指我们自己设计的处理器.\n\n\n\n\n\n1. YSYX (2025) E5 从 RTL 代码到可流片版图 | 官方文档\n\n\n2. Lazyparser (2025) Compilation and linker",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html",
    "href": "env-setup/env-setup.html",
    "title": "FPGA 开发环境配置",
    "section": "",
    "text": "Arty A7-100T CFU-playground 环境配置\n资料:",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html#arty-a7-100t-cfu-playground-环境配置",
    "href": "env-setup/env-setup.html#arty-a7-100t-cfu-playground-环境配置",
    "title": "FPGA 开发环境配置",
    "section": "",
    "text": "官方 CFU Playground Setup Guide, 官方 CFU Github\nMy Forked CFU Playground\n\n\nMacOS Docker 部署\n以下是本人在 MacOS 试过的两种失败的方法, 供参考:\n\n\n\n\n\n\n\nMacOS 原生部署 (未成功)\n\n\n\n\n\n官方 Setup Guide 不适用于 MacOS, 本教程可以配合官方教程. 以下是在 14-inch MacBook Pro (M2 pro) 上我执行过的命令, 可能有不必要的步骤. 另外我之前安装过一些工具如 make, brew, openocd 等, 如有漏掉的步骤请用 brew 自行安装.\n\nCFU 环境配置\ngit clone https://github.com/google/CFU-Playground.git\ncd CFU-Playground\n# Check necessary tools\nwhich gcc\nwhich make\nwhich brew\nbrew install openocd ccache verilator ninja libusb libftdi\nwhich expect\n将 scripts/setup 中的 line 58-60 替换为:\n# Check for libusb development libraries\nif [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n    # macOS: check for Homebrew libusb\n    if ! brew list libusb &gt;/dev/null 2&gt;&1 || ! brew list libftdi &gt;/dev/null 2&gt;&1; then\n        missing+=(libusb libftdi)\n    fi\nelse\n    # Linux: check for apt packages\n    if ! (apt list -i | grep libusb-1.0-0-dev) ; then\n        missing+=(libusb-1.0-0-dev libftdi1-dev)\n    fi\nfi\n再运行:\n# Should end up \"Setup complete\"\n./scripts/setup\nAmaranth 能让你用 Python 写硬件描述语言, 我们暂时不安装.\nFPGA 开源工具链 SymbiFlow 配置\nSymbiFlow 是一个开源的 FPGA 工具链, 支持我们用的 Arty A7-35T 开发板. F4PGA (Framework for FPGA) 是它的下一代.\nMacOS 上会遇到以下问题:\n\ndfu-util 包不可用\nflterm 包不可用\nPython 3.7 不支持\n\n执行:\nbrew install dfu-util yosys\n将 conf/environment-symbiflow.yml 中替换为:\nname: cfu-symbiflow\nchannels:\n- defaults\n- conda-forge\ndependencies:\n# Basic Python packages that should be available\n- lxml\n- simplejson\n- intervaltree\n- json-c\n- libevent\n- python=3.9\n- pip\n- pip:\n    - -r ./requirements-symbiflow.txt\n然后运行:\nrm -rf env/symbiflow && make install-sf\n出现以下输出时表示安装成功:\nDone installing SymbiFlow.  To enter the environment, type 'make enter-sf', which creates a new subshell, and 'exit' when done.\n测试环境:\nmake enter-sf\nexit\n以上方法会在执行 zsh  make prog TARGET=digilent_arty USE_SYMBIFLOW=1\n时出现错误, 因为我们删掉了很多 python 依赖. 这些依赖在 litex-hub 源里面没有 osx-arm64 的版本!!!\n\n\n\n\n\n\n\n\n\n\n\n\nMacOS 虚拟机部署 (未成功)\n\n\n\n\n\nCFU playground 里的 environment-symbiflow 里的很多依赖 (比如 dfu-util 和 flterm 等, 可以在 Anaconda 里面搜索你需要的包) 只支持 linux-64 版本, M 芯片的 MacOS 上的 PD 好像只能安装 linux-aarch64 架构的虚拟机.\n\n\n\ngcc-riscv32-elf-newlib 只支持 linux-64\n\n\n在你安装的虚拟机终端执行:\narch\n不能是 aarch64 才行, 需要是 x86_64 才能安装 linux-64 架构的包!!!\n\n\n\n\n我们利用 Docker 来搭建 CFU Playground 环境, 这样可以避免 MacOS 上的架构问题. 自行安装 Docker, 然后需要稍微改一下 scripts/Dockerfile 和 scripts/setup 脚本. 可以直接 clone 我的 fork:\ngit clone https://github.com/Marcobisky/CFU-Playground.git\n然后切换到 macos-env 分支, 在 CFU-Playground 目录下执行:\n# Takes around 20 min\ndocker build -t cfu-playground --platform linux/amd64 ./scripts\n查看镜像:\ndocker images\n逐条执行, 其中 -v $(pwd):/workspace 表示当前目录 (宿主机)挂载到容器的 /workspace 目录中 (数据共享通道). 但是以下命令不要在 /workspace 里面执行:\ndocker run -it -v $(pwd):/workspace cfu-playground bash\n./scripts/setup\n# Takes around 9 min\nmake install-sf\nmake enter-sf\ncd proj/proj_template\nmake clean\nmake bitstream TARGET=digilent_arty USE_SYMBIFLOW=1\n如果没报错, 恭喜你成功生成了比特流文件! 当你没插上板子的时候如果按照官方运行 make prog TARGET=digilent_arty USE_SYMBIFLOW=1 会报错:\nError: libusb_init() failed with LIBUSB_ERROR_OTHER\n\nTraceback (most recent call last):\n  File \"./common_soc.py\", line 57, in &lt;module&gt;\n    main()\n  File \"./common_soc.py\", line 53, in main\n    workflow.run()\n  File \"/CFU-Playground/soc/board_specific_workflows/general.py\", line 127, in run\n    self.load(soc, soc_builder)\n  File \"/CFU-Playground/soc/board_specific_workflows/general.py\", line 116, in load\n    prog.load_bitstream(bitstream_filename)\n  File \"/CFU-Playground/third_party/python/litex/litex/build/openocd.py\", line 27, in load_bitstream\n    self.call([\"openocd\", \"-f\", config, \"-c\", script])\n  File \"/CFU-Playground/third_party/python/litex/litex/build/generic_programmer.py\", line 101, in call\n    raise OSError(msg)\nOSError: Error occured during OpenOCD's call, please check:\n- OpenOCD installation.\n- Access permissions.\n- Hardware and cable.\n- Bitstream presence.\n即 libusb_init() 函数初始化错误. 事实上不可能通过 Docker 给开发版烧录, MacOS 环境有一个隔离层, GPT 如是说:\n\n\n\n不可能通过 Docker 给开发版烧录\n\n\n可以用两次 exit 退出容器 (第一次只会退出 enter-sf 的子 shell).\n如果要交互式运行已经存在的容器 (例如叫 romantic_austin), 运行:\ndocker start -ai romantic_austin\n\n\nUbuntu 24.04 实体机部署\n我们用 Arty A7-100T 开发板.\n具体运行步骤几乎与 MacOS 一样, 直接按照 Setup Guide 执行即可. 如果 make install-sf 报错:\nwget -qO- https://storage.googleapis.com/symbiflow-arch-defs/artifacts/prod/foss-fpga-tools/symbiflow-arch-defs/continuous/install/20220729-181657/symbiflow-arch-defs-install-xc7-7833050.tar.xz | tar -xJC env/symbiflow/xc7/install\nxz: (stdin): File format not recognized\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now\nmake: *** [Makefile:58: install-sf] Error 2\n仅仅是网络连接的问题, 请把科学上网 (如 Clash Verge) 安装上 Service Mode, 然后打开 Tun Mode. 把 Makefile 中 63-65 行的三个 wget 改成 curl 的写法. 在我的 fork 上已经更改, 直接 clone 即可:\ngit clone https://github.com/Marcobisky/CFU-Playground.git\n让后切换到 ubuntu-env 分支, 即可跑通 make install-sf.\n如果没插入开发板, 运行:\nmake bitstream TARGET=digilent_arty USE_SYMBIFLOW=1\n即可跑通. 若已经插入开发板, 则运行:\nmake prog TARGET=digilent_arty USE_SYMBIFLOW=1 EXTRA_LITEX_ARGS='--variant=a7-100'\nmake load BUILD_JOBS=4 TARGET=digilent_arty EXTRA_LITEX_ARGS='--variant=a7-100'\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\n如果你跟我一样用的是 Arty A7-100T 而不是 35T, 必须加上 EXTRA_LITEX_ARGS='--variant=a7-100' 参数 (见 CFU Wiki), 否则程序会卡在 make load 这一步, 并且会一直卡在这里 (按 enter 也没有用, 只能两下 Ctrl+C 退出):\n/home/merlin/fpga/CFU-Playground/soc/bin/litex_term --speed 3686400  --kernel /home/merlin/fpga/CFU-Playground/proj/proj_template/build/software.bin /dev/ttyUSB1\n当然卡在这里还有可能是其它问题: 见 Issue #787, Issue #775.",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html#icesugar-up5k-开发环境配置",
    "href": "env-setup/env-setup.html#icesugar-up5k-开发环境配置",
    "title": "FPGA 开发环境配置",
    "section": "iCESugar-UP5K 开发环境配置",
    "text": "iCESugar-UP5K 开发环境配置\n资料:\n\n官方 icesugar: 重要! 用它来学习 iCESugar-UP5K 开发板.\nMy TinyML Repo\n\n\nMacOS 部署\n如果你没有安装 Homebrew 包管理器, 请先安装 (会自动先安装 Xcode 命令行工具, 输入密码的过程不可见, 装完了要按照提示将 brew 添加到 PATH 中):\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n直接按 nextpnr 中的 next-pnr-ice40 的说明安装即可. 大致为以下几个命令 (可能有遗漏), 逐条执行:\ngit clone https://github.com/YosysHQ/nextpnr.git\ncd nextpnr\n# May not be successful immediately\nbrew install cmake python boost eigen\ngit submodule update --init --recursive\nbrew install boost\n# These two lines just to make sure dependencies are installed\nbrew install eigen\nmkdir -p build && cd build\ncmake .. -DARCH=ice40 -DICESTORM_INSTALL_PREFIX=/usr -DICEBOX_DATADIR=/usr/share/fpga-icestorm/chipdb\n# May be some error, please solve by yourself using GPT.\nmake -j$(nproc)\n# Check if nextpnr-ice40 is built\nls -la nextpnr-ice40\n# Install placing, routing and binary database format files\nsudo make install\n\n\nUbuntu 24.04 实体机部署\n按 nextpnr 中的 next-pnr-ice40 的说明安装即可. i.e., 逐条执行:\ngit clone https://github.com/YosysHQ/nextpnr.git\nsudo apt update\nsudo apt install libboost-all-dev libboost-filesystem-dev libboost-program-options-dev libboost-iostreams-dev libboost-system-dev libboost-thread-dev libeigen3-dev\ngit submodule update --init --recursive\nmkdir -p build && cd build\nsudo apt install fpga-icestorm\ncmake .. -DARCH=ice40 -DICESTORM_INSTALL_PREFIX=/usr -DICEBOX_DATADIR=/usr/share/fpga-icestorm/chipdb\nmake -j$(nproc)\n# Check if nextpnr-ice40 is built\nls -la nextpnr-ice40\n# Install placing, routing and binary database format files\nsudo make install\n\n\nblink 例子测试\n用 My TinyML Repo 的 blink 例子测试一下. 将 iCESugar 开发板连接到电脑 (注意不要用 JTAG 调试器, 直接用 C 口连接电脑). 按以下方式生成比特流 blink.bin:\ncd iCESugar/examples/blink\nmake\n在 Ubuntu 上可通过以下方式烧录:\nsudo icesprog blink.bin\n在 MacOS 上, 好像安装不上 icesprog, 直接将 blink.bin 拷贝到 iCESugar 虚拟磁盘上即可烧录.\n\n\n\n\n\n\n\n烧录方法注意\n\n\n\n\n\n\nUbuntu\n一定要用 sudo icesprog! 单用 iceprog 会报错:\ninit..\nCan't find iCE FTDI USB device (vendor_id 0x0403, device_id 0x6010 or 0x6014).\nABORT.\nMacOS\n注意 MacOS 上 iceprog 和 icesprog 烧录工具都不能用!\nMacOS 上的烧录工具 iceprog 不能识别到 FTDI 设备, 这可能是 MacOS 上的 USB 设备权限问题, 本人尝试过安装 FTDI 驱动, 安装手册见这里. 安装的时候如果不小心点了 OK, 安装程序会提示 “awaiting approval”, 解决方法见这里. 但是安装好了, Mac 还是识别不到开发板.",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html#vivado-vitis-hls-安装-ubuntu-24.04",
    "href": "env-setup/env-setup.html#vivado-vitis-hls-安装-ubuntu-24.04",
    "title": "FPGA 开发环境配置",
    "section": "Vivado & Vitis HLS 安装 (Ubuntu 24.04)",
    "text": "Vivado & Vitis HLS 安装 (Ubuntu 24.04)\n\n这个是备选项, 不严格要求. 有一说一 Vivado 的 block diagram 界面还是挺好的 (\n\n\n去官网下载最新的 Vivado 2025.1 即可.\n注意 Vitis HLS 工具和 Vivado 软件是分开的! 安装软件的时候我们可以先选择 Vivado ML Enterprise, 装完之后用它的 Add Design Tools or Devices 工具来 upgrade:\n\n\n\nupgrade 的时候要选择 Vitis Unified Software Platform!!\n\n\n安装完成后, 会发现 Vitis 2025.1 GUI (Figure fig-vitis-gui) 打不开, 我们需要换这个库: libstdc++, 解决方法参考 这里. 大致的步骤就是:\ncd &lt;installation_path&gt;/Xilinx/2025.1/Vitis/lib/lnx64.o/Ubuntu\nsudo -s\napt update && apt install libstdc++6:amd64\nmv libstdc++.so libstdc++.so.origin\nmv libstdc++.so.6 libstdc++.so.6.origin\nln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6\nln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6 libstdc++.so\n\n\n\n\n\n\n\n\n\nFigure 1: Vitis 的 GUI 在 Ubuntu 24.04 上打不开\n\n\n\n\nFigure fig-vitis-gui 打开后的界面:\n\n\n\nVitis 界面\n\n\nHLS 开发界面 (好像还能接受?)\n\n\n\nHLS 界面",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html#sbt-安装-ubuntu-24.04",
    "href": "env-setup/env-setup.html#sbt-安装-ubuntu-24.04",
    "title": "FPGA 开发环境配置",
    "section": "SBT 安装 (Ubuntu 24.04)",
    "text": "SBT 安装 (Ubuntu 24.04)\nVexRiscv 是 CFU-Playground 的一个重要子模块, 它是一个 RISC-V 软核 CPU 内核, 用 SpinalHDL 写的. 我们需要安装 Scala Build Tool (SBT) 来将 .scala 文件转换为 RTL 代码. 但官方文档会安装很多不必要的工具, 如果只要装 SBT 的话, 可以在 Ubuntu 24.04 执行:\n# 更新包管理器\nsudo apt-get update\n\n# 安装Java JDK 8 (SpinalHDL需要)\nsudo apt-get install openjdk-8-jdk -y\n\n# 设置Java版本（如果系统有多个Java版本）\nsudo update-alternatives --config java\nsudo update-alternatives --config javac\n\n# 安装SBT (Scala构建工具)\necho \"deb https://repo.scala-sbt.org/scalasbt/debian all main\" | sudo tee /etc/apt/sources.list.d/sbt.list\ncurl -sL \"https://keyserver.ubuntu.com/pks/lookup?op=get&search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823\" | sudo apt-key add\nsudo apt-get update\nsudo apt-get install sbt\n验证安装:\nsbt --version\n生成 VexRiscv 的 RTL 代码:\ngit clone https://github.com/SpinalHDL/VexRiscv.git\ncd VexRiscv\nsbt \"runMain vexriscv.demo.GenFull\"\n运行完会在根目录产生 VexRiscv.v 文件, 导入 Vivado 即可.",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "env-setup/env-setup.html#ysyx-环境搭建",
    "href": "env-setup/env-setup.html#ysyx-环境搭建",
    "title": "FPGA 开发环境配置",
    "section": "YSYX 环境搭建",
    "text": "YSYX 环境搭建\n\n跟踪环境搭建 (MacOS 和 Ubuntu 24.04)\n为了同时在 MacOS 和 Ubuntu 24.04 进行 YSYX 作业的提交, 先在 MacOS 上生成一堆密钥:\nssh-keygen\n名字可以随便起, 比如: ~/.ssh/id_ysyx_ed25519 和 ~/.ssh/id_ysyx_ed25519.pub 即可, 私钥不要设置密码 (按 Enter 即可). 公钥添加到 GitHub 的 SSH keys 中. 执行:\nnslookup github.com\n如果输出类似:\nServer:     198.18.0.2\nAddress:    198.18.0.2#53\n\nNon-authoritative answer:\nName:   github.com\nAddress: 198.18.0.57\n说明网络环境存在 DNS 劫持 (可能是梯子把 把 github.com 映射成了假的 IP 地址 198.18.0.57, 所以你的设备根本没法访问 GitHub 的真实服务器 (导致 SSH 失败)). 解决方法: 配置 ~/.ssh/config 走端口 443:\n\n\n~/.ssh/config\n\n# Add this to your ~/.ssh/config file\nHost github.com\n    HostName ssh.github.com\n    Port 443\n    User git\n    IdentityFile ~/.ssh/id_ysyx_ed25519\n    IdentitiesOnly yes\n\n运行:\nssh -T git@github.com\n如果输出:\nHi &lt;YourName&gt;! You've successfully authenticated, but GitHub does not provide shell access.\n说明 SSH 连接成功. 然后按照 YSYX E3 执行:\ngit clone -b master git@github.com:OSCPU/ysyx-workbench.git\n即可. 按照官方的说法先玩一下, 把该执行的都执行了, 比如:\ngit branch -m master\nbash init.sh nemu\nbash init.sh abstract-machine\n等等 (让他先有一些 git log). 然后创建一个 Private 的 GitHub Repo, 与你本地的 ysyx-workbench 目录关联:\n# 先把原来的 origin 改个名字，比如 oscpu\ngit remote rename origin oscpu\n\n# 然后添加你自己的仓库为新的 origin\ngit remote add origin https://github.com/&lt;Yourname&gt;/ysyx-workbench.git\n然后 push 到 origin (不是 oscpu) 即可.\n在 Ubuntu 24.04 上, 同样将文件 ~/.ssh/id_ysyx_ed25519 复制过去, 然后执行:\nchmod 600 ~/.ssh/id_ysyx_ed25519\nls -la ~/.ssh/id_ysyx_ed25519\nchmod 700 ~/.ssh\nls -ld ~/.ssh\nssh -T git@github.com\n如果成功, 将你自己的 ysyx-workbench 仓库 clone 到 Ubuntu 上:\ngit clone git@github.com:&lt;Yourname&gt;/ysyx-workbench.git\n可以通过\ngit log tracer-ysyx\n查看系统跟踪日志.\n\n\nNEMU 环境搭建 (Ubuntu 24.04)\n如果 make run 失败, 则可能需要:\necho $NEMU_HOME # 如果没有输出, 则需要设置 NEMU_HOME 环境变量\necho \"export NEMU_HOME=/home/marcobisky/LocalFiles/LIYUN/proj/ysyx-workbench/nemu\" &gt;&gt; ~/.bashrc # 换成你的 nemu 路径\nsource ~/.bashrc && echo $NEMU_HOME\n\nmake menuconfig # 如果失败, 则安装缺失的库然后重新运行.\nsudo apt update && sudo apt install bison flex\n\nmake run # 如果失败, 则需要检查错误信息并安装缺失的库, 比如:\nsudo apt install libreadline-dev\nmake run 运行后会有一个断言失败, 这是故意的练习提示:\nWelcome to riscv32-NEMU!\nFor help, type \"help\"\n[src/monitor/monitor.c:35 welcome] Exercise: Please remove me in the source code and compile NEMU again.\nriscv32-nemu-interpreter: src/monitor/monitor.c:36: welcome: Assertion `0' failed.\nmake: *** [/home/marcobisky/LocalFiles/LIYUN/proj/ysyx-workbench/nemu/scripts/native.mk:38: run] Aborted (core dumped)\n删除以下行即可:\n\n\nsrc/monitor/monitor.c\n\n    assert(0);",
    "crumbs": [
      "Environment Setup",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>FPGA 开发环境配置</span>"
    ]
  },
  {
    "objectID": "verilog/verilog.html",
    "href": "verilog/verilog.html",
    "title": "HDL 硬件描述语言",
    "section": "",
    "text": "Change of Mind",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "verilog/verilog.html#change-of-mind",
    "href": "verilog/verilog.html#change-of-mind",
    "title": "HDL 硬件描述语言",
    "section": "",
    "text": "Hardware does not “execute” the lines of code in sequence.",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "verilog/verilog.html#verilog",
    "href": "verilog/verilog.html#verilog",
    "title": "HDL 硬件描述语言",
    "section": "Verilog",
    "text": "Verilog\n\nassign\n\n多个 assign 执行没有顺序, 同时进行.\nassign 是 “continuous assignment”, 右值变化时, 左值跟着变化.\n\nOperation 运算符: ~, ! (logical), &, && (logical), |, || (logical), ^ (XOR).\nif, else if 是有顺序的!!!\n(procedure 一定要放在 always 块中吗?)\n(为什么 wire 类型不能在 always 里面被赋值?)\nalways 块中的代码是顺序执行的 (但在 always 块外的代码是并行执行的).\nmodule top (input my_in, output reg my_out);\n    always @(*) begin\n        my_out = 0;\n        my_out = 1; // This is valid! (Always block 按顺序执行)\n    end\nendmodule\n\nLatch 推断: 下面如果 cpu_overheated = 0 则默认会让 shut_off_computer 保持上一个值, 这就是 latch 推断.\nalways @(*) begin\n    if (cpu_overheated)\n        shut_off_computer = 1;\nend\n有时我们就是需要这种推断, 但为了避免, 可以利用always 的顺序性先提前赋值:\nalways @(*) begin\n    shut_off_computer = 0; // 先提前赋值\n    if (cpu_overheated)\n        shut_off_computer = 1;\nend\n\nConcatenation:\nassign out = {tmp, {3{3'b100}}}; // Concatenation, out = 0000011 100 100 100\nindex 可以是负数:\nreg [5:-1] my_reg; // index 可以是负数.\nwire [0:3] my_wire; // Big-endian, mywire[0] is MSB, use my_wire[3:0] later is illegal!\ninput a 默认为 wire.\nbegin end 在只有一行代码时可以省略 (相当于 C 中的 {}).\nwire 不能在 always 块中被赋值. reg 才能在 always 中被赋值.\nwire a;\nalways @(*) begin\n    assign a = 1; // Error!\nend\nwire a;\nalways @(*) begin\n    a &lt;= 1; // Not an error, `a` is viewed as a reg.\nend\nSynchronous and Asynchronous Reset:\n\nsynchronous reset:\nalways @(posedge clk) begin\n    if (reset)\n        ...\nend\nasynchronous reset:\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        ...\nend\n\nor 只能在 always 块中使用, if () 中要用 ||.\nInference 和 Instantiation:\n\nInference: 通过 always 块的内容推断出一个模块的功能.\nInstantiation: 显式地实例化一个模块, 通过 module_name instance_name (port_map) 的方式.\n\n循环群结构 (Torus, etc) 如果用 % 运算符来处理会消耗大量资源, 尽量用 if 语句:\nif (mm == 8'd59) begin\n    mm &lt;= 8'd0;\nend\n\n如果用 % 运算符来处理:\n\n-1 % 16 的结果是 -1, 而不是 15 (所以 (a-1)%16 应该写成 (a+15)%16).\n1~12 的循环先转换为 0~11 的循环, 再换元.\n\n\nBCD (Binary-Coded Decimal): 一种从 0 到 9 的计数器, 输出是四位二进制编码的十进制数.\nBlocking 和 Non-blocking assignments:\n\n=: Blocking assignment, 若在 always 块中使用, 则必须按照顺序执行!\n&lt;=: Non-blocking assignment, 在 always 块中使用时, 会同时执行所有赋值. (一般 always 里面都用这个!)\n\n\n\nVerilog Testbench\n`timescale 1ns / 1ps // #1 代表 1ns, 最精确可以到 #1.001\n`timescale 1ns / 1ns // #1 代表 1ns, #1.01 等是不合法的\n\n$stop //停下来",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "cc-fpga/cc-fpga.html",
    "href": "cc-fpga/cc-fpga.html",
    "title": "FPGA 原理速成",
    "section": "",
    "text": "FPGA Structure 结构",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>FPGA 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-fpga/cc-fpga.html#fpga-structure-结构",
    "href": "cc-fpga/cc-fpga.html#fpga-structure-结构",
    "title": "FPGA 原理速成",
    "section": "",
    "text": "PL (Programmable Logic) 可编程部分\n这个部分是一个 FPGA 开发板 “软” 的部分, 即可以通过 verilog 来控制硬件电路的部分. 要理清一下几个概念:\n\nBLE (Basic Logic Element): 基本逻辑单元. LUT 和 FF 的「经典」的组合.\n\n见 Figure fig-ble, 方框代表 LUT (Look up Table), 本质上就是一个 Mux (Multiplexer, 多路选择器).\n红色的位置将来的 bitstream 会写入 (用来配置这个 BLE 的功能), i0-i3 是这个 BLE 的输入, 右边是输出.\n\n\n\n\n\n\nFigure 1: 这个 BLE 由 LUT-4 和 D-FF 组成\n\n\n\n\nCLB (Configurable Logic Block, Xilinx) 可配置逻辑块: 一个或者多个 BLE 的组合.\n\n也叫 Slice (Vivado HLS) 或 LAB (Logic Array Block) 或 ALM (Adaptive Logic Module, Intel).\n\n\n\n\n\n\n\n\n由 1 个 BLE 构成的 CLB (e.g. Xilinx Spartan 6)\n\n\n\n\n\n\n\n由 4 个 BLE 构成的 CLB\n\n\n\n\n\n\nSB (SwitchBox): 连接不同 CLB 的开关盒.\n\n\n\n\n\n\nFigure 2: Slice (蓝色) 和其周围的 SB (SwitchBox) [1]\n\n\n\n\n\n\n\n\n\nFigure fig-slice-sb 的放大结构\n\n\n\n\nPS (Processing System) 处理器部分\n不要认为一个开发板只有 “软” 部分, 有些经常用的模块会用硬件 “焊死” 在板子上 (Heterogenous 异构). 这些硬件通过 I/O 口与 PL 部分通信, 比如:\n\n\n\nZYNQ PS 和 PL 通过 AXI 通信",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>FPGA 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-fpga/cc-fpga.html#编译过程",
    "href": "cc-fpga/cc-fpga.html#编译过程",
    "title": "FPGA 原理速成",
    "section": "编译过程",
    "text": "编译过程\n\nSynthesis 综合\n\n动机: FPGA 不懂 “行为”, 它需要的是 “你想用哪些门, 怎么连线”. 所以 Synthesis 是将你写的 .v 逻辑翻译成各种 Logic gates 应该如何连接 (门级网表) 的过程 (以 .json 格式输出).\n\n\n\n\n\n1. Kastner R, Matai J, Neuendorffer S (2018) Parallel Programming for FPGAs. ArXiv e-prints",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>FPGA 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-cpu/cc-cpu.html",
    "href": "cc-cpu/cc-cpu.html",
    "title": "CPU 原理速成",
    "section": "",
    "text": "Change of Mind",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>CPU 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-cpu/cc-cpu.html#change-of-mind",
    "href": "cc-cpu/cc-cpu.html#change-of-mind",
    "title": "CPU 原理速成",
    "section": "",
    "text": "对于有时钟的电路, 我们应该想象成: 电路的状态只在时钟的上升沿「瞬间」变化. 时钟的上升沿发生时电路做了两件事情:\n\n前一个时钟周期的计算结果该锁存的 锁存到寄存器 中.\n下一个时钟周期的结果瞬间计算出来并 放在线上 (他们目前还不能被 CPU “看到”).",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>CPU 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-cpu/cc-cpu.html#cpu-是如何成为现在这个样子的",
    "href": "cc-cpu/cc-cpu.html#cpu-是如何成为现在这个样子的",
    "title": "CPU 原理速成",
    "section": "CPU 是如何成为现在这个样子的?",
    "text": "CPU 是如何成为现在这个样子的?\n\nThe following is a critical path towards understanding CPU. You can’t drop any of them. 以下是理解 CPU 的必经之路.\n\n\n分而治之, 穷举 + 控制信号\n\n分而治之: 一条指令的执行可以拆分为这几个阶段 (phase):\n\nIF (Instruction Fetch): 取指.\nID (Instruction Decode): 译码.\n\nID 后面有些地方 [1] 后面还细分了 Evaluate Address 和 Fetch Operands.\n\nEX (Execute): 执行.\nME (Memory Access): 访存.\nWB (Write Back): 写回.\n每个 phase 都可以有固定的输入和输出, 所以每个 phase 都对应一个 (或多个) 电路模块.\n\n\n\n这个 phase 的 CPU 可以通过我的 my-riscv 项目 可视化地理解\n\n\n\n\n\n\n\n\n\n\n\nRISC-V 指令分类\n\n\n\n\n\n\nArithmetic 运算: 读取某些寄存器的值, 运算之后再放回某个寄存器中 (不能读写内存)\nLoad/Store 访存: 唯一能访问内存的指令. 将某个寄存器的值写到某个内存地址 (或者反过来)\nControl 控制流: 跳转 (其实就是改变 pc 寄存器的值 (还有顺带改变一下 ra 寄存器))\n\n\n\n\n\n\n穷举 + 控制信号 思想: 每个电路模块用硬件写死, 以 ALU 单元 (Execute 的其中一个模块) 为例, 所有可能的输出都计算出来 (说是计算, 其实就是一个数字电路通了而已, 电路通了结果自然就在输出端口显示出来了, 没有「计算」的过程. 比如 ALU), 只不过在输出之前用控制信号来决定哪个计算结果才是我们要的 (一般控制信号都由 Decoder 产生, 因为 Decoder 的作用就是 (根据 Opcode) 将一条指令解读为如何控制各个模块应该输出什么结果).\n\n\n\n穷举 + 控制信号 思想在 ALU 内部的体现\n\n\n一条指令的执行的那几个 phase 可以设计成:\n\nSingle-Cycle: 在一个时钟周期内完成所有 phases. 由于电路有延迟, 所有 phase 的电路很长, 要求时钟频率不能很高.\nMulti-Cycle: 每个时钟周期只执行一个 phase.\n\n\n\n\n\n\nFigure 1: 为了提升指令执行效率引入了 Pipeline [2]\n\n\n\n\n这样的 CPU: simple, general, 但是 not efficient!\n\n\n\n流水线\n\nPipeline 流水线: 见 Figure fig-single-mult-pipelined.\n在每两个 phase 之间插入一些受始终控制的寄存器:\n\nIF-ID 之间: 当前指令, PC 值 (jal 要用)\nID-EX 之间: 指令类型, rs1, rs2, rd, imm.\n\n\n\n\n第三阶段\n\n总线\n\nAXI4, AHB, APB\n\n\nCache\n\n\nMemory\n\n内存: working memory, main memory\nDRAM & SSD 内存与硬盘\n\n读写速度 (3000 倍): 17 ns vs 50 ms, 超音速飞机和龟速\n容量: 16GB vs 4TB\n\nSIMM & DIMM\n\nDIMM (Dual In-line Memory Module)\n\n\n\n\n\n\n1. Patt YN, Patel SJ (2020) Introduction to computing systems : From bits and gates to c/c++ & beyond. Mcgraw-Hill\n\n\n2. Slchoi (2025) Multi-cycle implementation & pipelining",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>CPU 原理速成</span>"
    ]
  },
  {
    "objectID": "cc-gpu/cc-gpu.html",
    "href": "cc-gpu/cc-gpu.html",
    "title": "GPU 原理速成",
    "section": "",
    "text": "Useful Links\nOngoing",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>GPU 原理速成</span>"
    ]
  },
  {
    "objectID": "yolo/yolo.html",
    "href": "yolo/yolo.html",
    "title": "YOLO Object Detection 目标检测",
    "section": "",
    "text": "Task Objective 任务目标",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>YOLO Object Detection 目标检测</span>"
    ]
  },
  {
    "objectID": "yolo/yolo.html#task-objective-任务目标",
    "href": "yolo/yolo.html#task-objective-任务目标",
    "title": "YOLO Object Detection 目标检测",
    "section": "",
    "text": "识别东西是什么\n将东西的位置框起来\n\n\n两类方法\n解决这个问题的方法有两类:\n\nOne-stage: 推理速度快, 可实时\n\nE.g., YOLO, SSD, RetinaNet\n\nTwo-stage: 准确率高\n\nRegion Proposal 候选区: 先从图片中提取出可能包含目标的 1000-2000 个区域, 然后对每个候选区进行目标对象识别操作.\nE.g., Faster R-CNN, Mask R-CNN, Cascade R-CNN\n\n\n\n\n\nOne stage 和 Two stage 流程框图对比\n\n\n\n\n\n\n\nMSCOCO 数据集有物体名字和位置标注\n\n\n\n\n损失函数\n\n\n\n交并比用来衡量预测地好不好",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>YOLO Object Detection 目标检测</span>"
    ]
  },
  {
    "objectID": "yolo/yolo.html#yolo-v1",
    "href": "yolo/yolo.html#yolo-v1",
    "title": "YOLO Object Detection 目标检测",
    "section": "YOLO V1",
    "text": "YOLO V1\n\nNetwork Structure 网络结构\n\n\n\n\n\n\nFigure 1: YOLO V1 的网络结构 [1]\n\n\n\n\n\n\n\n\n\nFigure 2: Figure fig-yolo-v1 的 Back-Bone 网络其实是若干的卷积网络 [2]\n\n\n\n说明:\n\nFigure fig-back-bone: -s-2 表示 stride 步长为 2.\n输入输出:\n\n输入是一张正方形的图片 (长宽像素各为 \\(448\\), 有 3 个通道: RGB).\n输出的 tensor 大小为 \\(7 \\times 7 \\times 30\\)\n\n\n\n\nLabel Tensor 标签张量\n\nMSCOCO 数据集需要先转换成另外一种形式 (Figure fig-yolo-v1-data-labeling) 再喂给 TOLO V1 神经网络 (即换一种形式打标签而已).\n\n\n\n\n\n\nFigure 3: YOLO V1: \\(S = 7\\), 总共\n\n\n\n每张图片都有 \\(S \\times S = 49\\) 个 grid cell, 每一个 grid cell 都被一个 \\(30 \\times 1\\) 的向量描述, 相当于一张图片都对应了一个 \\(7 \\times 7 \\times 30\\) 的 label tensor.\n\nFigure fig-back-bone 中网络的输出也是一个 \\(7 \\times 7 \\times 30\\) 的 tensor, 但这是 Prediction Tensor 预测张量 (sec-prediction-tensor), 不能混为一谈.\n\n如果有两个物体的中心点都落在同一个 grid cell 中, YOLO V1 只会保留其中一个.\n\n\n\nPrediction Tensor 预测张量\n\n\n\n\n1. 上下求索电子Er (2025) [YOLO V1] 数据标注和输出张量_哔哩哔哩_bilibili\n\n\n2. Redmon J, Divvala S, Girshick R, Farhadi A (2016) You only look once: Unified, real-time object detection",
    "crumbs": [
      "Neural Network",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>YOLO Object Detection 目标检测</span>"
    ]
  },
  {
    "objectID": "hls-design/HLS-design.html",
    "href": "hls-design/HLS-design.html",
    "title": "HLS Design FPGA 并行编程",
    "section": "",
    "text": "Test\nOngoing",
    "crumbs": [
      "ML Accelerators",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>HLS Design FPGA 并行编程</span>"
    ]
  },
  {
    "objectID": "cfu-proj-struct/cfu-proj-struct.html",
    "href": "cfu-proj-struct/cfu-proj-struct.html",
    "title": "CFU-Playground 工程结构",
    "section": "",
    "text": "Folder 文件夹描述",
    "crumbs": [
      "CFU Playground",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>CFU-Playground 工程结构</span>"
    ]
  },
  {
    "objectID": "cfu-proj-struct/cfu-proj-struct.html#folder-文件夹描述",
    "href": "cfu-proj-struct/cfu-proj-struct.html#folder-文件夹描述",
    "title": "CFU-Playground 工程结构",
    "section": "",
    "text": "soc: 存放一个完整的 CPU 的 verilog 设计.\n\n有很多种 CPU, 比如带或不带 CFU 接口的.",
    "crumbs": [
      "CFU Playground",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>CFU-Playground 工程结构</span>"
    ]
  },
  {
    "objectID": "hdl/hdl.html",
    "href": "hdl/hdl.html",
    "title": "HDL 硬件描述语言",
    "section": "",
    "text": "Change of Mind",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "hdl/hdl.html#change-of-mind",
    "href": "hdl/hdl.html#change-of-mind",
    "title": "HDL 硬件描述语言",
    "section": "",
    "text": "Hardware does not “execute” the lines of code in sequence.",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "hdl/hdl.html#verilog",
    "href": "hdl/hdl.html#verilog",
    "title": "HDL 硬件描述语言",
    "section": "Verilog",
    "text": "Verilog\n\nassign\n\n多个 assign 执行没有顺序, 同时进行.\nassign 是 “continuous assignment”, 右值变化时, 左值跟着变化.\n\nOperation 运算符: ~, ! (logical), &, && (logical), |, || (logical), ^ (XOR).\nif, else if 是有顺序的!!!\n(procedure 一定要放在 always 块中吗?)\n(为什么 wire 类型不能在 always 里面被赋值?)\nalways 块中的代码是顺序执行的 (但在 always 块外的代码是并行执行的).\nmodule top (input my_in, output reg my_out);\n    always @(*) begin\n        my_out = 0;\n        my_out = 1; // This is valid! (Always block 按顺序执行)\n    end\nendmodule\n\nLatch 推断: 下面如果 cpu_overheated = 0 则默认会让 shut_off_computer 保持上一个值, 这就是 latch 推断.\nalways @(*) begin\n    if (cpu_overheated)\n        shut_off_computer = 1;\nend\n有时我们就是需要这种推断, 但为了避免, 可以利用always 的顺序性先提前赋值:\nalways @(*) begin\n    shut_off_computer = 0; // 先提前赋值\n    if (cpu_overheated)\n        shut_off_computer = 1;\nend\n\nConcatenation:\nassign out = {tmp, {3{3'b100}}}; // Concatenation, out = 0000011 100 100 100\nindex 可以是负数:\nreg [5:-1] my_reg; // index 可以是负数.\nwire [0:3] my_wire; // Big-endian, mywire[0] is MSB, use my_wire[3:0] later is illegal!\ninput a 默认为 wire.\nbegin end 在只有一行代码时可以省略 (相当于 C 中的 {}).\nwire 不能在 always 块中被赋值. reg 才能在 always 中被赋值.\nwire a;\nalways @(*) begin\n    assign a = 1; // Error!\nend\nwire a;\nalways @(*) begin\n    a &lt;= 1; // Not an error, `a` is viewed as a reg.\nend\nSynchronous and Asynchronous Reset:\n\nsynchronous reset:\nalways @(posedge clk) begin\n    if (reset)\n        ...\nend\nasynchronous reset:\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        ...\nend\n\nor 只能在 always 块中使用, if () 中要用 ||.\nInference 和 Instantiation:\n\nInference: 通过 always 块的内容推断出一个模块的功能.\nInstantiation: 显式地实例化一个模块, 通过 module_name instance_name (port_map) 的方式.\n\n循环群结构 (Torus, etc) 如果用 % 运算符来处理会消耗大量资源, 尽量用 if 语句:\nif (mm == 8'd59) begin\n    mm &lt;= 8'd0;\nend\n\n如果用 % 运算符来处理:\n\n-1 % 16 的结果是 -1, 而不是 15 (所以 (a-1)%16 应该写成 (a+15)%16).\n1~12 的循环先转换为 0~11 的循环, 再换元.\n\n\nBCD (Binary-Coded Decimal): 一种从 0 到 9 的计数器, 输出是四位二进制编码的十进制数.\nBlocking 和 Non-blocking assignments:\n\n=: Blocking assignment, 若在 always 块中使用, 则必须按照顺序执行!\n&lt;=: Non-blocking assignment, 在 always 块中使用时, 会同时执行所有赋值. (一般 always 里面都用这个!)\n\n\n\nVerilog Testbench\n`timescale 1ns / 1ps // #1 代表 1ns, 最精确可以到 #1.001\n`timescale 1ns / 1ns // #1 代表 1ns, #1.01 等是不合法的\n\n$stop //停下来",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "hdl/hdl.html#chisel",
    "href": "hdl/hdl.html#chisel",
    "title": "HDL 硬件描述语言",
    "section": "Chisel",
    "text": "Chisel\n\n+&: 如果 io.in_a 和 io.in_b 为 4.W 时, 则 sum 为 5.W (带溢出).\nval sum = io.in_a +& io.in_b\n允许多个 := 赋值到同一个输出:\nio.out := 0.U\nio.out := 1.U // 覆盖上一个\nif 和 when 的区别:\n\nif 用来在编译阶段决定电路是哪一种\nwhen 用来生成固定的 verilog 电路, 相当于 verilog 的 if.",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>HDL 硬件描述语言</span>"
    ]
  },
  {
    "objectID": "glossary/glossary.html#riscv",
    "href": "glossary/glossary.html#riscv",
    "title": "Glossary 名词解释",
    "section": "RISCV",
    "text": "RISCV\n\nABI (Application Binary Interface): 应用二进制接口. 比如寄存器的使用约定等.\nHart (Hardware Thread): 硬件线程, 指一个独立的处理器核心, 包括一套流水线, 寄存器, PC 等等 (今后将不提处理器核心这个概念, 只提 Hart).",
    "crumbs": [
      "Prologue",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Glossary 名词解释</span>"
    ]
  },
  {
    "objectID": "compilation/compilation.html",
    "href": "compilation/compilation.html",
    "title": "C 语言编译",
    "section": "",
    "text": "编译过程\n装好 RISCV 编译工具链, 创建一个简单的 C 语言程序 hello.c:\n运行:\n用 riscv32-unknown-elf-readelf 查看生成的 .o 文件:\n得到:\n再查看 Section 信息:\n得到:\n对 .o 文件进行反汇编:\n得到:",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C 语言编译</span>"
    ]
  },
  {
    "objectID": "compilation/compilation.html#编译过程",
    "href": "compilation/compilation.html#编译过程",
    "title": "C 语言编译",
    "section": "",
    "text": "gcc 编译选项:\n\n-E: 只预处理, 不编译.\n-S: 生成汇编代码 (.s 文件)\n-c: 只编译, 不链接. (生成 .o 文件)\n-o &lt;file&gt;: 指定输出文件名.\n-g: 在输出的文件中加入支持调试的信息.\n-v (verbose): 显示编译过程中的详细信息.\n\n\n\n\n\n\n\n编译过程\n\n\n\n\n\nhello.c\n\n#include &lt;stdio.h&gt;\n\nint global_init = 0x11111111;\nconst int global_const = 0x22222222;\n\nvoid main()\n{\n    static int static_var = 0x33333333;\n    static int static_var_uninit;\n    int auto_var = 0x44444444;\n    printf(\"hello world!\\n\");\n    return;\n}\n\n\nriscv32-unknown-elf-gcc -c hello.c -o hello.o # 只编译, 不链接\n\nriscv32-unknown-elf-readelf -h hello.o &gt; header_info.log # 查看 Header 信息, 并输出到文件\n\n\n\nheader_info.log\n\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              REL (Relocatable file)\n  Machine:                           RISC-V\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          0 (bytes into file)\n  Start of section headers:          916 (bytes into file)\n  Flags:                             0x5, RVC, double-float ABI\n  Size of this header:               52 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           40 (bytes)\n  Number of section headers:         14\n  Section header string table index: 13\n\n\n\nriscv32-unknown-elf-readelf -S hello.o &gt; section_info.log # 查看 Section 信息, 并输出到文件\n\n\n\nsection_info.log\n\nThere are 14 section headers, starting at offset 0x394:\n\nSection Headers:\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\n  [ 1] .text             PROGBITS        00000000 000034 00002e 00  AX  0   0  2\n  [ 2] .rela.text        RELA            00000000 0002d8 000048 0c   I 11   1  4\n  [ 3] .data             PROGBITS        00000000 000062 000000 00  WA  0   0  1\n  [ 4] .bss              NOBITS          00000000 000064 000004 00  WA  0   0  4\n  [ 5] .sdata            PROGBITS        00000000 000064 000008 00  WA  0   0  4\n  [ 6] .srodata          PROGBITS        00000000 00006c 000004 00   A  0   0  4\n  [ 7] .rodata           PROGBITS        00000000 000070 00000d 00   A  0   0  4\n  [ 8] .comment          PROGBITS        00000000 00007d 00001a 01  MS  0   0  1\n  [ 9] .note.GNU-stack   PROGBITS        00000000 000097 000000 00      0   0  1\n  [10] .riscv.attributes RISCV_ATTRIBUTE 00000000 000097 000066 00      0   0  1\n  [11] .symtab           SYMTAB          00000000 000100 000130 10     12  15  4\n  [12] .strtab           STRTAB          00000000 000230 0000a7 00      0   0  1\n  [13] .shstrtab         STRTAB          00000000 000320 000074 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  D (mbind), p (processor specific)\n\n\n\nriscv32-unknown-elf-objdump -S hello.o &gt; disassembly.s # 反汇编, 并输出到文件\n\n\n\ndisassembly.s\n\n\nhello.o:     file format elf32-littleriscv\n\n\nDisassembly of section .text:\n\n00000000 &lt;main&gt;:\n   0:   1101                    addi    sp,sp,-32\n   2:   ce06                    sw  ra,28(sp)\n   4:   cc22                    sw  s0,24(sp)\n   6:   1000                    addi    s0,sp,32\n   8:   444447b7            lui a5,0x44444\n   c:   44478793            addi    a5,a5,1092 # 44444444 &lt;static_var.0+0x44444440&gt;\n  10:   fef42623            sw  a5,-20(s0)\n  14:   000007b7            lui a5,0x0\n  18:   00078513            mv  a0,a5\n  1c:   00000097            auipc   ra,0x0\n  20:   000080e7            jalr    ra # 1c &lt;main+0x1c&gt;\n  24:   0001                    nop\n  26:   40f2                    lw  ra,28(sp)\n  28:   4462                    lw  s0,24(sp)\n  2a:   6105                    addi    sp,sp,32\n  2c:   8082                    ret",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>C 语言编译</span>"
    ]
  },
  {
    "objectID": "open-src-tools/open-src-tools.html",
    "href": "open-src-tools/open-src-tools.html",
    "title": "Open Source Tools 开源工具",
    "section": "",
    "text": "Behavioral Simulation 行为仿真",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Open Source Tools 开源工具</span>"
    ]
  },
  {
    "objectID": "open-src-tools/open-src-tools.html#behavioral-simulation-行为仿真",
    "href": "open-src-tools/open-src-tools.html#behavioral-simulation-行为仿真",
    "title": "Open Source Tools 开源工具",
    "section": "",
    "text": "即: NOT board-specific 的仿真.\n\n\n用到的工具:",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Open Source Tools 开源工具</span>"
    ]
  },
  {
    "objectID": "open-src-tools/open-src-tools.html#makefile",
    "href": "open-src-tools/open-src-tools.html#makefile",
    "title": "Open Source Tools 开源工具",
    "section": "Makefile",
    "text": "Makefile\n\n格式:\ntarget: prerequisites\n    recipe\n缺省规则\n.DEFAULT_GOAL := all\nall: ...\n伪规则\n.PHONY: all clean",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Open Source Tools 开源工具</span>"
    ]
  },
  {
    "objectID": "open-src-tools/open-src-tools.html#qemu-模拟器",
    "href": "open-src-tools/open-src-tools.html#qemu-模拟器",
    "title": "Open Source Tools 开源工具",
    "section": "QEMU 模拟器",
    "text": "QEMU 模拟器",
    "crumbs": [
      "Crash Courses",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Open Source Tools 开源工具</span>"
    ]
  }
]