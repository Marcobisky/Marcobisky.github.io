[{"content":"基本概念 Alphabet 字母表 Defn. Alphabet is just another name for \u0026ldquo;finite set\u0026rdquo;.\nDefn. An Alphabet $Q$ determines a new set $Q^*$, which contains all finite sequences of elements in $Q$. The elements in $Q^$ are called codewords (on Q). i.e., $$ Q^ := \\bigcup_{i \\in \\mathbb{N}_+} Q^i $$\nNOTE.\nAlphabet 中的元素可以是任何东西！比如：\n$S$ := {\u0026ldquo;dogs\u0026rdquo;, \u0026ldquo;cats\u0026rdquo;, \u0026ldquo;birds\u0026rdquo;}，(含有待编码的东西，\u0026ldquo;source alphabet\u0026rdquo;)\n$T$ := {0, 1}, (含有用来编码的符号, \u0026ldquo;target alphabet\u0026rdquo;)\n$T^*$ := {00, 01, 10, 11}，(含有编码后的东西, \u0026ldquo;codewords\u0026rdquo;)\nsource alphabet 中的元素一般称为 clear text，target alphabet $Q$ 中的元素一般称为 letters, Q* 中的元素是 codewords。\ncodewords 有等长和不等长之分。\nDefn. Let $S$ and $T$ be alphabets, 编码(code)是一个从 $S$ 到 $T^*$ 的映射，i.e. code: $S \\to T^*$.\nNOTE.\n但是我们一般认为 $T^*$ 中的元素才是 code 而不是映射本身，这有点像随机变量一般认为是 $\\tilde{\\Omega}$ 中的元素而不是可测映射本身。\nEx. $Q := {0, 1}$, $\\mathbf{c} = 00100 (\\equiv (0, 0, 1, 0, 0)) \\in Q^*$，$\\mathbf{c}$ 称为 2-ary code of length 5.\nHamming Space 汉明空间 Defn. 设 $Q$ 是 alphabet, $N \\in \\mathbb{N}+$, 度量空间 $(Q^N, h_d)$ 称为 $Q$ 上的 Hamming space. $h_d: Q^N \\times Q^N \\to \\mathbb{N}+$ 称为 Hamming distance, 定义为：\n$$ \\forall \\mathbf{a}, \\mathbf{b} \\in Q^N, h_d(\\mathbf{a}, \\mathbf{b}) := # {i \\in {1, 2, \\ldots N} : a_i \\neq b_i} $$\n","date":"2024-09-13T00:00:00Z","permalink":"http://localhost:1313/p/coding-theory-%E7%BC%96%E7%A0%81%E7%90%86%E8%AE%BA/","title":"Coding Theory 编码理论"},{"content":"Intro 我想在launchpad上面启动一个 java 项目，但是application只支持启动 .app 文件，怎么办？\n解决方案 spotlight 搜索 Automator，打开 Automator，按 command+W 关闭弹出的窗口：\n在导航栏中再次打开 Automator，选择 Application：\n搜索栏中搜索 Run AppleScript，拖拽到右侧的空白区域:\n加入以下内容：\n1 2 3 4 5 on run {input, parameters} set p to POSIX path of (path to me) do shell script \u0026#34;java -jar \u0026#34; \u0026amp; p \u0026amp; \u0026#34;/Contents/Java/YOURJARFILE.jar\u0026#34; end run 记得替换 YOURJARFILE.jar 为你的 jar 文件名。但是此时 \u0026quot;/Contents/Java/ 这个路径是不存在的，而且 YOURJARFILE.jar 也没有在这个路径下，所以以后我们需要创建这个路径。但是首先我们先保存(Command+S)这个文件为一个 .app 文件，路径为 /Application，文件名为你期待这个app的名字，如：YOURJARFILE.app。\n进入 /Application/YOURJARFILE.app，右键点击 Show Package Contents，在 Contents 文件夹下创建 java 文件夹，将你的 YOURJARFILE.jar 拷贝放入这个文件夹。\n然后你就可以通过 launchpad .app 文件启动你的 java 项目了。\n改图标 还是在 Contents 文件夹下，把这个 .icns 文件换成你自己的图标文件，比如可以把 png 文件转换成 icns 文件，然后替换这个文件(文件名不变)。\n然后 Refresh the Icon Cache (if necessary):\n1 2 touch /path/to/YOURJARFILE.app killall Dock Finish!\nReferences How to convert .jar to .app on Mac - a Java tutorial\nLaunching a jar file as an app on Mac (from the dock)\n","date":"2024-09-11T00:00:00Z","permalink":"http://localhost:1313/p/java%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5launchpad%E6%96%B9%E6%A1%88-macos/","title":"java项目导入Launchpad方案 MacOS"},{"content":"Intro 首先我们提出研究布尔代数的动机，为啥要研究布尔代数？1和0的与、或、非运算是人都能算明白，简直显然到家，为啥还要花篇幅研究这个？首先请考虑以下问题：\n集合和布尔代数都有De Morgan\u0026rsquo;s laws，这是巧合吗？ $$ \\overline{A \\cup B} = \\overline{A} \\cap \\overline{B} \\newline \\overline{A \\cap B} = \\overline{A} \\cup \\overline{B} $$ $$ \\overline{A \\vee B} = \\overline{A} \\wedge \\overline{B} \\newline \\overline{A \\wedge B} = \\overline{A} \\vee \\overline{B} $$\nXOR和OR哪个运算更fundamental？\n$\\vee$和$\\wedge$为什么满足双侧分配律？为什么一般的模或向量空间只满足乘法对加法的分配律？分配律的本质是什么？\n逻辑学与布尔代数有什么关系？逻辑学是研究命题以及命题之间的关系的，布尔代数就是0和1一通操作的代数，这两者有什么关系？\n为什么电路会跟逻辑相关？电路能实现一切运算吗？\n很想用抽代的语言来描述布尔代数，具体怎么描述？\n希望通过这篇文章，能够解答上述问题。\nBoole Algebra $(\\mathbb{B^n})$ 和 Boolean Algebra $(K)$ 是不一样的 想到0和1及它们的运算，最先能够联想到的（maybe）是 环 $\\mathbb{Z}/2\\mathbb{Z}$ 上的运算。我们就从 $\\mathbb{Z}/2\\mathbb{Z}$ 出发，不断加上结构，首先得到 Boole 代数，然后再得到 Boolean 代数，这也是历史上的发展顺序。\nBoole Algebra $(\\mathbb{B^n})$ 简单起见，我们把 $\\mathbb{Z}/2\\mathbb{Z}$ 看作特征为2的有限域（而不是环，因为域上向量空间的性质好一点），并将其记作 $\\mathbb{B}$:\n$$ \\mathbb{B} \\equiv { \\bar{0}, \\bar{1} } $$\n（下文我们将省略 bar）\n很容易验证 $\\mathbb{B}$ 上的加法对应 XOR 运算，乘法对应 AND 运算。（从这个角度看，XOR 是比 OR 更fundamental的运算，因为XOR并不依赖任何的电子元件的特征，仅仅是从数学中自然而然引出的概念，即就是 $\\mathbb{Z}/2\\mathbb{Z}$ 上的加法，仅此而已）。\n自然地，我们可以定义 coordinate space $\\mathbb{B}^n$，其中的元素是 $n$-tuples of elements of $\\mathbb{B}$，并且加法的数乘的定义是 component-wise 的。$\\mathbb{B}^n$ 构成 $\\mathbb{B}$ 上的向量空间，所以我们称 $\\mathbb{B}^n$ 中的元素是一个 bit vector，比如：\n$$ \\mathbb{B}^5 \\ni \\mathbf{b} := (1, 0, 1, 1, 0) $$\n现在来研究 $\\mathbb{B}^n$ 上线性组合、span、dimension 等概念。\nBoolean Algebra $(K)$ 下面给出 Boolean 代数的定义：\nDefinition 一个 Boolean 代数 $(K,\\vee, \\wedge, \\bar{} \\space)$ 是一个集合 $K$ equipped with 两个二元运算 $\\vee$ 和 $\\wedge$, 还有一个一元运算 $\\space$ $\\bar{}$ $\\space$, 使得：\nA1. $(K, \\vee)$ 和 $(K, \\wedge)$ 是交换幺半群\nA2. $\\vee$ 和 $\\wedge$ 满足双侧分配律，且二者地位对等\nA3. 存在元素 $0, 1 \\in K$ 使得: A4. $\\space$ $\\bar{}$ $\\space$ 运算由以下公理定义：\n$$ x \\wedge \\bar{x} = 0 \\newline x \\vee \\bar{x} = 1 $$\nA1-A3 称为单调公理，A4 称为补公理。\n","date":"2024-09-10T00:00:00Z","permalink":"http://localhost:1313/p/boolean-algebra-%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/","title":"Boolean Algebra 布尔代数的本质"},{"content":"前置要求 热情passion.\n一些环境 为什么要环境（编译环境和可视化环境）？因为我们不是从头开始造轮子，我们将利用Yale N. Patt创造出的LC-3计算机的架构复现一遍。但是我们将站在一个发明者的视角。环境可以帮助我们学习和分析，并把我们头脑中的数据流动展现出来。我在MacOS上操作，但是其中的链接提供了其他操作系统的安装及使用方法。\n我用到了以下环境：\nlc3tools\u0026ndash;现成的LC-3汇编编译器 有一个现成的编译器总会make out live easier，lc3tools。Unix上请按照README自行编译文件。\n使用方法参考LC-3 Simulator Lab Manual.\nlc3tools 接受一个.asm的文件，输出一个.obj的二进制可执行文件，这将是直接烧录到Program memory中的内容。在造出实物之前，可以将它烧录到lc3uarch中进行仿真和学习：\nlc3uarch\u0026ndash;Data path 模拟 lc3uarch，它接受一个.obj的二进制可执行文件，输出一个单步执行和数据流动的过程：\n很酷吧！\ncustomasm\u0026ndash;自己的汇编编译器！ 我们用customasm工具来写自己的汇编编译器。但不是有现成的LC-3编译器了吗？是因为我们以后可能要自己设计指令集，所以需要用自己写的汇编编译器。但是我们不是from scratch，已经有人写好了：customasm，下面就来安装这个工具。\ncustomasm依赖rust，先用Homebrew安装rust环境：\n1 brew install rust 检测是否装好了：\n1 2 rustc --version cargo --version 其中rustc是rust的编译器，Cargo是Rust的包管理器和构建工具，我们用它再安装customasm并配置环境变量：\n1 2 3 4 cargo install customasm nano ~/.zshrc export PATH=\u0026#34;$HOME/.cargo/bin:$PATH\u0026#34; # Press Ctrl + O to write the changes, Enter to confirm, and Ctrl + X to exit the editor. source ~/.zshrc # apply changes 检测:\n1 customasm --version 看这里学习如何使用customasm.\n","date":"2024-09-07T00:00:00Z","permalink":"http://localhost:1313/p/%E4%B8%80%E8%B5%B7%E9%80%A0%E8%BD%AE%E5%AD%90/","title":"一起造轮子!"},{"content":"Introduction and Overview Building a generic website from scratch is a tough work. However, personal websites for blogs, a special type of website, is actually programmatic. Hugo provides a convenient building templates for that. To make a new blog in Hugo, one could only just create a new folder, write a markdown file (in a specific format) and that\u0026rsquo;s it. You don\u0026rsquo;t need ANY knowledge about HTML or CSS. Well do you need to buy a domain name for everyone to see your posts? Well, GitHub Pages is a free service where you just push some contents in a repository of your own with some extremely easy command line, you created your sites of names like yourname.github.io.\nTools needed Homebrew (Packet Manager) We will use a packet manager called Homebrew to install Hugo. Follow the commands here to download Homebrew first, or you can execute:\n1 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; Once downloaded, if you don\u0026rsquo;t get any error by entering this in the terminal in any folder, you installed it properly (Install testing):\n1 brew --version Git (Version Control System) You can use Homebrew to install Git:\n1 2 brew install git git --version # install testing Install Hugo Run this in any folder:\n1 brew install hugo Install testing:\n1 hugo version Run Example Theme Create Framework Enter the terminal in any folder, you will be creating another main folder called mysite in it. Folder mysite will contain all the contents that are relevant to your website:\n1 2 hugo new site mysite cd mysite Folder mysite should look like this:\nwith most folders in it empty. This is the framework.\nChoose Theme The themes folder is empty, now we will add some code representing a theme inside it. Now choose a template here and downlaod its source code folder inside the themes folder. I use Stack\n1 2 cd themes/ git clone https://github.com/CaiJimmy/hugo-theme-stack.git # Replace as needed Run Theme Now there should be a folder inside themes. Now copy all the things inside a folder like exampleSite into the main mysite folder (\u0026lsquo;\u0026lsquo;replace\u0026rsquo;\u0026rsquo;).\nGo to the main mysite folder and remove the original hugo.tomal file, or you can do:\n1 2 pwd # should be in \u0026#34;mysite\u0026#34; rm hugo.tomal Then (in mysite folder), run:\n1 hugo server -D it will prompt something like:\n1 2 3 4 5 6 Built in 865 ms Environment: \u0026#34;development\u0026#34; Serving pages from disk Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:53844/ (bind address 127.0.0.1) Press Ctrl+C to stop Enter the link provided (http://localhost:53844/). You are done!\nPlay Around This is easy, just compare the contents in each folder and the website and modify things a little.\nPublish your website Note the link (http://localhost:53844/) is private and cannot be visited on other devices. So follow these steps to publish it:\nCreate GitHub Repository Go to your GitHub page and click \u0026lsquo;+\u0026rsquo; on the right upper corner, choose New repository and name it like this:\ni.e., yourname.github.io, which will be your own domain name.\nPush Contents Run this:\n1 hugo --theme=hugo-theme-stack --baseURL=\u0026#34;https://yourname.github.io/\u0026#34; --buildDrafts Then push the contents in your folder public on it by:\n1 2 3 4 5 6 cd public git init git remote add origin https://github.com/yourname/yourname.github.io.git # change as needed git add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin main You can access your website on https://yourname.github.io/ within several minutes.\nNotes After you change contents locally, the contents on https://yourname.github.io/ will not change automatically, you will have to push it on GitHub again:\n1 2 3 4 cd public git add . git commit -m \u0026#34;Add something new\u0026#34; git push origin main Also the public website will not update instantly, you will have to wait several minutes.\n","date":"2024-08-31T00:00:00Z","permalink":"http://localhost:1313/p/create-your-own-website-using-hugo-on-macos/","title":"Create your own website using Hugo on MacOS"},{"content":"Intro and Overview References CLAIM: 本文综合了多个网站的结论和方法，并非原创。\nYou may find these websites useful:\nWorkflow for FPGA development Some open-source tools IceStudio for M2 Mac FPGA Toolchain VHDL compile chain on MacOS Tools related You need these:\ngtkwave: main RTL wave creator Icarus Verilog, and this manual YoSYS: .v to .json GHDL: compile, link and simulation tool for VHDL netlistsvg: .json to .svg Not nessasarily required:\nPulseview: Logic Analyzer (Not required though) Digital: Visual simulation Useful vscode plugins:\nVerilog Support: vscode verilog language highlighter Wavetrace: A nice vscode plugin to replace gtkwave First Project in Verilog Install Icarus Verilog Compiler 1 brew install icarus-verilog Compilation and Simulation 新建文件夹Verilog，在其中新建两个测试文件：GatedDLatch.v and GatedDLatch_tb.v，前者为电路结构描述文件，后者为testbench文件，分别写入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // in GatedDLatch.v module GatedDLatch (Data, WE, Out, OutBar); input Data; input WE; output Out; output OutBar; // component name(output, input1, input2) wire S; wire R; wire Dbar; nand g1(S, Data, WE); not g2(Dbar, Data); nand g3(R, WE, Dbar); nand g4(Out, S, OutBar); nand g5(OutBar, R, Out); endmodule and\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // in GatedDLatch_tb.v `timescale 1ns / 1ns // simulation time, time precision = 1ns //Import the main code into the testbench `include \u0026#34;GatedDLatch.v\u0026#34; module GatedDLatch_tb; //Inputs as registers reg Data; reg WE; //Outputs as wires wire Out; wire OutBar; //Initialisation GatedDLatch uut(Data, WE, Out, OutBar); initial begin //Name of the graph file that gets generated after we run $dumpfile(\u0026#34;GatedDLatch_tb.vcd\u0026#34;); $dumpvars(0,GatedDLatch_tb); Data = 0; WE = 0; #10; Data = 1; #4; WE = 1; #2; WE = 0; #4; Data = 0; #4; WE = 1; #2; WE = 0; #4; $display(\u0026#34;Test complete\u0026#34;); end endmodule 终端运行：\n1 iverilog -o GatedDLatch_tb.vvp GatedDLatch_tb.v 将产生的二进制临时文件 GatedDLatch_tb.vvp 用 vvp 命令转换为 GatedDLatch_tb.vcd waveform file:\n1 vvp GatedDLatch_tb.vvp 安装 Wavetrace 插件后即可查看波形：\n也可以用 gtkwave 软件内查看波形：\n1 2 brew install gtkwave gtkwave GatedDLatch_tb.vcd 下拉 GatedDLatch_tb 列表可显示波形：\nSynthesis and Visualization 我们需要将画出来的电路拓扑可视化（产生Schematics），首先用 YoSYS 将 Verilog 代码转化为数字逻辑电路的门级网表 (gate-level netlist)，先安装 YoSYS:\n1 2 brew install yosys yosys -V # Verify Yosys installation YoSYS 可将电路结构文件 GatedDLatch.v 转换为一个 json 文件：\n1 yosys -p \u0026#34;prep -top GatedDLatch; write_json GatedDLatch.json\u0026#34; GatedDLatch.v 然后我们再安装 netlistsvg 工具:\n1 2 3 4 5 6 7 8 # Install Node.js (if not already installed) brew install node # Install netlistsvg globally using npm npm install -g netlistsvg # Verify netlistsvg installation netlistsvg --version 用 netlistsvg 工具将 GatedDLatch.json 转换为 GatedDLatch.svg:\n1 netlistsvg GatedDLatch.json -o GatedDLatch.svg 预览 GatedDLatch.svg 可得电路结构图：\nMakefile Work Flow 可见整个流程分为上述独立的两大块：\n编译、仿真 iverilog (Compilation) vvp (Simulation) 合成、电路结构可视化 yosys (Synthesis) netlistsvg (Visualization) 我们用 Makefile 自动化这个过程（确保你装了Make有关组件）：在之前建的 Verilog 文件夹下创建一个 Makefile 文件，加入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Description: Makefile for GatedDLatch CIRCUIT_STRUCT = GatedDLatch # Directories BUILD_DIR = build # Ensure the build directory exists $(BUILD_DIR): mkdir -p $(BUILD_DIR) # Compilation: iverilog compilation iverilog: $(CIRCUIT_STRUCT).v $(CIRCUIT_STRUCT)_tb.v | $(BUILD_DIR) iverilog -o $(BUILD_DIR)/$(CIRCUIT_STRUCT)_tb.vvp $(CIRCUIT_STRUCT)_tb.v # Simulation: generate waveform (.vcd) vvp: $(BUILD_DIR)/$(CIRCUIT_STRUCT)_tb.vvp vvp $(BUILD_DIR)/$(CIRCUIT_STRUCT)_tb.vvp # Synthesis: generate circuit structure configuration file (.json) YOSYS: $(CIRCUIT_STRUCT).v | $(BUILD_DIR) yosys -p \u0026#34;prep -top $(CIRCUIT_STRUCT); write_json $(BUILD_DIR)/$(CIRCUIT_STRUCT).json\u0026#34; $(CIRCUIT_STRUCT).v # Visualization: generate human readable (.svg) from .json NETLISTSVG: $(BUILD_DIR)/$(CIRCUIT_STRUCT).json | $(BUILD_DIR) netlistsvg $(BUILD_DIR)/$(CIRCUIT_STRUCT).json -o $(BUILD_DIR)/$(CIRCUIT_STRUCT).svg # Schematic diagram only: Synthesis then Visualization schematic: YOSYS NETLISTSVG # Run all steps run_all: iverilog vvp schematic # Clean build directory clean: rm -rf $(BUILD_DIR) rm -f $(CIRCUIT_STRUCT)_tb.vcd 每次改变文件后只需执行：\n1 2 make clean make run_all 即可生成所有相关文件：\nFirst Project in VHDL Install GHDL Compiler 和 Verilog 一样，VHDL 也是一种硬件描述语言。编译它需要另一个工具：GHDL. 在MacOS上安装它有几个坑，以下步骤在M2 Mac上实测有效（截止2024-09-01）：\n用 brew 安装vhdl:\n1 brew install vhdl vhdl 有两个版本：LLVM和mcode，LLVM版本在Mac上有点问题，而brew下载的正是这个版本，所以我们从这里手动下载mcode的组件，我下的是 ghdl-macos-11-mcode.tgz。\n双击解压，得到三个文件\n将这三个文件复制粘贴到这个路径：/opt/homebrew/Caskroom/ghdl/4.1.0:\n终端输入：\n1 ghdl --version 如果有安全性提示，到系统设置 Privacy \u0026amp; Security 中允许即可:\nCompilation, Linking and Simulation 与Verilog不同，VHDL多了一步Linking，就是将component声明和其实体文件 (testbench) 链接在一起。Verilog为什么不要这一步？因为testbench文件中包含了声明的内容 (include \u0026quot;GatedDLatch.v\u0026quot; )，可自动链接。\nVerilog 中我们用了两中不同的工具 (iverilog, vvp) 来完成编译和仿真。而VHDL只用一个工具：GHDL.\n新建文件夹VHDLDemo，在其中新建两个测试文件：demo.vhdl and demo_tb.vhdl，前者为电路结构描述文件，后者为testbench文件 (也可用.vhd为后缀)，分别写入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity demo is port ( A : in STD_LOGIC; B : in STD_LOGIC; O : out STD_LOGIC ); end demo; architecture Behavioral of demo is begin O \u0026lt;= not (A and B); -- NAND gate end Behavioral; and\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity demo_tb is end demo_tb; architecture Behavioral of demo_tb is signal A : STD_LOGIC := \u0026#39;0\u0026#39;; signal B : STD_LOGIC := \u0026#39;0\u0026#39;; signal O : STD_LOGIC; -- Instantiate the unit under test (UUT) component demo port ( A : in STD_LOGIC; B : in STD_LOGIC; O : out STD_LOGIC ); end component; begin UUT: demo port map ( A =\u0026gt; A, B =\u0026gt; B, O =\u0026gt; O ); -- Test process process begin -- Test case 1: A = 0, B = 0 A \u0026lt;= \u0026#39;0\u0026#39;; B \u0026lt;= \u0026#39;0\u0026#39;; wait for 10 ns; -- Test case 2: A = 0, B = 1 A \u0026lt;= \u0026#39;0\u0026#39;; B \u0026lt;= \u0026#39;1\u0026#39;; wait for 10 ns; -- Test case 3: A = 1, B = 0 A \u0026lt;= \u0026#39;1\u0026#39;; B \u0026lt;= \u0026#39;0\u0026#39;; wait for 10 ns; -- Test case 4: A = 1, B = 1 A \u0026lt;= \u0026#39;1\u0026#39;; B \u0026lt;= \u0026#39;1\u0026#39;; wait for 10 ns; -- End of simulation wait; end process; end Behavioral; 再建立一个 Makefile 文件实现自动化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Description: Makefile for VHDLDemo CIRCUIT = demo TB = demo_tb BUILD_DIR = build # Ensure the build directory exists $(BUILD_DIR): mkdir -p $(BUILD_DIR) # Compilation: compile the design and testbench ghdl_compile: $(BUILD_DIR) ghdl -a --workdir=$(BUILD_DIR) $(CIRCUIT).vhdl ghdl -a --workdir=$(BUILD_DIR) $(TB).vhdl # Linking: Elaborate the design and testbench ghdl_elab: ghdl_compile ghdl -e --workdir=$(BUILD_DIR) $(TB) # Simulation: simulate the testbench ghdl_simulate: ghdl_elab ghdl -r --workdir=$(BUILD_DIR) $(TB) --vcd=$(BUILD_DIR)/$(TB).vcd ### These cannot work for now############################################## # # Synthesis: generate circuit structure configuration file (.json), you should have ghdl plugin installed for yosys, but I have error: \u0026#34;ERROR: No such command: ghdl\u0026#34; or \u0026#34;dyld[5264]: missing symbol called\u0026#34;, possible solution could be to install yosys from source, but not sure # YOSYS: $(CIRCUIT).vhdl | $(BUILD_DIR) # yosys -p \u0026#34;ghdl $(CIRCUIT); prep -top $(CIRCUIT); write_json -compat-int $(BUILD_DIR)/$(CIRCUIT).json\u0026#34; $(CIRCUIT).vhdl # # Visualization: generate human readable (.svg) from .json # NETLISTSVG: $(BUILD_DIR)/$(CIRCUIT).json | $(BUILD_DIR) # netlistsvg $(BUILD_DIR)/$(CIRCUIT).json -o $(BUILD_DIR)/$(CIRCUIT).svg # # Schematic diagram only: Synthesis then Visualization # schematic: YOSYS NETLISTSVG # # Run all steps # run_all: ghdl_compile ghdl_elab ghdl_simulate YOSYS NETLISTSVG ### These cannot work for now############################################## # Run compilation, linking and simulation run_cls: ghdl_compile ghdl_elab ghdl_simulate # Clean build directory clean: rm -rf $(BUILD_DIR) rm -f $(TB) # Experiment: Run testbench without the design file run_tb_only: $(BUILD_DIR) ghdl -a --workdir=$(BUILD_DIR) $(TB).vhdl ghdl -r --workdir=$(BUILD_DIR) $(TB) --vcd=$(BUILD_DIR)/$(TB)_no_design.vcd 运行过程自行理解。命令行执行：\n1 2 make clean make run_cls 即可。\n如果你要看如果不编译链接 design file (demo.vhdl) 会出来什么，可以运行：\n1 2 make clean # Cannot omitted! make run_tb_only 你可以在vscode中或用gtkwave对比两次生成的 .vcd 文件，它们是有区别的。\nNo Synthesis and Visualization Plan 注意这个 Makefile 没有包括画schematic diagram, 因为 yosys 需要装 ghdl 插件，目前适配不是很好，具体可参考 ghdl-yosys-plugin, building-ghdl, 前者提到的方法在M2 Mac上已经试过，会报错：\n1 2 3 4 5 6 7 8 9 10 11 12 /----------------------------------------------------------------------------\\ | yosys -- Yosys Open SYnthesis Suite | | Copyright (C) 2012 - 2024 Claire Xenia Wolf \u0026lt;claire@yosyshq.com\u0026gt; | | Distributed under an ISC-like license, type \u0026#34;license\u0026#34; to see terms | \\----------------------------------------------------------------------------/ Yosys 0.44 (git sha1 80ba43d26, clang++ 15.0.0 -fPIC -O3) -- Running command `ghdl demo_tb.vhdl -e demo_tb; prep -top demo_tb; write_json demo.json\u0026#39; -- 1. Executing GHDL. dyld[5264]: missing symbol called zsh: abort yosys -m ghdl -p 这个问题在 ghdl-yosys-plugin 的 Issues 里面也有人问了，没答案。\n可能的解决方法是从源文件自行编译安装yosys，或者 yosys 或 ghdl 的版本不对，或缺少了工具链中的某个工具。或者用某个工具将 VHDL 转成 Verilog 后再合成 Schematics.\n","date":"2024-08-31T00:00:00Z","image":"http://localhost:1313/p/macos%E6%90%AD%E5%BB%BArtl%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6/cover_hu4598471443165578547.png","permalink":"http://localhost:1313/p/macos%E6%90%AD%E5%BB%BArtl%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6/","title":"MacOS搭建RTL分析框架"}]