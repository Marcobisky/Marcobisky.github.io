[{"content":"Intro Most online VHDL descriptions of JK flip-flops (FF) are based on \u0026ldquo;processes\u0026rdquo; or circuit functionality (behavioral). Is it possible to simulate them only by constructing the circuit structure of the JK flip-flop?\nJK FF Review The circuit structure is JK FF is very familiar to everybody, which is: The corresponding truth table is shown below:\nC J K Q Q̅ ↑ 0 0 latch latch ↑ 0 1 0 1 ↑ 1 0 1 0 ↑ 1 1 toggle toggle x 0 0 latch latch x 0 1 latch latch x 1 0 latch latch x 1 1 latch latch where \u0026ldquo;latch\u0026rdquo; represent the Q output remembers whatever the last stored value was. \u0026ldquo;Toggle\u0026rdquo; means to flip Q, i.e. 0 -\u0026gt; 1, 1 -\u0026gt; 0. \u0026ldquo;↑\u0026rdquo; means the clock signal in a leading edge.\nProblem First try Write the following content in JKFF.vhdl:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity JKFF_nodelay is Port ( J : in STD_LOGIC; -- J input K : in STD_LOGIC; -- K input clk : in STD_LOGIC; -- Clock input Q : out STD_LOGIC; -- Output Q QN : out STD_LOGIC -- Output QN (complement of Q) ); end JKFF_nodelay; architecture Structural of JKFF_nodelay is -- Internal signals for latch and clock gating signal S, R : STD_LOGIC; -- Set and Reset inputs for the latch signal Q_int, QN_int : STD_LOGIC := \u0026#39;0\u0026#39;; -- Internal Q and QN for feedback begin S \u0026lt;= (J and clk) and QN_int; R \u0026lt;= (K and clk) and Q_int; -- NOR gate-based latch Q_int \u0026lt;= not (R or QN_int); QN_int \u0026lt;= not (S or Q_int); -- Outputs Q \u0026lt;= Q_int; -- Main output QN \u0026lt;= QN_int; -- Complementary output end Structural; Then write a testbench file to test the behavior of this circuit, you will find it will not work well.\nReason The reason (probably, only personal view) is that JK FF have two layers of feedback (instead of SR FF, which just have one), since we loop our output Q not only to the NOR gates, but also AND to our initial inputs J and K. This confuse the compiler because the resultant signal changes so fast and maybe not have a stable consequence, so the compiler do not know how to respond to this kind of feedback.\nSo we introduce some delay in the gates to simulate the reality closer.\nSolution Adding delay in the gates We write the following content in another file JKFF.vhdl:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity JKFF is Port ( J : in STD_LOGIC; -- J input K : in STD_LOGIC; -- K input clk : in STD_LOGIC; -- Clock input Q : out STD_LOGIC; -- Output Q QN : out STD_LOGIC -- Output QN (complement of Q) ); end JKFF; architecture Structural of JKFF is -- Internal signals for latch and clock gating signal S, R : STD_LOGIC; -- Set and Reset inputs for the latch signal Q_int, QN_int : STD_LOGIC := \u0026#39;0\u0026#39;; -- Internal Q and QN for feedback begin S \u0026lt;= (J and clk) and QN_int after 0.1 ns; R \u0026lt;= (K and clk) and Q_int after 0.1 ns; -- NOR gate-based latch Q_int \u0026lt;= not (R or QN_int) after 0.2 ns; QN_int \u0026lt;= not (S or Q_int) after 0.2 ns; -- Outputs Q \u0026lt;= Q_int; -- Main output QN \u0026lt;= QN_int; -- Complementary output end Structural; And run the following JKFF_tb.vhdl:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity JKFF_tb is -- No ports for testbench end JKFF_tb; architecture Behavioral of JKFF_tb is -- Component declaration component JKFF Port ( J : in STD_LOGIC; K : in STD_LOGIC; clk : in STD_LOGIC; Q : out STD_LOGIC; QN : out STD_LOGIC ); end component; -- Signals to connect to the JKFF signal J, K, clk : STD_LOGIC := \u0026#39;0\u0026#39;; signal Q, QN : STD_LOGIC; begin -- Instantiate the JK Flip-Flop uut: JKFF Port Map ( J =\u0026gt; J, K =\u0026gt; K, clk =\u0026gt; clk, Q =\u0026gt; Q, QN =\u0026gt; QN ); -- Clock generation process clk_gen: process begin for i in 0 to 9 loop -- Generate 10 clock cycles clk \u0026lt;= \u0026#39;0\u0026#39;; wait for 9 ns; -- Low for 5 ns clk \u0026lt;= \u0026#39;1\u0026#39;; wait for 1 ns; -- High for 5 ns end loop; wait; -- End simulation after clock finishes end process; -- Stimulus process to apply test cases stimulus: process begin -- Test Case 1: Hold state (J = 0, K = 0) J \u0026lt;= \u0026#39;0\u0026#39;; K \u0026lt;= \u0026#39;0\u0026#39;; wait for 20 ns; -- Test Case 2: Set state (J = 1, K = 0) J \u0026lt;= \u0026#39;1\u0026#39;; K \u0026lt;= \u0026#39;0\u0026#39;; wait for 20 ns; -- Test Case 3: Reset state (J = 0, K = 1) J \u0026lt;= \u0026#39;0\u0026#39;; K \u0026lt;= \u0026#39;1\u0026#39;; wait for 20 ns; -- Test Case 4: Toggle state (J = 1, K = 1) J \u0026lt;= \u0026#39;1\u0026#39;; K \u0026lt;= \u0026#39;1\u0026#39;; wait for 40 ns; -- Return to Hold state J \u0026lt;= \u0026#39;0\u0026#39;; K \u0026lt;= \u0026#39;0\u0026#39;; wait for 20 ns; wait; -- End simulation end process; end Behavioral; Results We will get the following waveform:\nThere are several strange things happen here:\nWhat happen before around 30 ns? The Q and QN oscillates at the same pace. Why? It\u0026rsquo;s because both J and K are zero. For a JK FF, this means to remember the last value. But the last value of Q and QN are both zero (we initialize them in the JKFF.vhdl file):\n1 signal Q_int, QN_int : STD_LOGIC := \u0026#39;0\u0026#39;; -- Internal Q and QN for feedback This is invalid and unstable! So they oscillates with a period of 0.2 ns, which is exactly the delay time of the NOR gates.\nOK, if instead we initialize the Q and QN a valid value, say Q_int=0 and QN_int=1 like this (in JKFF.vhdl file):\n1 2 signal Q_int : STD_LOGIC := \u0026#39;0\u0026#39;; -- Internal Q for feedback signal QN_int : STD_LOGIC := \u0026#39;1\u0026#39;; -- Internal QN for feedback Since they are valid, hence stable, Q and QN will not oscillates as expected:\nWhy not toggle successfully? At around $t = 70$ ns, both J and K are 1. This means at the leading edge of the clock signal clk, Q and QN should both flipped! But according to the waveform, they tried but failed, with a tiny pulse around that time.\nI tried several clk pulse width and analysed the JK circuit in \u0026ldquo;slow-motion\u0026rdquo; carefully (Try this! Very surprising!). Finally I figured it out:\nIt\u0026rsquo;s because JK FF don\u0026rsquo;t want the clk signal be high for too long. This is because if the clk line hold high for a sufficient long period, the signal at Q and QN will \u0026ldquo;backpropagate\u0026rdquo; (Haha just borrow the term) to the inputs, continue to control whether or not the J and K signal should come in. If we increase the so-called \u0026ldquo;duty-ratio\u0026rdquo; of the clk signal, we will see these:\nSome value of duty ratio (e.g. 0.65) happen to toggle the Q successfully, while others do not.\nYou can think of what value could the duty ratio be? (Given the clock cycle and the propagation delay of all gates) This is a very intereting yet tedious problem to consider. But as long as you understand why Q oscillates, you understand this.\nTherefore people say that there are no \u0026ldquo;JK latches\u0026rdquo;.\nConclusion The VHDL realization of a JK FF can be achieved by introducing propagation delay to the gates.\n","date":"2024-12-08T00:00:00Z","image":"http://localhost:1313/p/architectural-jk-flip-flop-in-vhdl-jk%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84vhdl%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/mio_hu5533475081215166419.png","permalink":"http://localhost:1313/p/architectural-jk-flip-flop-in-vhdl-jk%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84vhdl%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/","title":"Architectural JK Flip-flop in VHDL JK触发器的VHDL结构实现"},{"content":"Intro 人类最伟大的成就之一就是发明了集合(set)和映射(mapping)这两个概念。他们的抽象性使得自然界的所有存在都可以被这两个概念描述。比如分类就是图片集合到类别集合的映射，图片生成就是文字集合到图片集合的映射，信源编码就是字符集合到codewords集合的映射，等等。要注意这里的集合都是非常大的！比如图片集合是所有图片，不同大小，黑白的、彩色的等等等等，我们姑且称这种集合为“大集合”吧。比如 $\\mathbb{R}$ 到 $\\mathbb{R}$ 上所有函数构成的集合(denoted $\\mathbb{R}^{\\mathbb{R}}$)，这也是“大集合”，这种集合在实践中很难把握和分析。\n说回映射，他们往往都是在人脑中发生的，比如我们看到一张图片，立即认为这是这是一条狗而不是其他的东西，即把图片映成拉狗这个对象，但这个映射写不出表达式！\n或者说，可以？！如果我们粗略地写出了某种表达式，且图片通过这个表达式输出的结果和人脑中输出的结果很像，那是不是可以说我们找到了这种映射的显式表达？\n这正是机器学习干的事情，我们尝试找到一种映射，定义域是所有图片的集合(for example)，值域是物品字符串的集合。如果我们把所有图片到物品字符串的映射也都收集在一起构成一个“大集合”（或称为大函数空间），其实我们要找的就是这个大函数空间中的一个元素！注意是元素，这个元素就是我们脑中的那个映射。\n但是怎么找呢？首先这个映射都没有一个固定的形式，比如它可以是 $y=ax^2$，也可以是 $y = \\sin(ax)+bx+cx^2+d\\log(x)$ 等等所有这样的表达式 (这里简单起见就用一维变量的来说明)。如果我们仅仅把问题就局限在某种特定的函数形式上，这个过程就叫参数化(parametrization)，这里的 $a, b, c, d$ 就叫做参数(parameters)。某一种特定的参数化，远远不能涵盖大函数空间中的所有元素！\n但是有一种参数化形式，它几乎能涵盖整个函数空间！！也就是说，我们只需要考虑这一种形式的函数，就几乎相当于考虑了函数空间的所有函数！这怎么可能呢？当然上面举例的两种参数化显然是不行的，你能想出什么样的映射形式能够“逼近”大函数空间中的任何映射？\nUniversal approximation theorem 这种参数化长这样：\n$$ y = \\sum_{i=1}^m c_i , \\sigma(w_i \\cdot x + b_i) $$\n其中 $\\sigma(.)$ 是一种给定的具体的非线性函数，$w_i$, $b_i$, $c_i$都是参数。$x$ 是哪个集合里面的？我知道你很急，但你先别急，总之你看到了一种特殊的参数化形式，现在我跟你说它能拟合任意的函数！\n如果只有三个参数的话，提供的自由度只有三个，肯定不行。所以它们其实是很多很多（但有限个）参数，只是分成了三类。如果能将这种参数话形式可视化出来就好了，有什么方法呢？\n这种形式的函数都可以表示成这个样子：\n称为（全连接的）“神经网络”。\n神经网络可以拟合任意函数。\n这个结论使得机器学习得以安稳地存在，因为我们知道理论上，只要网络足够复杂，就可以拟合出任意的映射（而不会忙活半天最终证明压根拟合不了！）\n","date":"2024-11-25T00:00:00Z","permalink":"http://localhost:1313/p/machine-learning-notes-updating/","title":"Machine Learning Notes (Updating)"},{"content":"Python 函数 DataFrame DataFrame 是一个类型，每行每列都可以添加标签，也可以利用标签来提取行或列，比nparray更容易组织和修改数据。要index的时候要用 to_numpy() 转换为numpy array类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Create DataFrame data = { \u0026#39;Name\u0026#39;: [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;], \u0026#39;Age\u0026#39;: [24, 27, 22], \u0026#39;Score\u0026#39;: [85, 90, 88] } df = pd.DataFrame(data, index=[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]) print(df) # Select the column with index \u0026#39;Name\u0026#39; column_1 = df[\u0026#39;Name\u0026#39;] print(column_1) row_1 = df.loc[\u0026#39;A\u0026#39;] print(row_1) array = df.to_numpy() print(array) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Name Age Score A Alice 24 85 B Bob 27 90 C Charlie 22 88 A Alice B Bob C Charlie Name: Name, dtype: object Name Alice Age 24 Score 85 Name: A, dtype: object [[\u0026#39;Alice\u0026#39; 24 85] [\u0026#39;Bob\u0026#39; 27 90] [\u0026#39;Charlie\u0026#39; 22 88]] The : Technique : 表示所有 2: 表示从右往左取2个 :5 表示从左向右取5个 For example:\n1 2 3 4 5 6 import numpy as np a = np.array([[1, 2, 3], [0, 0, 0], [2, 3, 4]]) b = a[2:, :3] # Works only for numpy array print(b) 1 [[2 3 4]] The column_stack() 与 row_stack() 函数 仅仅是将两个nparray按照行或列拼在一起\n1 2 3 4 5 6 7 import numpy as np # Demonstrate column_stack() function x = np.array([1, 2, 3, 4, 5]) y = np.array([6, 7, 8, 9, 10]) z = np.row_stack((x, y)) print(z) 1 2 [[ 1 2 3 4 5] [ 6 7 8 9 10]] ","date":"2024-10-29T00:00:00Z","permalink":"http://localhost:1313/p/python-for-ml-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Python for ML 学习笔记"},{"content":"说明 下面的操作已在欧版iphone 16 pro ios 18.1上测试成功，但我个人感觉这个操作跟欧版iPhone没有什么关系，其他版本的iPhone大概率应该也可以，但是不保证。\n本文参考链接：\nlist of tools sideloadly sidestore What is side-downloading ios系统不像安卓系统，只能在iOS store里面下载app。为了打破这点，有两种方法：越狱(jail breaking)或使用side-downloading。本文介绍后者。\nSide-downloading 指通过不越狱的方法将 iOS 应用程序直接安装到 Apple 设备上，而不需要通过 App Store。有很多工具可以实现这点，具体参考list of tools。\n其中 Scarlet 和 Signulous 的方法我没试过，另外三种 AltStore 需要你手机是欧版的、app地区是欧洲、你人也要在欧洲，所以没戏。最后两种 Sideloadly 和 Sidestore，后者下载软件需要连电脑，并且一般 side-downloading 的软件是要“续约(renew)”的，一般每周都要，而且 Sideloadly 这种方法还要连电脑 renew，不方便。所以我们采用最后一种 SideStore（只需要第一次的时候连电脑，后面在手机上下载和 renew）。当然我们也会用 sideloadly 下几个看看，毕竟这种比较简单。\nSideloadly 在 windows 或 mac 上下载安装 sideloadly，图标如下：\n（可能要在 settings 中授权这个应用）\n这个只是个将软件下载到 iPhone 中的工具，而软件在哪里获取呢？我们需要 .ipa 后缀的文件，可以在这里搜索你要的软件，如果没有就在google上搜，最好注意下安全性问题。\n然后打开 sideloadly, 左侧选择你的 .ipa 文件，iDevice选择你的 iPhone（要用线将手机连到mac），输入你的Apple id（要记住这个ID，以后都用这个）和密码，点击start。（start 左边那个按钮是用来 renew 的，将来软件过期的时候就用同样的操作来 renew）\nSidestore 直接按照这里的指示下载安装即可：sidestore。\n其中有一步要产生一个配对文件，记得要将mac连上手机后再运行。如果mac上一直运行不出来，在 terminal 当前文件夹中输入：\n1 sudo ./jitterbugpair 输入密码即可生成\n","date":"2024-10-29T00:00:00Z","permalink":"http://localhost:1313/p/%E5%9C%A8-ios-%E4%B8%8B%E8%BD%BD%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8/","title":"在 ios 下载第三方应用"},{"content":"请在所有概念的后面加上“仅此而已” Please don\u0026rsquo;t over emphasize these concepts! These are just bullshits that horrifies laymans, which CANNOT lift ANY understanding of the principles of communication!!!! So just know these a little bit in case you don\u0026rsquo;t understand what the hell the engineering books are talking about.\nBullshits start here Baseband signal 基带信号，基频信号：原始的未经过频率调制后的信号，其频谱一般在0附近才有。\nSideband signal (SB) 边带信号：调制完以后的信号，频谱分布在carrier信号频率 $f_c$ 的两侧。还分为 upper sideband (USB) 上边带，和 lower sideband (LSB) 下边带。 Bandwidth (B) (模拟信号的)带宽：频谱大概的长度，如图为 $2f_m$。\nRF signal (Radio frequency signal) 射频信号：20 kHz-300 GHz内的电磁波，翻译成无线电多好，还射频。其他波段有其他的名字，如红外线、X射线等。\n","date":"2024-10-21T00:00:00Z","permalink":"http://localhost:1313/p/concepts-in-cps-%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5/","title":"Concepts in CPS 通信概念"},{"content":"Introduction The goal is to find the linear model $y = \\beta_0 + \\beta_1 x$ such that the sum of squared errors between the predicted values and the actual data is minimized.\nLinear Model The form of the linear model is:\n$$ y_i = \\beta_0 + \\beta_1 x_i + \\epsilon_i $$\nwhere $y_i$ is the observed value, $x_i$ is the independent variable, $\\beta_0$ is the intercept, $\\beta_1$ is the slope, and $\\epsilon_i$ is the error term.\nWe wish to find $\\beta_0$ and $\\beta_1$ such that the predicted values $\\hat{y}_i = \\beta_0 + \\beta_1 x_i$ minimize the sum of squared errors between $\\hat{y}_i$ and the observed values $y_i$.\nDesign Matrix and Observation Vector To make the problem more convenient, we represent it using vectors and matrices.\nDesign Matrix Define the design matrix $\\mathbf{X}$ as:\n$$ \\mathbf{X} = \\begin{bmatrix} 1 \u0026amp; 1 \\newline 1 \u0026amp; 2 \\newline 1 \u0026amp; 3 \\newline 1 \u0026amp; 4 \\end{bmatrix} $$\nThe first column contains only 1s, representing the constant term $\\beta_0$, and the second column contains the values of the independent variable $x_i$.\nObservation Vector Define the observation vector $\\mathbf{y}$ as:\n$$ \\mathbf{y} = \\begin{bmatrix} 2 \\newline 3 \\newline 5 \\newline 7 \\end{bmatrix} $$\nThis vector contains all the observed values $y_i$.\nParameter Vector Define the parameter vector $\\boldsymbol{\\beta} = \\begin{bmatrix} \\beta_0 \\newline \\beta_1 \\end{bmatrix}$.\nSum of Squared Errors Objective Function In regression, our goal is to find the parameters $\\boldsymbol{\\beta}$ such that the predicted values $\\hat{\\mathbf{y}} = \\mathbf{X} \\boldsymbol{\\beta}$ are as close as possible to the observed values $\\mathbf{y}$, by minimizing the sum of squared errors (SSE):\n$$ S(\\beta_0, \\beta_1) = \\sum_{i=1}^n (y_i - \\hat{y}_i)^2 = (\\mathbf{y} - \\mathbf{X} \\boldsymbol{\\beta})^T (\\mathbf{y} - \\mathbf{X} \\boldsymbol{\\beta}) $$\nDeriving the Normal Equation The key idea of least squares is to find $\\boldsymbol{\\beta}$ such that the residual $\\mathbf{y} - \\mathbf{X} \\boldsymbol{\\beta}$ is minimized. Geometrically, this means that the residual should be orthogonal to the column space of the design matrix $\\mathbf{X}$, which leads to the normal equation:\n$$ \\mathbf{X}^T (\\mathbf{y} - \\mathbf{X} \\hat{\\boldsymbol{\\beta}}) = 0 $$\nExpanding this:\n$$ \\mathbf{X}^T \\mathbf{y} = \\mathbf{X}^T \\mathbf{X} \\hat{\\boldsymbol{\\beta}} $$\nThis is the normal equation, which can be solved to find the least squares estimate $\\hat{\\boldsymbol{\\beta}}$.\nSolving the Normal Equation Now, let\u0026rsquo;s compute the parts of the normal equation.\nCompute $\\mathbf{X}^T \\mathbf{X}$ $$ \\mathbf{X}^T \\mathbf{X} = \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\newline 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 1 \\newline 1 \u0026amp; 2 \\newline 1 \u0026amp; 3 \\newline 1 \u0026amp; 4 \\end{bmatrix} = \\begin{bmatrix} 4 \u0026amp; 10 \\newline 10 \u0026amp; 30 \\end{bmatrix} $$\nCompute $\\mathbf{X}^T \\mathbf{y}$ $$ \\mathbf{X}^T \\mathbf{y} = \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\newline 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\end{bmatrix} \\begin{bmatrix} 2 \\newline 3 \\newline 5 \\newline 7 \\end{bmatrix} = \\begin{bmatrix} 17 \\newline 50 \\end{bmatrix} $$\nSolve the Normal Equation Now we solve the normal equation:\n$$ \\begin{bmatrix} 4 \u0026amp; 10 \\newline 10 \u0026amp; 30 \\end{bmatrix} \\hat{\\boldsymbol{\\beta}} = \\begin{bmatrix} 17 \\newline 50 \\end{bmatrix} $$\nTo solve this, we first compute the inverse of $\\mathbf{X}^T \\mathbf{X}$:\n$$ (\\mathbf{X}^T \\mathbf{X})^{-1} = \\frac{1}{(4)(30) - (10)(10)} \\begin{bmatrix} 30 \u0026amp; -10 \\newline -10 \u0026amp; 4 \\end{bmatrix} = \\frac{1}{20} \\begin{bmatrix} 30 \u0026amp; -10 \\newline -10 \u0026amp; 4 \\end{bmatrix} $$\nNext, we compute $\\hat{\\boldsymbol{\\beta}}$:\n$$ \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y} $$\n$$ \\hat{\\boldsymbol{\\beta}} = \\frac{1}{20} \\begin{bmatrix} 30 \u0026amp; -10 \\newline -10 \u0026amp; 4 \\end{bmatrix} \\begin{bmatrix} 17 \\newline 50 \\end{bmatrix} = \\frac{1}{20} \\begin{bmatrix} (30)(17) + (-10)(50) \\newline (-10)(17) + (4)(50) \\end{bmatrix} $$\n$$ \\hat{\\boldsymbol{\\beta}} = \\frac{1}{20} \\begin{bmatrix} 510 - 500 \\newline -170 + 200 \\end{bmatrix} = \\frac{1}{20} \\begin{bmatrix} 10 \\newline 30 \\end{bmatrix} = \\begin{bmatrix} 0.5 \\newline 1.5 \\end{bmatrix} $$\nLeast Squares Estimate By solving the normal equation, we find $\\hat{\\beta}_0 = 0.5$ and $\\hat{\\beta}_1 = 1.5$. Thus, the regression model is:\n$$ \\hat{y} = 0.5 + 1.5x $$\nConclusion Using the projection approach, we see that the least squares estimate is the projection of the observation vector $\\mathbf{y}$ onto the space spanned by the columns of the design matrix $\\mathbf{X}$. By solving the normal equation, we found the parameters $\\hat{\\beta}_0 = 0.5$ and $\\hat{\\beta}_1 = 1.5$, which minimize the sum of squared errors.\n","date":"2024-09-21T00:00:00Z","permalink":"http://localhost:1313/p/least-squares-as-projection-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E7%9A%84%E6%8A%95%E5%BD%B1%E8%A7%A3%E9%87%8A/","title":"Least Squares as Projection 最小二乘法的投影解释"},{"content":"基本概念 Alphabet 字母表 Defn. Alphabet is just another name for \u0026ldquo;finite set\u0026rdquo;.\nDefn. An Alphabet $Q$ determines a new set $Q^*$, which contains all finite sequences of elements in $Q$. The elements in $Q^$ are called codewords (on Q). i.e., $$ Q^ := \\bigcup_{i \\in \\mathbb{N}_+} Q^i $$\nNOTE.\nAlphabet 中的元素可以是任何东西！比如：\n$S$ := {\u0026ldquo;dogs\u0026rdquo;, \u0026ldquo;cats\u0026rdquo;, \u0026ldquo;birds\u0026rdquo;}，(含有待编码的东西，\u0026ldquo;source alphabet\u0026rdquo;)\n$T$ := {0, 1}, (含有用来编码的符号, \u0026ldquo;target alphabet\u0026rdquo;)\n$T^*$ := {00, 01, 10, 11}，(含有编码后的东西, \u0026ldquo;codewords\u0026rdquo;)\nsource alphabet 中的元素一般称为 clear text，target alphabet $Q$ 中的元素一般称为 letters, Q* 中的元素是 codewords。\ncodewords 有等长和不等长之分。\nDefn. Let $S$ and $T$ be alphabets, 编码(code)是一个从 $S$ 到 $T^*$ 的映射，i.e. code: $S \\to T^*$.\nNOTE.\n但是我们一般认为 $T^*$ 中的元素才是 code 而不是映射本身，这有点像随机变量一般认为是 $\\tilde{\\Omega}$ 中的元素而不是可测映射本身。\nEx. $Q := {0, 1}$, $\\mathbf{c} = 00100 (\\equiv (0, 0, 1, 0, 0)) \\in Q^*$，$\\mathbf{c}$ 称为 2-ary code of length 5.\nHamming Space 汉明空间 Defn. 设 $Q$ 是 alphabet, $N \\in \\mathbb{N}+$, 度量空间 $(Q^N, h_d)$ 称为 $Q$ 上的 Hamming space. $h_d: Q^N \\times Q^N \\to \\mathbb{N}+$ 称为 Hamming distance, 定义为：\n$$ \\forall \\mathbf{a}, \\mathbf{b} \\in Q^N, h_d(\\mathbf{a}, \\mathbf{b}) := # {i \\in {1, 2, \\ldots N} : a_i \\neq b_i} $$\n","date":"2024-09-13T00:00:00Z","permalink":"http://localhost:1313/p/coding-theory-%E7%BC%96%E7%A0%81%E7%90%86%E8%AE%BA/","title":"Coding Theory 编码理论"},{"content":"Intro 我想在launchpad上面启动一个 java 项目，但是application只支持启动 .app 文件，怎么办？\n解决方案 spotlight 搜索 Automator，打开 Automator，按 command+W 关闭弹出的窗口：\n在导航栏中再次打开 Automator，选择 Application：\n搜索栏中搜索 Run AppleScript，拖拽到右侧的空白区域:\n加入以下内容：\n1 2 3 4 5 on run {input, parameters} set p to POSIX path of (path to me) do shell script \u0026#34;java -jar \u0026#34; \u0026amp; p \u0026amp; \u0026#34;/Contents/Java/YOURJARFILE.jar\u0026#34; end run 记得替换 YOURJARFILE.jar 为你的 jar 文件名。但是此时 \u0026quot;/Contents/Java/ 这个路径是不存在的，而且 YOURJARFILE.jar 也没有在这个路径下，所以以后我们需要创建这个路径。但是首先我们先保存(Command+S)这个文件为一个 .app 文件，路径为 /Application，文件名为你期待这个app的名字，如：YOURJARFILE.app。\n进入 /Application/YOURJARFILE.app，右键点击 Show Package Contents，在 Contents 文件夹下创建 java 文件夹，将你的 YOURJARFILE.jar 拷贝放入这个文件夹。\n然后你就可以通过 launchpad .app 文件启动你的 java 项目了。\n改图标 还是在 Contents 文件夹下，把这个 .icns 文件换成你自己的图标文件，比如可以把 png 文件转换成 icns 文件，然后替换这个文件(文件名不变)。\n然后 Refresh the Icon Cache (if necessary):\n1 2 touch /path/to/YOURJARFILE.app killall Dock Finish!\nReferences How to convert .jar to .app on Mac - a Java tutorial\nLaunching a jar file as an app on Mac (from the dock)\n","date":"2024-09-11T00:00:00Z","permalink":"http://localhost:1313/p/java%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5launchpad%E6%96%B9%E6%A1%88-macos/","title":"java项目导入Launchpad方案 MacOS"},{"content":"Intro 首先我们提出研究布尔代数的动机，为啥要研究布尔代数？1和0的与、或、非运算是人都能算明白，简直显然到家，为啥还要花篇幅研究这个？首先请考虑以下问题：\n集合和布尔代数都有De Morgan\u0026rsquo;s laws，这是巧合吗？ $$ \\overline{A \\cup B} = \\overline{A} \\cap \\overline{B} \\newline \\overline{A \\cap B} = \\overline{A} \\cup \\overline{B} $$ $$ \\overline{A \\vee B} = \\overline{A} \\wedge \\overline{B} \\newline \\overline{A \\wedge B} = \\overline{A} \\vee \\overline{B} $$\nXOR和OR哪个运算更fundamental？\n$\\vee$和$\\wedge$为什么满足双侧分配律？为什么一般的模或向量空间只满足乘法对加法的分配律？分配律的本质是什么？\n逻辑学与布尔代数有什么关系？逻辑学是研究命题以及命题之间的关系的，布尔代数就是0和1一通操作的代数，这两者有什么关系？\n为什么电路会跟逻辑相关？电路能实现一切运算吗？\n很想用抽代的语言来描述布尔代数，具体怎么描述？\n希望通过这篇文章，能够解答上述问题。\nBoole Algebra $(\\mathbb{B^n})$ 和 Boolean Algebra $(K)$ 是不一样的 想到0和1及它们的运算，最先能够联想到的（maybe）是 环 $\\mathbb{Z}/2\\mathbb{Z}$ 上的运算。我们就从 $\\mathbb{Z}/2\\mathbb{Z}$ 出发，不断加上结构，首先得到 Boole 代数，然后再得到 Boolean 代数，这也是历史上的发展顺序。\nBoole Algebra $(\\mathbb{B^n})$ 简单起见，我们把 $\\mathbb{Z}/2\\mathbb{Z}$ 看作特征为2的有限域（而不是环，因为域上向量空间的性质好一点），并将其记作 $\\mathbb{B}$:\n$$ \\mathbb{B} \\equiv { \\bar{0}, \\bar{1} } $$\n（下文我们将省略 bar）\n很容易验证 $\\mathbb{B}$ 上的加法对应 XOR 运算，乘法对应 AND 运算。（从这个角度看，XOR 是比 OR 更fundamental的运算，因为XOR并不依赖任何的电子元件的特征，仅仅是从数学中自然而然引出的概念，即就是 $\\mathbb{Z}/2\\mathbb{Z}$ 上的加法，仅此而已）。\n自然地，我们可以定义 coordinate space $\\mathbb{B}^n$，其中的元素是 $n$-tuples of elements of $\\mathbb{B}$，并且加法的数乘的定义是 component-wise 的。$\\mathbb{B}^n$ 构成 $\\mathbb{B}$ 上的向量空间，所以我们称 $\\mathbb{B}^n$ 中的元素是一个 bit vector，比如：\n$$ \\mathbb{B}^5 \\ni \\mathbf{b} := (1, 0, 1, 1, 0) $$\n现在来研究 $\\mathbb{B}^n$ 上线性组合、span、dimension 等概念。\nBoolean Algebra $(K)$ 下面给出 Boolean 代数的定义：\nDefinition 一个 Boolean 代数 $(K,\\vee, \\wedge, \\bar{} \\space)$ 是一个集合 $K$ equipped with 两个二元运算 $\\vee$ 和 $\\wedge$, 还有一个一元运算 $\\space$ $\\bar{}$ $\\space$, 使得：\nA1. $(K, \\vee)$ 和 $(K, \\wedge)$ 是交换幺半群\nA2. $\\vee$ 和 $\\wedge$ 满足双侧分配律，且二者地位对等\nA3. 存在元素 $0, 1 \\in K$ 使得: A4. $\\space$ $\\bar{}$ $\\space$ 运算由以下公理定义：\n$$ x \\wedge \\bar{x} = 0 \\newline x \\vee \\bar{x} = 1 $$\nA1-A3 称为单调公理，A4 称为补公理。\n","date":"2024-09-10T00:00:00Z","permalink":"http://localhost:1313/p/boolean-algebra-and-category-of-lattices-%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E4%B8%8E%E6%A0%BC%E8%8C%83%E7%95%B4/","title":"Boolean Algebra and Category of Lattices 布尔代数与格范畴"},{"content":"前置要求 热情passion.\n一些环境 为什么要环境（编译环境和可视化环境）？因为我们不是从头开始造轮子，我们将利用Yale N. Patt创造出的LC-3计算机的架构复现一遍。但是我们将站在一个发明者的视角。环境可以帮助我们学习和分析，并把我们头脑中的数据流动展现出来。我在MacOS上操作，但是其中的链接提供了其他操作系统的安装及使用方法。\n我用到了以下环境：\nlc3tools\u0026ndash;现成的LC-3汇编编译器 有一个现成的编译器总会make out live easier，lc3tools。Unix上请按照README自行编译文件。\n使用方法参考LC-3 Simulator Lab Manual.\nlc3tools 接受一个.asm的文件，输出一个.obj的二进制可执行文件，这将是直接烧录到Program memory中的内容。在造出实物之前，可以将它烧录到lc3uarch中进行仿真和学习：\nlc3uarch\u0026ndash;Data path 模拟 lc3uarch，它接受一个.obj的二进制可执行文件，输出一个单步执行和数据流动的过程：\n很酷吧！\ncustomasm\u0026ndash;自己的汇编编译器！ 我们用customasm工具来写自己的汇编编译器。但不是有现成的LC-3编译器了吗？是因为我们以后可能要自己设计指令集，所以需要用自己写的汇编编译器。但是我们不是from scratch，已经有人写好了：customasm，下面就来安装这个工具。\ncustomasm依赖rust，先用Homebrew安装rust环境：\n1 brew install rust 检测是否装好了：\n1 2 rustc --version cargo --version 其中rustc是rust的编译器，Cargo是Rust的包管理器和构建工具，我们用它再安装customasm并配置环境变量：\n1 2 3 4 cargo install customasm nano ~/.zshrc export PATH=\u0026#34;$HOME/.cargo/bin:$PATH\u0026#34; # Press Ctrl + O to write the changes, Enter to confirm, and Ctrl + X to exit the editor. source ~/.zshrc # apply changes 检测:\n1 customasm --version 看这里学习如何使用customasm.\n","date":"2024-09-07T00:00:00Z","permalink":"http://localhost:1313/p/%E4%B8%80%E8%B5%B7%E9%80%A0%E8%BD%AE%E5%AD%90/","title":"一起造轮子!"},{"content":"Introduction and Overview Building a generic website from scratch is a tough work. However, personal websites for blogs, a special type of website, is actually programmatic. Hugo provides a convenient building templates for that. To make a new blog in Hugo, one could only just create a new folder, write a markdown file (in a specific format) and that\u0026rsquo;s it. You don\u0026rsquo;t need ANY knowledge about HTML or CSS. Well do you need to buy a domain name for everyone to see your posts? Well, GitHub Pages is a free service where you just push some contents in a repository of your own with some extremely easy command line, you created your sites of names like yourname.github.io.\nTools needed Homebrew (Packet Manager) We will use a packet manager called Homebrew to install Hugo. Follow the commands here to download Homebrew first, or you can execute:\n1 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; Once downloaded, if you don\u0026rsquo;t get any error by entering this in the terminal in any folder, you installed it properly (Install testing):\n1 brew --version Git (Version Control System) You can use Homebrew to install Git:\n1 2 brew install git git --version # install testing Install Hugo Run this in any folder:\n1 brew install hugo Install testing:\n1 hugo version Run Example Theme Create Framework Enter the terminal in any folder, you will be creating another main folder called mysite in it. Folder mysite will contain all the contents that are relevant to your website:\n1 2 hugo new site mysite cd mysite Folder mysite should look like this:\nwith most folders in it empty. This is the framework.\nChoose Theme The themes folder is empty, now we will add some code representing a theme inside it. Now choose a template here and downlaod its source code folder inside the themes folder. I use Stack\n1 2 cd themes/ git clone https://github.com/CaiJimmy/hugo-theme-stack.git # Replace as needed Run Theme Now there should be a folder inside themes. Now copy all the things inside a folder like exampleSite into the main mysite folder (\u0026lsquo;\u0026lsquo;replace\u0026rsquo;\u0026rsquo;).\nGo to the main mysite folder and remove the original hugo.tomal file, or you can do:\n1 2 pwd # should be in \u0026#34;mysite\u0026#34; rm hugo.tomal Then (in mysite folder), run:\n1 hugo server -D it will prompt something like:\n1 2 3 4 5 6 Built in 865 ms Environment: \u0026#34;development\u0026#34; Serving pages from disk Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:53844/ (bind address 127.0.0.1) Press Ctrl+C to stop Enter the link provided (http://localhost:53844/). You are done!\nPlay Around This is easy, just compare the contents in each folder and the website and modify things a little.\nPublish your website Note the link (http://localhost:53844/) is private and cannot be visited on other devices. So follow these steps to publish it:\nCreate GitHub Repository Go to your GitHub page and click \u0026lsquo;+\u0026rsquo; on the right upper corner, choose New repository and name it like this:\ni.e., yourname.github.io, which will be your own domain name.\nPush Contents Run this:\n1 hugo --theme=hugo-theme-stack --baseURL=\u0026#34;https://yourname.github.io/\u0026#34; --buildDrafts Then push the contents in your folder public on it by:\n1 2 3 4 5 6 cd public git init git remote add origin https://github.com/yourname/yourname.github.io.git # change as needed git add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin main You can access your website on https://yourname.github.io/ within several minutes.\nNotes After you change contents locally, the contents on https://yourname.github.io/ will not change automatically, you will have to push it on GitHub again:\n1 2 3 4 cd public git add . git commit -m \u0026#34;Add something new\u0026#34; git push origin main Also the public website will not update instantly, you will have to wait several minutes.\n","date":"2024-08-31T00:00:00Z","permalink":"http://localhost:1313/p/create-your-own-website-using-hugo-on-macos/","title":"Create your own website using Hugo on MacOS"},{"content":"Intro and Overview References CLAIM: This article synthesizes conclusions and methods from multiple websites and is not pure original. 本文综合了多个网站的结论和方法，并非原创。\nYou may find these websites useful:\nWorkflow for FPGA development Some open-source tools IceStudio for M2 Mac FPGA Toolchain VHDL compile chain on MacOS Tools related You need these:\ngtkwave: main RTL wave creator Icarus Verilog, and this manual YoSYS: .v to .json GHDL: compile, link and simulation tool for VHDL netlistsvg: .json to .svg Not nessasarily required:\nPulseview: Logic Analyzer (Not required though) Digital: Visual simulation Useful vscode plugins:\nVerilog Support: vscode verilog language highlighter Wavetrace: A nice vscode plugin to replace gtkwave First Project in Verilog Install Icarus Verilog Compiler 1 brew install icarus-verilog Compilation and Simulation Create new folder called Verilog, then create two test files named GatedDLatch.v and GatedDLatch_tb.v. The former is the description file of the circuit, the latter is for testbench. And write the following contents respectively:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // in GatedDLatch.v module GatedDLatch (Data, WE, Out, OutBar); input Data; input WE; output Out; output OutBar; // component name(output, input1, input2) wire S; wire R; wire Dbar; nand g1(S, Data, WE); not g2(Dbar, Data); nand g3(R, WE, Dbar); nand g4(Out, S, OutBar); nand g5(OutBar, R, Out); endmodule and\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // in GatedDLatch_tb.v `timescale 1ns / 1ns // simulation time, time precision = 1ns //Import the main code into the testbench `include \u0026#34;GatedDLatch.v\u0026#34; module GatedDLatch_tb; //Inputs as registers reg Data; reg WE; //Outputs as wires wire Out; wire OutBar; //Initialisation GatedDLatch uut(Data, WE, Out, OutBar); initial begin //Name of the graph file that gets generated after we run $dumpfile(\u0026#34;GatedDLatch_tb.vcd\u0026#34;); $dumpvars(0,GatedDLatch_tb); Data = 0; WE = 0; #10; Data = 1; #4; WE = 1; #2; WE = 0; #4; Data = 0; #4; WE = 1; #2; WE = 0; #4; $display(\u0026#34;Test complete\u0026#34;); end endmodule Run this in the terminal:\n1 iverilog -o GatedDLatch_tb.vvp GatedDLatch_tb.v Use vvp command to convert the binary temperary file GatedDLatch_tb.vvp to GatedDLatch_tb.vcd waveform file:\n1 vvp GatedDLatch_tb.vvp Install Wavetrace in vscode to view the waveform:\nYou can also install gtkwave to view the waveform.\n1 2 brew install gtkwave gtkwave GatedDLatch_tb.vcd Expand GatedDLatch_tb list to display the waveform:\nSynthesis and Visualization We can also visualize the circuit topology (called generating schematics). First, use YoSYS to convert the verilog code into gate-level netlist. Of course you should install the command line tool YoSYS:\n1 2 brew install yosys yosys -V # Verify Yosys installation YoSYS will first convert the circuit structure description file GatedDLatch.v into a json file:\n1 yosys -p \u0026#34;prep -top GatedDLatch; write_json GatedDLatch.json\u0026#34; GatedDLatch.v Then we install another tool called netlistsvg:\n1 2 3 4 5 6 7 8 # Install Node.js (if not already installed) brew install node # Install netlistsvg globally using npm npm install -g netlistsvg # Verify netlistsvg installation netlistsvg --version Using the netlistsvg tool to convert GatedDLatch.json to GatedDLatch.svg:\n1 netlistsvg GatedDLatch.json -o GatedDLatch.svg Previewing GatedDLatch.svg will give you the circuit schematic:\nMakefile Work Flow The entire workflow can be divided into two major independent parts:\nCompilation and Simulation: iverilog (Compilation) vvp (Simulation) Synthesis and Circuit Structure Visualization: yosys (Synthesis) netlistsvg (Visualization) We use a Makefile to automate this process (ensure that Make and related components are installed): Create a Makefile file in the previously created Verilog folder and add the following content:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Description: Makefile for GatedDLatch CIRCUIT_STRUCT = GatedDLatch # Directories BUILD_DIR = build # Ensure the build directory exists $(BUILD_DIR): mkdir -p $(BUILD_DIR) # Compilation: iverilog compilation iverilog: $(CIRCUIT_STRUCT).v $(CIRCUIT_STRUCT)_tb.v | $(BUILD_DIR) iverilog -o $(BUILD_DIR)/$(CIRCUIT_STRUCT)_tb.vvp $(CIRCUIT_STRUCT)_tb.v # Simulation: generate waveform (.vcd) vvp: $(BUILD_DIR)/$(CIRCUIT_STRUCT)_tb.vvp vvp $(BUILD_DIR)/$(CIRCUIT_STRUCT)_tb.vvp # Synthesis: generate circuit structure configuration file (.json) YOSYS: $(CIRCUIT_STRUCT).v | $(BUILD_DIR) yosys -p \u0026#34;prep -top $(CIRCUIT_STRUCT); write_json $(BUILD_DIR)/$(CIRCUIT_STRUCT).json\u0026#34; $(CIRCUIT_STRUCT).v # Visualization: generate human readable (.svg) from .json NETLISTSVG: $(BUILD_DIR)/$(CIRCUIT_STRUCT).json | $(BUILD_DIR) netlistsvg $(BUILD_DIR)/$(CIRCUIT_STRUCT).json -o $(BUILD_DIR)/$(CIRCUIT_STRUCT).svg # Schematic diagram only: Synthesis then Visualization schematic: YOSYS NETLISTSVG # Run all steps run_all: iverilog vvp schematic # Clean build directory clean: rm -rf $(BUILD_DIR) rm -f $(CIRCUIT_STRUCT)_tb.vcd After modifying the files, simply execute:\n1 2 make clean make run_all This will generate all the relevant files:\nFirst Project in VHDL Install GHDL Compiler Similar to Verilog, VHDL is also a hardware description language. Compiling it requires another tool: GHDL. Installing it on macOS can be tricky. The following steps have been tested on an M2 Mac (as of 2024-09-01):\nInstall vhdl using brew:\n1 brew install vhdl vhdl has two versions: LLVM and mcode. The LLVM version has some issues on macOS, and the brew-installed version uses LLVM, so we manually download the mcode version from here. I downloaded ghdl-macos-11-mcode.tgz.\nExtract it by double-clicking, and you will get three files:\nCopy and paste these three files to the following path: /opt/homebrew/Caskroom/ghdl/4.1.0:\nIn the terminal, type:\n1 ghdl --version If you encounter security prompts, go to System Settings \u0026gt; Privacy \u0026amp; Security to allow access:\nCompilation, Linking and Simulation Unlike Verilog, VHDL requires an additional Linking step, which connects the component declarations with their implementation files (testbench). Why doesn’t Verilog require this? Because the testbench file in Verilog includes the declaration contents (include \u0026quot;GatedDLatch.v\u0026quot;), so it links automatically.\nIn Verilog, we used two separate tools (iverilog and vvp) for compilation and simulation. However, for VHDL, we only need one tool: GHDL.\nCreate a new folder VHDLDemo, and within it, create two files: demo.vhdl and demo_tb.vhdl. The former describes the circuit structure, and the latter serves as the testbench file (you can also use .vhd as the suffix). Add the following content to the respective files:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity demo is port ( A : in STD_LOGIC; B : in STD_LOGIC; O : out STD_LOGIC ); end demo; architecture Behavioral of demo is begin O \u0026lt;= not (A and B); -- NAND gate end Behavioral; and\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity demo_tb is end demo_tb; architecture Behavioral of demo_tb is signal A : STD_LOGIC := \u0026#39;0\u0026#39;; signal B : STD_LOGIC := \u0026#39;0\u0026#39;; signal O : STD_LOGIC; -- Instantiate the unit under test (UUT) component demo port ( A : in STD_LOGIC; B : in STD_LOGIC; O : out STD_LOGIC ); end component; begin UUT: demo port map ( A =\u0026gt; A, B =\u0026gt; B, O =\u0026gt; O ); -- Test process process begin -- Test case 1: A = 0, B = 0 A \u0026lt;= \u0026#39;0\u0026#39;; B \u0026lt;= \u0026#39;0\u0026#39;; wait for 10 ns; -- Test case 2: A = 0, B = 1 A \u0026lt;= \u0026#39;0\u0026#39;; B \u0026lt;= \u0026#39;1\u0026#39;; wait for 10 ns; -- Test case 3: A = 1, B = 0 A \u0026lt;= \u0026#39;1\u0026#39;; B \u0026lt;= \u0026#39;0\u0026#39;; wait for 10 ns; -- Test case 4: A = 1, B = 1 A \u0026lt;= \u0026#39;1\u0026#39;; B \u0026lt;= \u0026#39;1\u0026#39;; wait for 10 ns; -- End of simulation wait; end process; end Behavioral; Create a Makefile to automate the process:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Description: Makefile for VHDLDemo CIRCUIT = demo TB = demo_tb BUILD_DIR = build # Ensure the build directory exists $(BUILD_DIR): mkdir -p $(BUILD_DIR) # Compilation: compile the design and testbench ghdl_compile: $(BUILD_DIR) ghdl -a --workdir=$(BUILD_DIR) $(CIRCUIT).vhdl ghdl -a --workdir=$(BUILD_DIR) $(TB).vhdl # Linking: Elaborate the design and testbench ghdl_elab: ghdl_compile ghdl -e --workdir=$(BUILD_DIR) $(TB) # Simulation: simulate the testbench ghdl_simulate: ghdl_elab ghdl -r --workdir=$(BUILD_DIR) $(TB) --vcd=$(BUILD_DIR)/$(TB).vcd ### These cannot work for now############################################## # # Synthesis: generate circuit structure configuration file (.json), you should have ghdl plugin installed for yosys, but I have error: \u0026#34;ERROR: No such command: ghdl\u0026#34; or \u0026#34;dyld[5264]: missing symbol called\u0026#34;, possible solution could be to install yosys from source, but not sure # YOSYS: $(CIRCUIT).vhdl | $(BUILD_DIR) # yosys -p \u0026#34;ghdl $(CIRCUIT); prep -top $(CIRCUIT); write_json -compat-int $(BUILD_DIR)/$(CIRCUIT).json\u0026#34; $(CIRCUIT).vhdl # # Visualization: generate human readable (.svg) from .json # NETLISTSVG: $(BUILD_DIR)/$(CIRCUIT).json | $(BUILD_DIR) # netlistsvg $(BUILD_DIR)/$(CIRCUIT).json -o $(BUILD_DIR)/$(CIRCUIT).svg # # Schematic diagram only: Synthesis then Visualization # schematic: YOSYS NETLISTSVG # # Run all steps # run_all: ghdl_compile ghdl_elab ghdl_simulate YOSYS NETLISTSVG ### These cannot work for now############################################## # Run compilation, linking and simulation run_cls: ghdl_compile ghdl_elab ghdl_simulate # Clean build directory clean: rm -rf $(BUILD_DIR) rm -f $(TB) # Experiment: Run testbench without the design file run_tb_only: $(BUILD_DIR) ghdl -a --workdir=$(BUILD_DIR) $(TB).vhdl ghdl -r --workdir=$(BUILD_DIR) $(TB) --vcd=$(BUILD_DIR)/$(TB)_no_design.vcd The running process is very clear. In the command line, execute:\n1 2 make clean make run_cls This will complete the process.\nIf you want to see what happens if you skip compiling and linking the design file (demo.vhdl), run:\n1 2 make clean # Cannot omitted! make run_tb_only You can compare the two .vcd files generated in VSCode or using GTKWave; they are different as expected.\nNo Synthesis and Visualization Plan Note that this Makefile does not include steps to generate a schematic diagram because yosys requires a ghdl plugin. Currently, the integration is not very stable. You can refer to ghdl-yosys-plugin and building-ghdl for more details. However, the suggested methods have been tested on M2 Mac and result in errors:\n1 2 3 4 5 6 7 8 9 10 11 12 /----------------------------------------------------------------------------\\ | yosys -- Yosys Open SYnthesis Suite | | Copyright (C) 2012 - 2024 Claire Xenia Wolf \u0026lt;claire@yosyshq.com\u0026gt; | | Distributed under an ISC-like license, type \u0026#34;license\u0026#34; to see terms | \\----------------------------------------------------------------------------/ Yosys 0.44 (git sha1 80ba43d26, clang++ 15.0.0 -fPIC -O3) -- Running command `ghdl demo_tb.vhdl -e demo_tb; prep -top demo_tb; write_json demo.json\u0026#39; -- 1. Executing GHDL. dyld[5264]: missing symbol called zsh: abort yosys -m ghdl -p This issue has also been mentioned in the Issues section of ghdl-yosys-plugin, but there is no solution yet.\nPossible solutions might include compiling and installing yosys from source, ensuring the correct versions of yosys and ghdl, or checking if any component of the FPGA Toolchain is missing. Alternatively, you could try converting VHDL to Verilog using some tool (like GPT) and then synthesizing the schematics.\n","date":"2024-08-31T00:00:00Z","image":"http://localhost:1313/p/rtl-analysis-on-macos-under-300mb/cover_hu4598471443165578547.png","permalink":"http://localhost:1313/p/rtl-analysis-on-macos-under-300mb/","title":"RTL Analysis on MacOS under 300MB"}]