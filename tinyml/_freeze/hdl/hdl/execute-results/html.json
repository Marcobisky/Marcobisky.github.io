{
  "hash": "bd07e6d585f55f2c5f7d82ec959b3b69",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"HDL 硬件描述语言\"\n---\n\n## Change of Mind\n\n- Hardware does not \"execute\" the lines of code in sequence. \n\n## Verilog\n\n- `assign`\n    - 多个 `assign` 执行**没有顺序**, 同时进行.\n    - `assign` 是 \"continuous assignment\", 右值变化时, 左值跟着变化.\n\n- **Operation 运算符**: `~`, `!` (logical), `&`, `&&` (logical), `|`, `||` (logical), `^` (XOR).\n\n\n- `if, else if` 是有顺序的!!!\n\n- (procedure 一定要放在 always 块中吗?)\n\n\n- (为什么 wire 类型不能在 always 里面被赋值?)\n\n- `always` 块中的代码是**顺序执行**的 (但在 `always` 块外的代码是**并行执行**的).\n\n    ```verilog\n    module top (input my_in, output reg my_out);\n        always @(*) begin\n            my_out = 0;\n            my_out = 1; // This is valid! (Always block 按顺序执行)\n        end\n    endmodule\n    ```\n\n    - **Latch 推断**: 下面如果 `cpu_overheated = 0` 则默认会让 `shut_off_computer` 保持上一个值, 这就是 latch 推断.\n\n        ```verilog\n        always @(*) begin\n            if (cpu_overheated)\n                shut_off_computer = 1;\n        end\n        ```\n        有时我们就是需要这种推断, 但为了避免, 可以利用always 的顺序性先提前赋值:\n        \n        ```verilog\n        always @(*) begin\n            shut_off_computer = 0; // 先提前赋值\n            if (cpu_overheated)\n                shut_off_computer = 1;\n        end\n        ```\n\n- **Concatenation**: \n\n    ```verilog\n    assign out = {tmp, {3{3'b100}}}; // Concatenation, out = 0000011 100 100 100\n    ```\n\n- index 可以是负数:\n\n    ```verilog\n    reg [5:-1] my_reg; // index 可以是负数.\n    wire [0:3] my_wire; // Big-endian, mywire[0] is MSB, use my_wire[3:0] later is illegal!\n    ```\n\n- `input a` 默认为 `wire`.\n\n- `begin end` 在只有一行代码时可以省略 (相当于 C 中的 `{}`).\n\n- `wire` 不能在 `always` 块中被赋值. `reg` 才能在 `always` 中被赋值.\n    \n    ```verilog\n    wire a;\n    always @(*) begin\n        assign a = 1; // Error!\n    end\n    ```\n    ```verilog\n    wire a;\n    always @(*) begin\n        a <= 1; // Not an error, `a` is viewed as a reg.\n    end\n    ```\n\n- **Synchronous and Asynchronous Reset**:\n\n    - synchronous reset: \n\n        ```verilog\n        always @(posedge clk) begin\n            if (reset)\n                ...\n        end\n        ```\n\n    - asynchronous reset: \n\n        ```verilog\n        always @(posedge clk or posedge reset) begin\n            if (reset)\n                ...\n        end\n        ```\n\n- `or` **只能**在 `always` 块中使用, `if ()` 中要用 `||`.\n\n- **Inference** 和 **Instantiation**:\n    - **Inference**: 通过 `always` 块的内容推断出一个模块的功能.\n    - **Instantiation**: 显式地实例化一个模块, 通过 `module_name instance_name (port_map)` 的方式.\n\n - 循环群结构 (Torus, etc) 如果用 `%` 运算符来处理会消耗大量资源, **尽量用 `if` 语句**:\n\n    ```verilog\n    if (mm == 8'd59) begin\n        mm <= 8'd0;\n    end\n    ```\n\n    - 如果用 `%` 运算符来处理:\n        - `-1 % 16` 的结果是 `-1`, 而不是 `15` (所以 `(a-1)%16` 应该写成 `(a+15)%16`).\n        - 1~12 的循环先转换为 0~11 的循环, 再换元.\n\n- **BCD (Binary-Coded Decimal)**: 一种从 0 到 9 的计数器, 输出是四位二进制编码的十进制数.\n\n- **Blocking 和 Non-blocking assignments**:\n    - `=`: Blocking assignment, 若在 `always` 块中使用, 则必须按照顺序执行!\n    - `<=`: Non-blocking assignment, 在 `always` 块中使用时, 会同时执行所有赋值. (一般 `always` 里面都用这个!)\n\n### Verilog Testbench\n\n```verilog\n`timescale 1ns / 1ps // #1 代表 1ns, 最精确可以到 #1.001\n`timescale 1ns / 1ns // #1 代表 1ns, #1.01 等是不合法的\n\n$stop //停下来\n```\n\n\n## Chisel\n\n- `+&`: 如果 `io.in_a` 和 `io.in_b` 为 `4.W` 时, 则 `sum` 为 `5.W` (带溢出).\n\n    ```chisel\n    val sum = io.in_a +& io.in_b\n    ```\n\n- 允许多个 `:=` 赋值到同一个输出:\n\n    ```chisel\n    io.out := 0.U\n    io.out := 1.U // 覆盖上一个\n    ```\n\n- `if` 和 `when` 的区别:\n    - `if` 用来在编译阶段决定电路是哪一种\n    - `when` 用来生成固定的 verilog 电路, 相当于 verilog 的 `if`.\n\n- `orR`: reduction OR, 对所有位进行 OR 操作.\n\n## Area Optimization 面积优化方法\n\n> 有时可读性强的代码会导致使用的逻辑门更多, 占用更多面积. 所以一个模块有时会写两种版本, 一种是可读性强的, 另一种是面积优化的版本.\n\n### CSE 公共子表达式消除\n\n```{scala}\n%%| file: AddSubSimple.scala\n```\n\n```{scala}\n%%| file: AddSubArea.scala\n```\n\n",
    "supporting": [
      "hdl_files"
    ],
    "filters": [],
    "includes": {}
  }
}