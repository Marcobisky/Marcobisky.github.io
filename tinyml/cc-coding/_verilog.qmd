> ***Change of Mind:*** Hardware does not "execute" the lines of code in sequence. 

> 下文不严格区分 Verilog 和 SystemVerilog (你可以当作都是 SystemVerilog).

### Verilog Basics

- `assign`
    - 多个 `assign` 执行**没有顺序**, 同时进行.
    - `assign` 是 "continuous assignment", 右值变化时, 左值跟着变化.

- **Operation 运算符**: `~`, `!` (logical), `&`, `&&` (logical), `|`, `||` (logical), `^` (XOR).


- `if, else if` 是有顺序的!!!

- (procedure 一定要放在 always 块中吗?)


- (为什么 wire 类型不能在 always 里面被赋值?)

- `always` 块中的代码是**顺序执行**的 (但在 `always` 块外的代码是**并行执行**的).

    ```verilog
    module top (input my_in, output reg my_out);
        always @(*) begin
            my_out = 0;
            my_out = 1; // This is valid! (Always block 按顺序执行)
        end
    endmodule
    ```

    - **Latch 推断**: 下面如果 `cpu_overheated = 0` 则默认会让 `shut_off_computer` 保持上一个值, 这就是 latch 推断.

        ```verilog
        always @(*) begin
            if (cpu_overheated)
                shut_off_computer = 1;
        end
        ```
        有时我们就是需要这种推断, 但为了避免, 可以利用always 的顺序性先提前赋值:
        
        ```verilog
        always @(*) begin
            shut_off_computer = 0; // 先提前赋值
            if (cpu_overheated)
                shut_off_computer = 1;
        end
        ```

- `input a` 默认为 `wire`.

- `begin end` 在只有一行代码时可以省略 (相当于 C 中的 `{}`).

- `wire` 不能在 `always` 块中被赋值. `reg` 才能在 `always` 中被赋值.
    
    ```verilog
    wire a;
    always @(*) begin
        assign a = 1; // Error!
    end
    ```
    ```verilog
    wire a;
    always @(*) begin
        a <= 1; // Not an error, `a` is viewed as a reg.
    end
    ```

- **Synchronous and Asynchronous Reset**:

    - synchronous reset: 

        ```verilog
        always @(posedge clk) begin
            if (reset)
                ...
        end
        ```

    - asynchronous reset: 

        ```verilog
        always @(posedge clk or posedge reset) begin
            if (reset)
                ...
        end
        ```

- `or` **只能**在 `always` 块中使用, `if ()` 中要用 `||`.

- **Inference** 和 **Instantiation**:
    - **Inference**: 通过 `always` 块的内容推断出一个模块的功能.
    - **Instantiation**: 显式地实例化一个模块, 通过 `module_name instance_name (port_map)` 的方式:

        ```verilog
        fetcher #(
            .PROGRAM_MEM_ADDR_BITS(PROGRAM_MEM_ADDR_BITS),
            .PROGRAM_MEM_DATA_BITS(PROGRAM_MEM_DATA_BITS)
        ) fetcher_instance (
            .clk(clk),
            .reset(reset),
            .core_state(core_state),
            .current_pc(current_pc),
            ...
        );
        ```
        - 注意 `port_map` 左侧是模块内的端口名, 右侧是当前作用域内的信号名 (不一定要一样).
        - `#(...)` 是 `systemverilog` 的语法, 用来**传递参数**. 同样, 右侧是当前作用域内的参数名.
            - 所以也可以写成: `.PROGRAM_MEM_ADDR_BITS(8)`.



 - 循环群结构 (Torus, etc) 如果用 `%` 运算符来处理会消耗大量资源, **尽量用 `if` 语句**:

    ```verilog
    if (mm == 8'd59) begin
        mm <= 8'd0;
    end
    ```

    - 如果用 `%` 运算符来处理:
        - `-1 % 16` 的结果是 `-1`, 而不是 `15` (所以 `(a-1)%16` 应该写成 `(a+15)%16`).
        - 1~12 的循环先转换为 0~11 的循环, 再换元.

- **BCD (Binary-Coded Decimal)**: 一种从 0 到 9 的计数器, 输出是四位二进制编码的十进制数.

- **Blocking 和 Non-blocking assignments**:
    - `=`: Blocking assignment, 若在 `always` 块中使用, 则必须按照顺序执行!
    - `<=`: Non-blocking assignment, 在 `always` 块中使用时, 会同时执行所有赋值. (一般 `always` 里面都用这个!)

### Verilog 向量

- 一个易错点

    ```verilog
    reg [7:0] foo;      // foo[i] 是 1 bit
    reg [7:0] foo[3:0]; // foo[i] 是 8 bit
    ```

- index 可以是负数:

    ```verilog
    reg [5:-1] my_reg; // index 可以是负数.
    wire [0:3] my_wire; // Big-endian, mywire[0] is MSB, use my_wire[3:0] later is illegal!
    ```

- **Concatenation**: 

    ```verilog
    assign out = {tmp, {3{3'b100}}}; // Concatenation, out = 0000011 100 100 100
    ```

### 硬件代码生成

- `generate for` 块: 用于生成重复的硬件结构 (只是偷懒, 不用写重复的相似代码). (下文两个代码块是等价的, 其中 `gen_regs` 只是一个 label, 可以随便取名)

::: {layout-ncol=2}
```verilog
genvar i; // 只用于生成硬件结构的循环变量
generate
    for (i = 0; i < 4; i = i + 1) begin : gen_regs
        always @(posedge clk) begin
            q[i] <= d[i];
        end
    end
endgenerate
```

```verilog
always @(posedge clk) q[0] <= d[0];
always @(posedge clk) q[1] <= d[1];
always @(posedge clk) q[2] <= d[2];
always @(posedge clk) q[3] <= d[3];
```
:::

- `generate if` 块: 用于根据参数生成不同的硬件结构.

::: {layout-ncol=2}
```verilog
module reg1 #(
    parameter bit USE_RESET = 1
)(
    input  logic clk,
    input  logic rstn,
    input  logic d,
    output logic q
);
generate
    if (USE_RESET) begin
        always @(posedge clk or negedge rstn) begin
            if (!rstn)
                q <= 1'b0;
            else
                q <= d;
        end
    end else begin
        always @(posedge clk) begin
            q <= d;
        end
    end
endgenerate
endmodule
```

```verilog
module reg1 (
    input  logic clk,
    input  logic rstn,
    input  logic d,
    output logic q
);
always @(posedge clk or negedge rstn) begin
    if (!rstn)
        q <= 1'b0;
    else
        q <= d;
end
endmodule
```
:::

### Systemverilog 函数

- `$clog_2`: 向上取整的 $\log_2(\cdot)$, 比如:

    ```verilog
    input wire [$clog2(THREADS_PER_BLOCK):0] thread_count
    ```

### Verilog Testbench

```verilog
`timescale 1ns / 1ps // #1 代表 1ns, 最精确可以到 #1.001
`timescale 1ns / 1ns // #1 代表 1ns, #1.01 等是不合法的

$stop //停下来
```
