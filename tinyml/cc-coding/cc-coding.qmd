---
title: "Random Notes on Coding"
---

## Some C++ Basics

### Class 类

#### `friend` 关键字

在一个类里面声明另一个类 (或函数) 为 `friend`, 表示同意它访问自己的 `private` 和 `protected` 成员:

```{.cpp filename="friend.cpp" #lst-friendcpp}
{{< include src/cpp/friend.cpp >}}
```

### Alias 别名

#### Reference 引用

- Reference 仅仅是 Syntax sugar!
- 必须初始化. `int& ref;` 是错误的.
- `int& ref = a;` 在编译时不会出现 `ref` 这个变量, 它只是 `a` 的别名 (alias).

```{.cpp filename="change_val_ref.cpp" #lst-changevalrefcpp}
{{< include src/cpp/change_val_ref.cpp >}}
```

```{.cpp filename="increment_val_ref.cpp" #lst-incrementvalrefcpp}
{{< include src/cpp/increment_val_ref.cpp >}}
```

#### `typedef` 和 `using`

下面两个都是给 `std::vector<int>` 起别名 `IntList`, 效果一样:

```cpp
using IntList = std::vector<int>;
typedef std::vector<int> IntList;
```

### Namespace 命名空间

- 我们希望在不同的场景中给功能类似的函数起**完全相同的名字** (比如下面例子的 `print()` 函数), 为了**避免命名冲突**, 我们可以使用 `namespace`:

```{.cpp filename="namespace.cpp" #lst-namespacecpp}
{{< include src/cpp/namespace.cpp >}}
```

输出:

```txt
Goodapple Hello
Badapple Hello
Orange Hello
```

- 不要到处拉 `using namespace xxx;` 的 shit!

- 全局作用域运算符:

```{.cpp filename="globalnamespace.cpp" #lst-globalnamespacecpp}
{{< include src/cpp/globalnamespace.cpp >}}
```

<!-- ### Anonymous Functions (Lambda Expressions) -->


## Pybind11

`Pybind11` 是一个 `C++` 库, 使得我们可以在 `Python` 代码中调用 `C++` 函数和类. 比如:

```{.cpp filename="add_op.cpp" #lst-addopcpp}
{{< include src/pybind/add_op.cpp >}}
```

```{.python filename="main.py" #lst-mainpy}
{{< include src/pybind/main.py >}}
```

运行类似下面的命令:

```bash
c++ -O3 -Wall -shared -std=c++11 -fPIC -undefined dynamic_lookup \
    -I/opt/homebrew/anaconda3/lib/python3.12/site-packages/pybind11/include \
    -I/opt/homebrew/anaconda3/include/python3.12 \
    add_op.cpp -o ops.cpython-312-darwin.so

python main.py # output 8
```

第一个命令会在当前目录下产生一个 `.so` (shared object) 文件. 运行 `python main.py` 的时候在 `import ops` 的时候, `Python` 会在 `.so` 文件中找到 `add` 函数.


## Coding Techniques

### 正负无穷

涉及最小/最大值初始化. 例如我们要找 `arr` 中的最大值:

```cpp
#include <float.h>   // for FLT_MAX

int main() {
    float arr[] = {3.2, -1.5, 7.8, 0.0, 4.4};
    int n = sizeof(arr) / sizeof(arr[0]);
    float max_val = -FLT_MAX;    // Initialize to -inf
    for (int i = 0; i < n; i++) {
        if (arr[i] > max_val)   max_val = arr[i];
    }
    std::cout << "Max value: " << max_val << std::endl;
    return 0;
}
```

### 向上取整转为向下取整

可通过 $$\left\lceil \frac{x}{y} \right\rceil = \left\lfloor \frac{x + y - 1}{y} \right\rfloor$$ 实现 (由于整数除法默认向下取整):

```cpp
int ceil_div(int x, int y) {
    return (x + y - 1) / y; // Automatically does floor division
}
```

## Verilog

> ***Change of Mind:*** Hardware does not "execute" the lines of code in sequence. 

- `assign`
    - 多个 `assign` 执行**没有顺序**, 同时进行.
    - `assign` 是 "continuous assignment", 右值变化时, 左值跟着变化.

- **Operation 运算符**: `~`, `!` (logical), `&`, `&&` (logical), `|`, `||` (logical), `^` (XOR).


- `if, else if` 是有顺序的!!!

- (procedure 一定要放在 always 块中吗?)


- (为什么 wire 类型不能在 always 里面被赋值?)

- `always` 块中的代码是**顺序执行**的 (但在 `always` 块外的代码是**并行执行**的).

    ```verilog
    module top (input my_in, output reg my_out);
        always @(*) begin
            my_out = 0;
            my_out = 1; // This is valid! (Always block 按顺序执行)
        end
    endmodule
    ```

    - **Latch 推断**: 下面如果 `cpu_overheated = 0` 则默认会让 `shut_off_computer` 保持上一个值, 这就是 latch 推断.

        ```verilog
        always @(*) begin
            if (cpu_overheated)
                shut_off_computer = 1;
        end
        ```
        有时我们就是需要这种推断, 但为了避免, 可以利用always 的顺序性先提前赋值:
        
        ```verilog
        always @(*) begin
            shut_off_computer = 0; // 先提前赋值
            if (cpu_overheated)
                shut_off_computer = 1;
        end
        ```

- **Concatenation**: 

    ```verilog
    assign out = {tmp, {3{3'b100}}}; // Concatenation, out = 0000011 100 100 100
    ```

- index 可以是负数:

    ```verilog
    reg [5:-1] my_reg; // index 可以是负数.
    wire [0:3] my_wire; // Big-endian, mywire[0] is MSB, use my_wire[3:0] later is illegal!
    ```

- `input a` 默认为 `wire`.

- `begin end` 在只有一行代码时可以省略 (相当于 C 中的 `{}`).

- `wire` 不能在 `always` 块中被赋值. `reg` 才能在 `always` 中被赋值.
    
    ```verilog
    wire a;
    always @(*) begin
        assign a = 1; // Error!
    end
    ```
    ```verilog
    wire a;
    always @(*) begin
        a <= 1; // Not an error, `a` is viewed as a reg.
    end
    ```

- **Synchronous and Asynchronous Reset**:

    - synchronous reset: 

        ```verilog
        always @(posedge clk) begin
            if (reset)
                ...
        end
        ```

    - asynchronous reset: 

        ```verilog
        always @(posedge clk or posedge reset) begin
            if (reset)
                ...
        end
        ```

- `or` **只能**在 `always` 块中使用, `if ()` 中要用 `||`.

- **Inference** 和 **Instantiation**:
    - **Inference**: 通过 `always` 块的内容推断出一个模块的功能.
    - **Instantiation**: 显式地实例化一个模块, 通过 `module_name instance_name (port_map)` 的方式.

 - 循环群结构 (Torus, etc) 如果用 `%` 运算符来处理会消耗大量资源, **尽量用 `if` 语句**:

    ```verilog
    if (mm == 8'd59) begin
        mm <= 8'd0;
    end
    ```

    - 如果用 `%` 运算符来处理:
        - `-1 % 16` 的结果是 `-1`, 而不是 `15` (所以 `(a-1)%16` 应该写成 `(a+15)%16`).
        - 1~12 的循环先转换为 0~11 的循环, 再换元.

- **BCD (Binary-Coded Decimal)**: 一种从 0 到 9 的计数器, 输出是四位二进制编码的十进制数.

- **Blocking 和 Non-blocking assignments**:
    - `=`: Blocking assignment, 若在 `always` 块中使用, 则必须按照顺序执行!
    - `<=`: Non-blocking assignment, 在 `always` 块中使用时, 会同时执行所有赋值. (一般 `always` 里面都用这个!)

### Verilog Testbench

```verilog
`timescale 1ns / 1ps // #1 代表 1ns, 最精确可以到 #1.001
`timescale 1ns / 1ns // #1 代表 1ns, #1.01 等是不合法的

$stop //停下来
```


## Chisel

- `+&`: 如果 `io.in_a` 和 `io.in_b` 为 `4.W` 时, 则 `sum` 为 `5.W` (带溢出).

    ```scala
    val sum = io.in_a +& io.in_b
    ```

- 允许多个 `:=` 赋值到同一个输出:

    ```scala
    io.out := 0.U
    io.out := 1.U // 覆盖上一个
    ```

- `if` 和 `when` 的区别:
    - `if` 用来在编译阶段决定电路是哪一种
    - `when` 用来生成固定的 verilog 电路, 相当于 verilog 的 `if`.

- `orR`: reduction OR, 对所有位进行 OR 操作. 比如 GPR 读寄存器时, 只要地址不是全 0，就读出寄存器的值 (即创建了一个虚拟的 x0 寄存器，值恒为 0):

    ```scala
    io.rdata1 := Mux(io.raddr1.orR, regs(io.raddr1), 0.U)
    io.rdata2 := Mux(io.raddr2.orR, regs(io.raddr2), 0.U)
    ```

### Area Optimization 面积优化方法

> 有时可读性强的代码会导致使用的逻辑门更多, 占用更多面积. 所以一个模块有时会写两种版本, 一种是可读性强的, 另一种是面积优化的版本.

#### CSE 公共子表达式消除

**Common Subexpression Elimination** 也是编译器优化的一种. 举个简单的例子:

```c
int x = a + b;
int y = a + b;
```

可以优化为:

```c
int temp = a + b;
int x = temp;
int y = temp;
```

这样就避免了重复计算 `a + b` 两次.

在 RTL 设计中, 比如 @lst-AddSubSimple 这个简单的加减法模块, **注意到 "减法" 其实等价于 "加上 B 的补码"**, 可以得到更优化的版本 @lst-AddSubArea:

::: {layout-ncol=2}

```{.scala filename="AddSubSimple.scala" #lst-AddSubSimple}
{{< include src/hdl/AddSubSimple.scala >}}
```

```{.scala filename="AddSubArea.scala" #lst-AddSubArea}
{{< include src/hdl/AddSubArea.scala >}}
```

:::

对比他们两个 `sbt` 出来的 `verilog` 代码:

::: {layout-ncol=2}

```{.verilog filename="AddSubSimple.v"}
{{< include src/hdl/AddSubSimple.v >}}
```

```{.verilog filename="AddSubArea.v"}
{{< include src/hdl/AddSubArea.v >}}
```

:::