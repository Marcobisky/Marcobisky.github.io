### C++ Basics

#### `inline` 关键字

- 允许重复定义 (如果你要在头文件里**定义** (而不是声明) 函数最好加上 `inline`):

    ```{.cpp filename="add.cpp" #lst-addcpp}
    inline int add(int a, int b) {return a + b;}
    ```

- 避免函数调用开销, 如果 `add()` 用 @lst-addcpp 来定义, 则:

    ```cpp
    int x = add(3, 5);
    ```

    会被编译器展开成:

    ```cpp
    int x = 3 + 5;
    ```

    (当然这个函数由于过于简单, 如果不用 `inline`, 编译器也会自动优化掉函数调用开销).

#### 命令行参数

- `argc`: Argument Count, 参数个数
- `argv`: Argument Vector, 参数列表 (字符串数组)

```cpp
int main(int argc, char* argv[]) {
    return 0;
}
```

编译运行:

```bash
g++ main.cpp -o main
./main abc 999 test
```

会有:

```cpp
argc = 4
argv[0] = "./main"
argv[1] = "abc"
argv[2] = "999"
argv[3] = "test"
```


### Class 类

#### `this` 指针

就是 `Python` 里的 `self` (当前对象的地址):

```cpp
class A {
private:
    int x;

public:
    void setX(int x) {
        this->x = x;   // Left: member variable; Right: parameter
    }
};
```

#### 类继承

```cpp
class A : public B
```

上面代码表示让 `class A` 继承 `class B`. `public` 表示**公开继承**, 即 `B` 的 `public` 和 `protected` 成员在 `A` 里依然是 `public` 和 `protected`[^protected].

[^protected]: `protected` 和 `private` 区别: 前者代表本类和子类可以访问, 后者只能本类访问 (子类不行).

#### `friend` 关键字

在一个类里面声明另一个类 (或函数) 为 `friend`, 表示同意它访问自己的 `private` 和 `protected` 成员:

```{.cpp filename="friend.cpp" #lst-friendcpp}
{{< include src/cpp/friend.cpp >}}
```

### Alias 别名

#### Reference 引用

- Reference 仅仅是 Syntax sugar!
- 必须初始化. `int& ref;` 是错误的.
- `int& ref = a;` 在编译时不会出现 `ref` 这个变量, 它只是 `a` 的别名 (alias).

```{.cpp filename="change_val_ref.cpp" #lst-changevalrefcpp}
{{< include src/cpp/change_val_ref.cpp >}}
```

```{.cpp filename="increment_val_ref.cpp" #lst-incrementvalrefcpp}
{{< include src/cpp/increment_val_ref.cpp >}}
```

#### `typedef` 和 `using` 关键字

下面两个都是给 `std::vector<int>` 起别名 `IntList`, 效果一样:

```cpp
using IntList = std::vector<int>;
typedef std::vector<int> IntList;
```

### Namespace 命名空间

- 我们希望在不同的场景中给功能类似的函数起**完全相同的名字** (比如下面例子的 `print()` 函数), 为了**避免命名冲突**, 我们可以使用 `namespace`:

```{.cpp filename="namespace.cpp" #lst-namespacecpp}
{{< include src/cpp/namespace.cpp >}}
```

输出:

```txt
Goodapple Hello
Badapple Hello
Orange Hello
```

- 不要到处拉 `using namespace xxx;` 的 shit!

- 全局作用域运算符:

```{.cpp filename="globalnamespace.cpp" #lst-globalnamespacecpp}
{{< include src/cpp/globalnamespace.cpp >}}
```

- `::` 可用于**调用** namespace 里的函数 或 class 里的 `static` 变量或方法. 在外部**定义**类的方法实现时必须用 `::` (调用时用 `.`).

<!-- ### Anonymous Functions (Lambda Expressions) -->
