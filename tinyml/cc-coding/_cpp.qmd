### C++ Basics

#### `inline` 关键字

- 允许重复定义 (如果你要在头文件里**定义** (而不是声明) 函数最好加上 `inline`):

    ```{.cpp filename="add.cpp" #lst-addcpp}
    inline int add(int a, int b) {return a + b;}
    ```

- 避免函数调用开销, 如果 `add()` 用 @lst-addcpp 来定义, 则:

    ```cpp
    int x = add(3, 5);
    ```

    会被编译器展开成:

    ```cpp
    int x = 3 + 5;
    ```

    (当然这个函数由于过于简单, 如果不用 `inline`, 编译器也会自动优化掉函数调用开销).

#### `extern` 关键字

- 告诉编译器这变量存在, 先不要急着报错, 链接的时候会找到它.

    ```cpp
    // var.cpp
    int var = 2;

    // main.cpp
    #include <iostream>
    extern int var;  // Tell compiler var exists somewhere
    int main() {
        std::cout << "var = " << var << std::endl;
        return 0;
    }
    ```

    ```bash
    g++ main.cpp var.cpp -o main
    ./main # Outputs: var = 2
    ```

- `extern "C"`: 当用 Cpp 写的函数名**要被 C 代码 (或汇编) 调用时**需要加上 `extern "C"` 来告诉编译器不要对函数名进行 Name mangling (名字修饰).
    - **Name mangling**: 在 Cpp 中编译出来的 `.o` 文件中的函数名并不是源代码中写的名字 (但是 C 语言中是一样的)! 比如下面的例子:

{{< include src/cpp/extern-c.md >}}


#### 命令行参数

- `argc`: Argument Count, 参数个数
- `argv`: Argument Vector, 参数列表 (字符串数组)

```cpp
int main(int argc, char* argv[]) {
    return 0;
}
```

编译运行:

```bash
g++ main.cpp -o main
./main abc 999 test
```

会有:

```cpp
argc = 4
argv[0] = "./main"
argv[1] = "abc"
argv[2] = "999"
argv[3] = "test"
```

#### 类型转换

TODO

### Memory Management 内存管理

#### Type 数据类型

- `size_t`: 就是 `unsigned int` (RV32 就是 $32$ bit). 一般用来表示内存大小或数组索引.

#### `new` 关键字

`new` 用来在堆上分配内存:

```cpp
int* p = new int[10]; // Allocate 10 integers on heap
for (int i = 0; i < 10; i++) {
    p[i] = i * i; // Assign values
}
delete[] p; // Don't forget to free the memory!
```

分配单个对象. 注意下面两行代码的唯一区别是 `malloc` **没有调用 Constructor**!

```cpp
MyClass* obj = new MyClass(); // Allocate single object
MyClass* obj2 = (MyClass*)malloc(sizeof(MyClass)); // C-style allocation
delete obj; // Free the memory!
free(obj2); // Free C-style allocated memory
```

#### Smart Pointers 智能指针

Smart Pointers = `new` without `delete`. 即不需要担心内存泄漏问题.

- `std::unique_ptr<T>`: 不能被复制:

    ```cpp
    std::unique_ptr<int> p1 = std::make_unique<int>(42); // Create unique_ptr
    // std::unique_ptr<int> p2 = p1; // Error: cannot copy unique_ptr
    ```

- `std::shared_ptr<T>`: 可以被复制 (用过引用计数来管理内存).

- `std::weak_ptr<T>`: 不会增加引用计数, 用于解决 `shared_ptr` 循环引用问题 (@fig-cirref, `a1` 表示 `a` 的引用计数为 1 (`a.use_count() == 1`)):

:::{.column-margin}
![循环引用问题](cirref.png){#fig-cirref}
:::

::: {layout-ncol=2}
```{.cpp filename="sharedptr.cpp" #lst-sharedptrcpp}
{{< include src/cpp/sharedptr.cpp >}}
```

```{.cpp filename="weakptr.cpp" #lst-weakptr}
{{< include src/cpp/weakptr.cpp >}}
```
:::

#### Arena 分配器

TODO

### Class 类

#### Constructor, Init List 构造函数与初始化列表

- **Constructor 构造函数**: 相当于 `Python` 里的 `__init__` 方法. 每次创建对象时会被调用.
    - 可以有多个 Constructor (根据初始化时所带参数数量和类型自动调用, 也是**多态**的一种体现). 名字必须直接用类名: `ClassName()`.
    - 如果没写则编译器默认会生成一个效果跟下面一样的构造函数:

        ```cpp
        ClassName() {} // Default constructor
        // Or
        ClassName() = default;
        ```
    建议显式写出默认构造函数, 以防止别人以为你忘了写.
    
- **Destructor 析构函数**: 相当于 `Python` 里的 `__del__` 方法. 每次对象被销毁时会被调用. 名字是 `~ClassName()`.

- **Constructor member initializer list**: 用于在 Constructor 体**执行前**初始化成员变量 (用 `:` 引出). 那跟放在 Constructor 体里初始化有什么区别呢?
    - `C++` 规定: **所有成员对象, 必须在进入构造函数体之前完成构造**, 比如 #lst-constructorcpp 中进入 `Big(int in) {...}` 之前就必须构造出 `small`, 那只能调用 `Small` 的默认构造方法 `Small()`. 所以 `1` 先被打印. 

::: {layout-ncol=2}
```{.cpp filename="constructor.cpp" #lst-constructorcpp}
{{< include src/cpp/constructor.cpp >}}
```

```{.cpp filename="constructor_init.cpp" #lst-constructorinitcpp}
{{< include src/cpp/constructor_init.cpp >}}
```
:::

#### `this` 指针

就是 `Python` 里的 `self` (当前对象的地址):

```cpp
class A {
private:
    int x;

public:
    void setX(int x) {
        this->x = x;   // Left: member variable; Right: parameter
    }
};
```

#### 类继承

```cpp
class A : public B
```

上面代码表示让 `class A` 继承 `class B`. `public` 表示**公开继承**, 即 `B` 的 `public` 和 `protected` 成员在 `A` 里依然是 `public` 和 `protected`[^protected].

[^protected]: `protected` 和 `private` 区别: 前者代表本类和子类可以访问, 后者只能本类访问 (子类不行).

#### `friend` 关键字

在一个类里面声明另一个类 (或函数) 为 `friend`, 表示同意它访问自己的 `private` 和 `protected` 成员 (注意是谁访问谁的私有成员!):

```{.cpp filename="friend.cpp" #lst-friendcpp}
{{< include src/cpp/friend.cpp >}}
```

### Alias 别名

#### Reference 引用

- Reference 仅仅是 Syntax sugar!
- 必须初始化. `int& ref;` 是错误的.
- `int& ref = a;` 在编译时不会出现 `ref` 这个变量, 它只是 `a` 的别名 (alias).

```{.cpp filename="change_val_ref.cpp" #lst-changevalrefcpp}
{{< include src/cpp/change_val_ref.cpp >}}
```

```{.cpp filename="increment_val_ref.cpp" #lst-incrementvalrefcpp}
{{< include src/cpp/increment_val_ref.cpp >}}
```

#### `typedef` 和 `using` 关键字

下面两个都是给复杂类型 `std::vector<int>` 起好听一点的名字 `IntList`, 效果一样:

```cpp
using IntList = std::vector<int>;
typedef std::vector<int> IntList;
```

### Polymorphism 多态

> 多态: 同一个接口用于不同的数据类型. 这是 OOP 的重要特性之一. 分为:

- 编译时多态: **函数重载**、**运算符重载**.
- 运行时多态: **虚函数**、**纯虚函数**.

#### 函数重载

- 如果你需要让很多同名的函数支持不同类型或数量的参数, 可以把他们放进一个 class 里面, 因为 class 支持**函数重载**:

```{.cpp filename="overload_function.cpp" #lst-overloadfunctioncpp}
{{< include src/cpp/overload_function.cpp >}}
```

#### 运算符重载

- 运算符重载使得 `+`, `*` 这些运算符可以用于自定义 class 之间的运算 (而不仅限于 `int`, `float` 等).
- `Python` 里面也有 `__add__` 这种魔法方法实现重载.
- 重载是不好的编程习惯! 但在写 API 的时候要提供重载和非重载两种接口供开发者使用 (比如下面的 `Add()` 和 `operator+()` 方法), 定义的时候可以用重载定义非重载, 也可以反过来:

::: {layout-ncol=2}
```{.cpp filename="overload_op_calls_method.cpp" #lst-overload_op_calls_methodcpp}
{{< include src/cpp/overload_op_calls_method.cpp >}}
```

```{.cpp filename="overload_method_calls_op.cpp" #lst-overload_method_calls_opcpp}
{{< include src/cpp/overload_method_calls_op.cpp >}}
```
:::

这样就可以直接这样来将两个 `Point` 对象相加:

```{.cpp filename="overload_main.cpp" #lst-overloadmaincpp}
{{< include src/cpp/overload_main.cpp >}}
```

#### 虚函数

- 我们想用同一个函数 `print_res()` 来打印 `A` 类和 `B` 类 (derived from `A`) **各自**的 `forward()` 结果, 我们在 C++ 和 Python 里实现它们, 发现虽然 `print_res()` 定义时规定参数类型是 `A*`, Python 成功调用了各自的 `forward()` 方法, 但 C++ 却都用的是 `A` 类的 `forward()` 方法 (这不是我们所期望的).

::: {layout-ncol=2}
```{.cpp filename="virtual.cc" #lst-virtualcc}
{{< include src/cpp/virtual.cc >}}
```

```{.cpp filename="virtual.py" #lst-virtualpy}
{{< include src/cpp/virtual.py >}}
```
:::

- 为了使得子类的方法能够覆盖 (override) 父类的方法, 我们需要在**父类**的方法前加上 `virtual`, 子类的函数体前加上 `override` (也可以不加).

    ```cpp
    class A {
    public:
        virtual int forward(int x) const {
            return x;
        }
    };

    class B : public A {
    public:
        int forward(int x) const override {
            return 2*x;
        }
    };
    ```

- 虚函数通过 **vtable** 实现, 会增加一点点内存和时间开销, 但小到可以忽略.

#### 纯虚函数 (a.k.a. 接口, 抽象类)

- **动机**: 有时候我们希望一个类**没有**一个具体的方法 (只有一个抽象的方法), 很多子类都去实现这个方法. 以 @lst-virtualcc 来说的话就是我们希望 `A` 类的 `forward()` 方法不要有具体实现, 让所有子类都去实现它. 这样的类叫做 **Abstract Class 抽象类**, 也叫做 **Interface 接口** (很形象吧).
    - 比如 @lst-virtualpurecc 中的 `Speaker` 很抽象吧嘿嘿.

- 实现: 在父类的方法后面前加上 `= 0`, 称为一个 **Pure Virtual Function 纯虚函数**.
    - 这样的抽象类不能被实例化, 只有子类可以被实例化.

```{.cpp filename="virtual_pure.cc" #lst-virtualpurecc}
{{< include src/cpp/virtual_pure.cc >}}
```

- 但是 @lst-virtualpurecc 会有个 warning: 

    ```bash
    virtual_pure.cc:34:5: warning: delete called on 'Speaker' that is abstract but has non-virtual destructor [-Wdelete-abstract-non-virtual-dtor]
    34 |     delete cat;
       |     ^
    ```
    这是因为 `delete` 一个 `Speaker` 类型的指针时, 会去调用 `Speaker` 抽象类的析构函数 (注意这个析构函数是被隐式创建过的), 这时候编译器非常贴心的提醒我们: **你应该想调用的是子类的析构函数吧**, 你最好把父类的析构函数也声明为 `virtual`:

    ```cpp
    class Speaker {
    public:
        virtual ~Speaker() = default;
        virtual void speak() = 0; // pure virtual
    };
    ```


### Namespace 命名空间

- 我们希望在不同的场景中给功能类似的函数起**完全相同的名字** (比如下面例子的 `print()` 函数), 为了**避免命名冲突**, 我们可以使用 `namespace`:

```{.cpp filename="namespace.cpp" #lst-namespacecpp}
{{< include src/cpp/namespace.cpp >}}
```

输出:

```txt
Goodapple Hello
Badapple Hello
Orange Hello
```

- 不要到处拉 `using namespace xxx;` 的 shit!

- 全局作用域运算符:

```{.cpp filename="globalnamespace.cpp" #lst-globalnamespacecpp}
{{< include src/cpp/globalnamespace.cpp >}}
```

- `::` 可用于**调用** namespace 里的函数 或 class 里的 `static` 变量或方法. 在外部**定义**类的方法实现时必须用 `::` (调用时用 `.`).

<!-- ### Anonymous Functions (Lambda Expressions) -->

### 常见库用法

#### `std::copy()`

```cpp
#include <vector>
#include <algorithm>  // std::copy

int main() {
    std::vector<int> src = {1, 2, 3, 4, 5};
    std::vector<int> dst(5);   // Must arrange space in advance

    std::copy(src.begin(), src.end(), dst.begin()); // Copy src to dst
}
```
