### C++ Basics

#### `inline` 关键字

- 允许重复定义 (如果你要在头文件里**定义** (而不是声明) 函数最好加上 `inline`):

    ```{.cpp filename="add.cpp" #lst-addcpp}
    inline int add(int a, int b) {return a + b;}
    ```

- 避免函数调用开销, 如果 `add()` 用 @lst-addcpp 来定义, 则:

    ```cpp
    int x = add(3, 5);
    ```

    会被编译器展开成:

    ```cpp
    int x = 3 + 5;
    ```

    (当然这个函数由于过于简单, 如果不用 `inline`, 编译器也会自动优化掉函数调用开销).

#### `extern` 关键字

- 告诉编译器这变量存在, 先不要急着报错, 链接的时候会找到它.

    ```cpp
    // var.cpp
    int var = 2;

    // main.cpp
    #include <iostream>
    extern int var;  // Tell compiler var exists somewhere
    int main() {
        std::cout << "var = " << var << std::endl;
        return 0;
    }
    ```

    ```bash
    g++ main.cpp var.cpp -o main
    ./main # Outputs: var = 2
    ```

- `extern "C"`: 当用 Cpp 写的函数名**要被 C 代码 (或汇编) 调用时**需要加上 `extern "C"` 来告诉编译器不要对函数名进行 Name mangling (名字修饰).
    - **Name mangling**: 在 Cpp 中编译出来的 `.o` 文件中的函数名并不是源代码中写的名字 (但是 C 语言中是一样的)! 比如下面的例子:

{{< include src/cpp/extern-c.md >}}


#### 命令行参数

- `argc`: Argument Count, 参数个数
- `argv`: Argument Vector, 参数列表 (字符串数组)

```cpp
int main(int argc, char* argv[]) {
    return 0;
}
```

编译运行:

```bash
g++ main.cpp -o main
./main abc 999 test
```

会有:

```cpp
argc = 4
argv[0] = "./main"
argv[1] = "abc"
argv[2] = "999"
argv[3] = "test"
```

#### 类型转换

TODO

### Memory Management 内存管理

#### Type 数据类型

- `size_t`: 就是 `unsigned int` (RV32 就是 $32$ bit). 一般用来表示内存大小或数组索引.

#### `new` 关键字

`new` 用来在堆上分配内存:

```cpp
int* p = new int[10]; // Allocate 10 integers on heap
for (int i = 0; i < 10; i++) {
    p[i] = i * i; // Assign values
}
delete[] p; // Don't forget to free the memory!
```

分配单个对象. 注意下面两行代码的唯一区别是 `malloc` **没有调用 Constructor**!

```cpp
MyClass* obj = new MyClass(); // Allocate single object
MyClass* obj2 = (MyClass*)malloc(sizeof(MyClass)); // C-style allocation
delete obj; // Free the memory!
free(obj2); // Free C-style allocated memory
```

#### Smart Pointers 智能指针

Smart Pointers = `new` without `delete`. 即不需要担心内存泄漏问题.

- `std::unique_ptr<T>`: 不能被复制:

    ```cpp
    std::unique_ptr<int> p1 = std::make_unique<int>(42); // Create unique_ptr
    // std::unique_ptr<int> p2 = p1; // Error: cannot copy unique_ptr
    ```

- `std::shared_ptr<T>`: 可以被复制 (用过引用计数来管理内存).

- `std::weak_ptr<T>`: 不会增加引用计数, 用于解决 `shared_ptr` 循环引用问题 (@fig-cirref, `a1` 表示 `a` 的引用计数为 1 (`a.use_count() == 1`)):

:::{.column-margin}
![循环引用问题](cirref.png){#fig-cirref}
:::

::: {layout-ncol=2}
```{.cpp filename="sharedptr.cpp" #lst-sharedptrcpp}
{{< include src/cpp/sharedptr.cpp >}}
```

```{.cpp filename="weakptr.cpp" #lst-weakptr}
{{< include src/cpp/weakptr.cpp >}}
```
:::

#### Arena 分配器

TODO

### Class 类

#### Constructor, Init List 构造函数与初始化列表

- **Constructor**: 相当于 `Python` 里的 `__init__` 方法. 每次创建对象时会被调用. 可以有多个 Constructor (根据是否带参数区分). 名字是 `ClassName()`.
    - **Destructor**: 相当于 `Python` 里的 `__del__` 方法. 每次对象被销毁时会被调用. 名字是 `~ClassName()`.

- **Constructor member initializer list**: 用于在 Constructor 体**执行前**初始化成员变量 (用 `:` 引出). 那跟放在 Constructor 体里初始化有什么区别呢? 见下面例子:

::: {layout-ncol=2}
```{.cpp filename="constructor.cpp" #lst-constructorcpp}
{{< include src/cpp/constructor.cpp >}}
```

```{.cpp filename="constructor_init.cpp" #lst-constructorinitcpp}
{{< include src/cpp/constructor_init.cpp >}}
```
:::

#### `this` 指针

就是 `Python` 里的 `self` (当前对象的地址):

```cpp
class A {
private:
    int x;

public:
    void setX(int x) {
        this->x = x;   // Left: member variable; Right: parameter
    }
};
```

#### 类继承

```cpp
class A : public B
```

上面代码表示让 `class A` 继承 `class B`. `public` 表示**公开继承**, 即 `B` 的 `public` 和 `protected` 成员在 `A` 里依然是 `public` 和 `protected`[^protected].

[^protected]: `protected` 和 `private` 区别: 前者代表本类和子类可以访问, 后者只能本类访问 (子类不行).

#### `friend` 关键字

在一个类里面声明另一个类 (或函数) 为 `friend`, 表示同意它访问自己的 `private` 和 `protected` 成员 (注意是谁访问谁的私有成员!):

```{.cpp filename="friend.cpp" #lst-friendcpp}
{{< include src/cpp/friend.cpp >}}
```

### Alias 别名

#### Reference 引用

- Reference 仅仅是 Syntax sugar!
- 必须初始化. `int& ref;` 是错误的.
- `int& ref = a;` 在编译时不会出现 `ref` 这个变量, 它只是 `a` 的别名 (alias).

```{.cpp filename="change_val_ref.cpp" #lst-changevalrefcpp}
{{< include src/cpp/change_val_ref.cpp >}}
```

```{.cpp filename="increment_val_ref.cpp" #lst-incrementvalrefcpp}
{{< include src/cpp/increment_val_ref.cpp >}}
```

#### `typedef` 和 `using` 关键字

下面两个都是给 `std::vector<int>` 起别名 `IntList`, 效果一样:

```cpp
using IntList = std::vector<int>;
typedef std::vector<int> IntList;
```

#### Overloading 重载

- 重载使得 `+`, `*` 这些运算符可以用于自定义 class 之间的运算 (而不仅限于 `int`, `float` 等).
- `Python` 里面也有 `__add__` 这种魔法方法实现重载.
- 重载是不好的编程习惯! 但在写 API 的时候要提供重载和非重载两种接口供开发者使用 (比如下面的 `Add()` 和 `operator+()` 方法), 定义的时候可以用重载定义非重载, 也可以反过来:

::: {layout-ncol=2}
```{.cpp filename="overload_op_calls_method.cpp" #lst-overload_op_calls_methodcpp}
{{< include src/cpp/overload_op_calls_method.cpp >}}
```

```{.cpp filename="overload_method_calls_op.cpp" #lst-overload_method_calls_opcpp}
{{< include src/cpp/overload_method_calls_op.cpp >}}
```
:::

这样就可以直接这样来将两个 `Point` 对象相加:

```{.cpp filename="overload_main.cpp" #lst-overloadmaincpp}
{{< include src/cpp/overload_main.cpp >}}
```


### Namespace 命名空间

- 我们希望在不同的场景中给功能类似的函数起**完全相同的名字** (比如下面例子的 `print()` 函数), 为了**避免命名冲突**, 我们可以使用 `namespace`:

```{.cpp filename="namespace.cpp" #lst-namespacecpp}
{{< include src/cpp/namespace.cpp >}}
```

输出:

```txt
Goodapple Hello
Badapple Hello
Orange Hello
```

- 不要到处拉 `using namespace xxx;` 的 shit!

- 全局作用域运算符:

```{.cpp filename="globalnamespace.cpp" #lst-globalnamespacecpp}
{{< include src/cpp/globalnamespace.cpp >}}
```

- `::` 可用于**调用** namespace 里的函数 或 class 里的 `static` 变量或方法. 在外部**定义**类的方法实现时必须用 `::` (调用时用 `.`).

<!-- ### Anonymous Functions (Lambda Expressions) -->

### 常见库用法

#### `std::copy()`

```cpp
#include <vector>
#include <algorithm>  // std::copy

int main() {
    std::vector<int> src = {1, 2, 3, 4, 5};
    std::vector<int> dst(5);   // Must arrange space in advance

    std::copy(src.begin(), src.end(), dst.begin()); // Copy src to dst
}
```
