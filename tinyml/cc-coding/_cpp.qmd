### C++ Basics

#### `inline` 关键字

- 允许重复定义 (如果你要在头文件里**定义** (而不是声明) 函数最好加上 `inline`):

    ```{.cpp filename="add.cpp" #lst-addcpp}
    inline int add(int a, int b) {return a + b;}
    ```

- 避免函数调用开销, 如果 `add()` 用 @lst-addcpp 来定义, 则:

    ```cpp
    int x = add(3, 5);
    ```

    会被编译器展开成:

    ```cpp
    int x = 3 + 5;
    ```

    (当然这个函数由于过于简单, 如果不用 `inline`, 编译器也会自动优化掉函数调用开销).

#### 命令行参数

- `argc`: Argument Count, 参数个数
- `argv`: Argument Vector, 参数列表 (字符串数组)

```cpp
int main(int argc, char* argv[]) {
    return 0;
}
```

编译运行:

```bash
g++ main.cpp -o main
./main abc 999 test
```

会有:

```cpp
argc = 4
argv[0] = "./main"
argv[1] = "abc"
argv[2] = "999"
argv[3] = "test"
```

### Memory Management 内存管理

#### `new` 关键字

`new` 用来在堆上分配内存:

```cpp
int* p = new int[10]; // Allocate 10 integers on heap
for (int i = 0; i < 10; i++) {
    p[i] = i * i; // Assign values
}
delete[] p; // Don't forget to free the memory!
```

分配单个对象. 注意下面两行代码的唯一区别是 `malloc` **没有调用 Constructor**!

```cpp
MyClass* obj = new MyClass(); // Allocate single object
MyClass* obj2 = (MyClass*)malloc(sizeof(MyClass)); // C-style allocation
delete obj; // Free the memory!
free(obj2); // Free C-style allocated memory
```

#### Smart Pointers 智能指针

Smart Pointers = `new` without `delete`. 即不需要担心内存泄漏问题.

- `std::unique_ptr<T>`: 不能被复制:

    ```cpp
    std::unique_ptr<int> p1 = std::make_unique<int>(42); // Create unique_ptr
    // std::unique_ptr<int> p2 = p1; // Error: cannot copy unique_ptr
    ```

- `std::shared_ptr<T>`: 可以被复制 (用过引用计数来管理内存).

- `std::weak_ptr<T>`: 不会增加引用计数, 用于解决 `shared_ptr` 循环引用问题 (@fig-cirref, `a1` 表示 `a` 的引用计数为 1 (`a.use_count() == 1`)):

:::{.column-margin}
![循环引用问题](cirref.png){#fig-cirref}
:::

::: {layout-ncol=2}
```{.cpp filename="sharedptr.cpp" #lst-sharedptrcpp}
{{< include src/cpp/sharedptr.cpp >}}
```

```{.cpp filename="weakptr.cpp" #lst-weakptr}
{{< include src/cpp/weakptr.cpp >}}
```
:::


### Class 类

#### `this` 指针

就是 `Python` 里的 `self` (当前对象的地址):

```cpp
class A {
private:
    int x;

public:
    void setX(int x) {
        this->x = x;   // Left: member variable; Right: parameter
    }
};
```

#### 类继承

```cpp
class A : public B
```

上面代码表示让 `class A` 继承 `class B`. `public` 表示**公开继承**, 即 `B` 的 `public` 和 `protected` 成员在 `A` 里依然是 `public` 和 `protected`[^protected].

[^protected]: `protected` 和 `private` 区别: 前者代表本类和子类可以访问, 后者只能本类访问 (子类不行).

#### `friend` 关键字

在一个类里面声明另一个类 (或函数) 为 `friend`, 表示同意它访问自己的 `private` 和 `protected` 成员:

```{.cpp filename="friend.cpp" #lst-friendcpp}
{{< include src/cpp/friend.cpp >}}
```

### Alias 别名

#### Reference 引用

- Reference 仅仅是 Syntax sugar!
- 必须初始化. `int& ref;` 是错误的.
- `int& ref = a;` 在编译时不会出现 `ref` 这个变量, 它只是 `a` 的别名 (alias).

```{.cpp filename="change_val_ref.cpp" #lst-changevalrefcpp}
{{< include src/cpp/change_val_ref.cpp >}}
```

```{.cpp filename="increment_val_ref.cpp" #lst-incrementvalrefcpp}
{{< include src/cpp/increment_val_ref.cpp >}}
```

#### `typedef` 和 `using` 关键字

下面两个都是给 `std::vector<int>` 起别名 `IntList`, 效果一样:

```cpp
using IntList = std::vector<int>;
typedef std::vector<int> IntList;
```

### Namespace 命名空间

- 我们希望在不同的场景中给功能类似的函数起**完全相同的名字** (比如下面例子的 `print()` 函数), 为了**避免命名冲突**, 我们可以使用 `namespace`:

```{.cpp filename="namespace.cpp" #lst-namespacecpp}
{{< include src/cpp/namespace.cpp >}}
```

输出:

```txt
Goodapple Hello
Badapple Hello
Orange Hello
```

- 不要到处拉 `using namespace xxx;` 的 shit!

- 全局作用域运算符:

```{.cpp filename="globalnamespace.cpp" #lst-globalnamespacecpp}
{{< include src/cpp/globalnamespace.cpp >}}
```

- `::` 可用于**调用** namespace 里的函数 或 class 里的 `static` 变量或方法. 在外部**定义**类的方法实现时必须用 `::` (调用时用 `.`).

<!-- ### Anonymous Functions (Lambda Expressions) -->
