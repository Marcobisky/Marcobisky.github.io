### Python Basics

#### `async def` 和 `await`

- `async def` 表示这个函数的执行过程中如果碰到 `await` 关键字, 会暂时跳出这个函数, 先去处理其它的函数, 比如:

```{.python filename="async-demo.py" #lst-async-demopy}
{{< include src/python/async-demo.py >}}
```

输出:

```txt
Arranged two tasks, waiting for complete ...
Task 1: Starting
Task 2: Starting
Task 2: Completed
Task 1: Completed
All tasks completed in 10.0 seconds
```

#### `assert`

- `assert` 用来 debug 很有用, 比如你要检查程序中间 `a` 是否等于 `1`:

    ```python
    a = 1
    assert a == 1 # 如果 a 不等于 1, 程序会报错退出
    print("Test passed!")
    ```

    - `assert` 后面接的就是一个布尔值, 所以:

        ```python
        assert True  # No error
        assert False # Raises an AssertionError
        ```
    - 也可以加上错误信息:

        ```python
        assert a == 1, "a is not equal to 1!"
        ```

### Python Class 类

#### 类属性和实例属性

- **Class attribute 类属性**: 只不过是定义在类里面的常量而已, **所有实例共享**, 比如可用于 track 某个 class 的实例个数.
    - 在类的内部和外部都可以用 `Car.wheels` 来访问和修改.

- **Instance attribute 实例属性**: 放在 `__init__` 里面的属性, **只有创建了实例后才能访问, 不同的实例可以有不同的值 (独有)**!
    - 在类的内部用 `self.color`、外部用 `car1.color` 来访问和修改.

```python
{{< include src/python/class-instance-attr.py >}}
```

#### 特殊方法 `@classmethod`、`@staticmethod`

- `@classmethod` 仅仅是允许我们**不创建实例**就能调用该方法. 用途:
    - 如果非要用 `car1.change_wheels(6)` 而不是 `Car.wheels = 6` 来修改类属性, 这个时候就可以用 `@classmethod`.
        - 用 `Car.change_wheels(6)` 也行.    
    - 由于该方法可以在创建实例前调用, 所以从某种角度看可以当作**替代构造函数**的方法 (比如下面从字典和 JSON 创建实例).

- `@staticmethod` 仅仅是定义一个与类完全无关的函数, 函数里面不能访问任何类属性和实例属性, 写在类里面仅仅是因为**逻辑上与该类相关**, 一般就是 print 一些信息.
    - 用实例名也可以调用该方法.

```python
{{< include src/python/class-static-method-demo.py >}}
```

<!-- ----------------------------------------- -->
::: {.callout-tip icon=tip collapse=false}
## 他俩其实就是 decorator!
它们其实本质上是一个函数, 可以思考下可能是怎么实现的.
:::
<!-- ----------------------------------------- -->


### Python 常用数据结构

#### Dictionary 字典

- 用 `get()` 来访问 key, 返回对应的 value
    - 注意 key 不存在时不会报错, 而是返回 `None`!

    ```python
    a = {'x': 1, 'y': 2}
    print(a.get('x'))  # 输出 1
    print(a.get("x"))  # 也可以
    print(a.get('z'))  # 输出 None
    ```

### 可变参数

- `*`: 表示任意数量的**单个**参数, 会自动打包成一个 tuple, 比如 `('a', 'b', 'c')`.
    - 一般约定叫 `*args` (arguments), 但也可以随便取名, 比如 `*courses`.
- `**`: 表示任意数量的 **"xxx=yyy" 形式**的参数, 会自动打包成一个 dict, 比如 `{'hobby': '篮球', 'score': 95}`.
    - 一般约定叫 `**kwargs` (keyword arguments), 但也可以随便取名, 比如 `**extras`.
    - 会配合 `for key, value in kwargs.items():` 解包使用!

```python
{{< include src/python/var-params.py >}}
```

### First-class Objects

- 一个对象若有以下特征, 则称其为 "first-class object":
    - 可以被赋值给变量
    - 可以作为参数传递给函数
    - 可以作为函数的返回值
    - 可以在运行时动态创建
    - 可以存储在数据结构中 (如列表、字典等)

<!-- ----------------------------------------- -->
::: {.callout-note icon=true collapse=true}
## First-class Objects Examples
- Functions 函数

```{.python filename="function-1stclass.py" #lst-function-1stclasspy}
{{< include src/python/function-1stclass.py >}}
```

- Classes 类

```{.python filename="class-1stclass.py" #lst-class-1stclasspy}
{{< include src/python/class-1stclass.py >}}
```
:::
<!-- ----------------------------------------- -->


#### Python Decorator 装饰器

> 广义来说, **返回值和参数都是函数**的函数都可以叫作装饰器.

- 装饰器就想**每当一个函数执行的时候**多输出一些日志等信息但又不想将日志 `print` 代码写在函数体内 (给函数穿衣服).
    - 比如 @lst-function-1stclasspy 中 `simple_decorator()` 装饰器也可以写成:

```{.python filename="decorator.py" #lst-decoratorpy}
{{< include src/python/decorator.py >}}
```