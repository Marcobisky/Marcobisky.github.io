### Python Basics

#### Python 变量

- **Mutable 可变类型**

- **Immutable 不可变类型**

- 函数传参时不可变类型按值传递, 可变类型按引用传递 (是这样吗, TODO).

#### Import Libraries

- 导入库就是让定义在别的文件中**所有 object** (**函数、类、实例、变量等**) 在本文件中可以被使用, 一般有下面几种使用方法:

    ```python
    # cocotb 是文件夹!
    # 导入虚拟环境的 /site-packages/cocotb 文件夹下的所有 object (好像不是所有?? TODO)
    # 之后要用的 object 必须用 cocotb.xxx 引出
    import cocotb

    # 这样做可以简化引出方式: np.xxx
    import numpy as np

    # 只导入 cocotb 文件夹下 triggers.py 的 RisingEdge() 函数
    # 这样就可以直接用 RisingEdge() 而不用 cocotb.triggers.RisingEdge()
    from cocotb.triggers import RisingEdge

    # 导入当前目录 ./helpers/xxx.py 中的一些 object
    from .helpers.memory import Memory          # class
    from .helpers.format import format_cycle    # function
    from .helpers.logger import logger          # instance
    ```

#### `async def` 和 `await`

- `async def` 表示这个函数的执行过程中如果碰到 `await` 关键字, 会暂时跳出这个函数, 先去处理其它的函数, 比如:

```{.python filename="async-demo.py" #lst-async-demopy}
{{< include src/python/async-demo.py >}}
```

输出:

```txt
Arranged two tasks, waiting for complete ...
Task 1: Starting
Task 2: Starting
Task 2: Completed
Task 1: Completed
All tasks completed in 10.0 seconds
```

#### `assert`

- `assert` 用来 debug 很有用, 比如你要检查程序中间 `a` 是否等于 `1`:

    ```python
    a = 1
    assert a == 1 # 如果 a 不等于 1, 程序会报错退出
    print("Test passed!")
    ```

    - `assert` 后面接的就是一个布尔值, 所以:

        ```python
        assert True  # No error
        assert False # Raises an AssertionError
        ```
    - 也可以加上错误信息:

        ```python
        assert a == 1, "a is not equal to 1!"
        ```

### Python Class 类

#### 类属性和实例属性

- **Class attribute 类属性**: 只不过是定义在类里面的常量而已, **所有实例共享**, 比如可用于 track 某个 class 的实例个数.
    - 在类的内部和外部都可以用 `Car.wheels` 来访问和修改.

- **Instance attribute 实例属性**: 放在 `__init__` 里面的属性, **只有创建了实例后才能访问, 不同的实例可以有不同的值 (独有)**!
    - 在类的内部用 `self.color`、外部用 `car1.color` 来访问和修改.

```python
{{< include src/python/class-instance-attr.py >}}
```

#### 特殊方法 `@classmethod`、`@staticmethod`

- `@classmethod` 仅仅是允许我们**不创建实例**就能调用该方法. 用途:
    - 如果非要用 `car1.change_wheels(6)` 而不是 `Car.wheels = 6` 来修改类属性, 这个时候就可以用 `@classmethod`.
        - 用 `Car.change_wheels(6)` 也行.    
    - 由于该方法可以在创建实例前调用, 所以从某种角度看可以当作**替代构造函数**的方法 (比如下面从字典和 JSON 创建实例).

- `@staticmethod` 仅仅是定义一个与类完全无关的函数, 函数里面不能访问任何类属性和实例属性, 写在类里面仅仅是因为**逻辑上与该类相关**, 一般就是 print 一些信息.
    - 用实例名也可以调用该方法.

```python
{{< include src/python/class-static-method-demo.py >}}
```

<!-- ----------------------------------------- -->
::: {.callout-tip icon=tip collapse=false}
## 他俩其实就是 decorator!
它们其实本质上是一个函数, 可以思考下可能是怎么实现的.
:::
<!-- ----------------------------------------- -->

#### 动态访问实例属性 `getattr()`

- 如果你想访问的属性名在运行时才能决定, 比如:

    ```python
    class Order:
        def __init__(self):
            self.price = 100
            self.qty = 5

    order = Order()
    attr_name = "price"
    print(order.attr_name)              # 这样是不行的!
    print(getattr(order, attr_name))    # 这样才行!
    ```

### Python 下划线

#### 下划线的基本用法

- 作为大数字的分隔符 (只是看起来更舒服):

    ```python
    num = 1_000_000 # 相当于 num = 1000000
    ```

- 作为不重要的变量, 常见的有:
    - 循环变量

    ```python
    for _ in range(5):  # 表示循环变量不重要, 不会在循环体内使用
        print("Hello")
    ```
    - 解包变量

    ```python
    a, _, b = (1, 2, 3)  # 表示中间的变量不重要
    print(a, b)          # 输出: 1 3
    ```

- 用来避免保留关键字 (仅仅是约定, 众所周知程序员很不擅长取名字, 不用 `foo` 就很好了, 理解一下):

    ```python
    class_ = "MyClass"  # 避免和关键字 class 冲突
    ```

#### Python 下划线命名的可见性

> 我们研究单下划线、双下划线的 **变量、函数、类属性、实例属性、类方法、实例方法、类名** 在 **类内部、子类、类外同文件、不同文件** 中的可见性.

> 总体来说, 单下划线开头 $\approx$ "protected", 双下划线开头 $=$ "private".

```{.python filename="myModule.py" #lst-myModulepy}
_var = 5                # module variable
__var = 6               # module variable

def _g():               # module function
    print("_g called")

def __g():              # module function
    print("__g called")

class A:
    _ca = 1             # Class attribute
    __ca = 2            # Class attribute
    def __init__(self):
        self._ia = 3    # Instance attribute
        self.__ia = 4   # Instance attribute
    def _f(self):
        print("_f called")
    def __f(self):
        print("__f called")
    @classmethod
    def _cf(cls):
        print("_cf called")
    @classmethod
    def __cf(cls):
        print("__cf called")

class _A:               # module class
    pass

class __A:              # module class
    pass
```

- 单下划线: 在**所有地方**都能访问 (相当于没有下划线, 但除了子类访问父类的所有单下划线开头的东西没有警告, 其它都会有警告), 除了不同文件的这种访问方法: 

    ```python
    from myModule import *
    print(_var)    # Error: _var is not defined
    print(_A)      # Error: _A is not defined
    _g()           # Error: _g is not defined
    ```
    但这样是可以的:
    
    ```python
    import myModule
    print(myModule._var)  # 输出: 5
    print(myModule._A)    # 输出: <class 'myModule._A'>
    myModule._g()         # 输出: _g called
    ```
    这样可以:
    
    ```python
    from myModule import _var, _A, _g
    ```

- 双下划线:
    - 类中所有双下划线的 (`__ca`, `__ia`, `__f`, `__cf`) 都**只能**在类的内部使用 (即 "private", 子类和类外同文件都不行).
        - 其实是 **Name Mangling**, 比如 `__ca` 在 runtime 会变成 `_A__ca` (类名 + 变量名), 用这种方法可以访问 (在 Python 中没有什么是绝对 private 的!):
        
        ```python
        import myModule
        print(myModule.A._A__ca)  # 输出: 2
        ```
    - 类外的双下划线 (`__var`, `__g`, `__A`) 必须用:

        ```python
        import myModule
        from myModule import __var, __g, __A    # 也可以
        ```
        这种方法导出其它文件.


#### Dunder Method 魔法方法

> 以双下划线开头和结尾的方法, 表示对某个类进行某种特定操作 (比如创建、销毁、加法、当作函数调用等) 时自动调用的方法 (如同 C++ 的运算符重载).

- 注意所有的魔法方法都是 Python 提供的, 自己不能定义!

```{.python filename="dunder-method.py" #lst-dunder-methodpy}
{{< include src/python/dunder-method.py >}}
```


### Python 常用数据结构

#### Dictionary 字典

- 访问 key, value 和 key-value 对: 

    ```python
    a = {'x': 1, 'y': 2, 'z': 3}
    print(a.keys())        # 输出 dict_keys(['x', 'y', 'z'])
    print(a.values())      # 输出 dict_values([1, 2, 3])
    print(a.items())       # 输出 dict_items([('x', 1), ('y', 2), ('z', 3)])
    ```
    - 注意返回的不是 list 而是**视图对象** (原对象变化后可以跟着变):

        ```python
        a = {'x': 1, 'y': 2, 'z': 3}
        keys_view = a.keys()
        print(keys_view)       # 输出 dict_keys(['x', 'y', 'z'])
        a['w'] = 4
        print(keys_view)       # keys_view 也变了,
                               # 输出 dict_keys(['x', 'y', 'z', 'w'])
        ```

- 用 `get()` 来访问 key, 返回对应的 value
    - 注意 key 不存在时不会报错, 而是返回 `None`!

    ```python
    a = {'x': 1, 'y': 2}
    print(a.get('x'))  # 输出 1
    print(a.get("x"))  # 也可以
    print(a.get('z'))  # 输出 None
    ```

### 可变参数

- `*`: 表示任意数量的**单个**参数, 会自动打包成一个 tuple, 比如 `('a', 'b', 'c')`.
    - 一般约定叫 `*args` (arguments), 但也可以随便取名, 比如 `*courses`.
- `**`: 表示任意数量的 **"xxx=yyy" 形式**的参数, 会自动打包成一个 dict, 比如 `{'hobby': '篮球', 'score': 95}`.
    - 一般约定叫 `**kwargs` (keyword arguments), 但也可以随便取名, 比如 `**extras`.
    - 会配合 `for key, value in kwargs.items():` 解包使用!

```python
{{< include src/python/var-params.py >}}
```

### First-class Objects

- 一个对象若有以下特征, 则称其为 "first-class object":
    - 可以被赋值给变量
    - 可以作为参数传递给函数
    - 可以作为函数的返回值
    - 可以在运行时动态创建
    - 可以存储在数据结构中 (如列表、字典等)

<!-- ----------------------------------------- -->
::: {.callout-note icon=true collapse=true}
## First-class Objects Examples
- Functions 函数

```{.python filename="function-1stclass.py" #lst-function-1stclasspy}
{{< include src/python/function-1stclass.py >}}
```

- Classes 类

```{.python filename="class-1stclass.py" #lst-class-1stclasspy}
{{< include src/python/class-1stclass.py >}}
```
:::
<!-- ----------------------------------------- -->


#### Python Decorator 装饰器

> 广义来说, **返回值和参数都是函数**的函数都可以叫作装饰器.

- 装饰器就想**每当一个函数执行的时候**多输出一些日志等信息但又不想将日志 `print` 代码写在函数体内 (给函数穿衣服).
    - 比如 @lst-function-1stclasspy 中 `simple_decorator()` 装饰器也可以写成:

```{.python filename="decorator.py" #lst-decoratorpy}
{{< include src/python/decorator.py >}}
```

### 链式调用

返回 `*this` 的引用可以实现链式调用:

```{.cpp filename="chaining.cpp" #lst-chaining}
{{< include src/cpp/chaining.cpp >}}
```

### `cocotb` 库

- 常用操作:

```python
import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge
```