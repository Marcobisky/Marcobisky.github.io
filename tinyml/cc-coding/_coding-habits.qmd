> 下面是一些常见的编程习惯和技巧, 注意反过来的脑回路: 读到类似的这些代码的时候也要立即条件反射出来他们在干什么!

### General

- 能引用尽量引用不要用指针!
- 函数的参数尽量少.
- 写程序的时候先关注主逻辑, 函数的实现放到最后写.
- `C++` 中 `namespace` 中的内容不要缩进.

### 检查相等

- 浮点数不能直接用 `==` 检查相等!
    - CPU 上一般用 `std::numeric_limits<float>::epsilon()` 作为误差.
    - CPU 和 GPU 运算结果比较时一般用绝对误差比如 `1e-8f` (库函数提供的可能会太严格).

```{.cpp filename="is_equal_float.cc" #lst-is-equal-float}
{{< include src/cpp/is_equal_float.cc >}}
```

### 正负无穷

- 涉及最小/最大值初始化. 例如我们要找 `arr` 中的最大值:

    ```cpp
    #include <float.h>   // for FLT_MAX

    int main() {
        float arr[] = {3.2, -1.5, 7.8, 0.0, 4.4};
        int n = sizeof(arr) / sizeof(arr[0]);
        float max_val = -FLT_MAX;    // Initialize to -inf
        for (int i = 0; i < n; i++) {
            if (arr[i] > max_val)   max_val = arr[i];
        }
        std::cout << "Max value: " << max_val << std::endl;
        return 0;
    }
    ```

### 向上取整

- 向上取整的操作非常常见, 比如 HPC 里面分配多少个 block 等. 可通过 $$\left\lceil \frac{x}{y} \right\rceil = \left\lfloor \frac{x + y - 1}{y} \right\rfloor$$ 实现 (由于整数除法默认向下取整):

```cpp
int ceil_div(const int x, const int y) {
    return (x + y - 1) / y; // Automatically does floor division
}
```

### 遍历数组和张量

- 看见下面的代码时要立刻意识到这不仅是一个循环, 而且是一个**遍历**!!!

    ```cpp
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            // Process element at (i, j)
        }
    }
    // for (int i = 1; i <= N; i++) {} // 不推荐
    ```

    - `for` 循环的边界: 从 `0` 开始计数而不是 `1`, 用 `<` 而不是 `<=`, 因为下标往往是从 `0` 开始的 (Matlab 除外), 如果用从 `1` 开始, 循环体里面还要减 `1`, 很麻烦.
    - TODO: 如何思考高阶张量的处理? 不要用 global 的 mental picture?

### 全局索引与局部索引的转换

- 遇到下面这种形式的代码时, 要瞬间意识到这是在进行**二维数组**的 flatten/unflatten 操作!
    - Flattening:

        ```verilog
        lsu_index = i * THREADS_PER_BLOCK + j;
        ```

        ```cpp
        int idx = blockIdx.x * blockDim.x + threadIdx.x;
        ```
    - Unflattening:

        ```cpp
        int block_id = idx / block_dim;
        int thread_id = idx % block_dim;
        ```


### 命名习惯

- `k`: 用于常量变量 (constant variable), 例如 `const int kBufferSize = 1024;`.

- `foo(), bar()`: 表示程序员不想起名字 (就像 Alice 和 Bob).
    - 来源于 FUBAR (Fucked up beyond all recognition).

- **功能相似的函数和文件用前缀匹配**: 比如用 `add_float()`, `add_float_vec()`, `add_int()` 而不是: `float_add()`, `vec_float_add()`, `int_add()`. 因为如果它们作为文件名的话, **前缀 match** 的文件会放在一起, 方便查找!

### getters 和 Setters

为了让外部代码访问和修改类的成员变量, 一种办法是将成员变量声明为 `public`, 但一旦外部代码写入了不合法的值, 就会导致类的状态变得不可预测. 因此我们用 `private` + getter/setter 的方式来控制对成员变量的访问和修改.

::: {layout-ncol=2}
```{.cpp filename="account_public.cpp" #lst-account_public}
{{< include src/cpp/account_public.cpp >}}
```

```{.cpp filename="account_private.cpp" #lst-account_private}
{{< include src/cpp/account_private.cpp >}}
```
:::

### 常写 `const`

- 能加上 `const` 尽量加上 (比如 @lst-account_private), 比如**函数声明时的参数列表、返回值和函数体**, 这样尤其是参数有指针的函数可以一眼看出来哪些是可读、可写的.

- `const` 用法:

    ```cpp
    const int *p1; // p1 本身可以修改, 但指向的内容不可以修改
    int * const p2; // p2 本身不可以修改, 但指向的内容可以修改
    const int * const p3; // 都不能修改

    int const& my_int; // 引用的内容不可以修改, 同 const int&
    // int &const // 不合法
    ```

- `Pytorch C++ API` 中提供 `TORCH_ARG` 宏, 用于自动生成类成员变量的 getter 和 setter 方法:

    ```cpp
    #include <torch/torch.h>
    TORCH_ARG(double, balance) = 0;
    ```

    自动展开为:

    ```cpp
    private:
        double balance_ = 0;

    public:
        // getter
        const double& balance() const { return balance_; }
        
        // setter
        double& balance() { return balance_; }
    ```

    这种写法类似 @lst-account_private, `const double&` 意思是返回一个不可修改的引用 (若用值拷贝的话速度较慢). 第二个 `const` 表示 getter 方法本身不会修改这个类的**所有**成员变量 (`balance_` in this case). 用户可以通过 `obj.balance()` 来获取余额, 也可以通过 `obj.balance() = 100.0;` 来修改余额.


- `const` 和 `constexpr` 区别:
    - `constexpr` 变量在编译时就算出来了, 且不可修改. 一般用于**性能优化**或用作**编译时才能决定声明的数组大小**.

    ```cpp
    const int x = some_runtime_function(); // 合法
    constexpr int y = some_runtime_function(); // 不合法, 因为 some_runtime_function() 不是常量表达式
    constexpr int kTensorSize = 256 * 1024; // 合法
    uint8_t tensor[kTensorSize]; // 编译时决定的数组大小
    ```
