### First Encounter

- **Take it Easy**: 一个 `C++` project 不过是一堆 class 和一个 main. 

- 如果是 OOP, 关注类会**改变**哪些外部变量 (通常是引用传递) 而不是某个方法的具体实现.

- 先阅读接口函数 (一般会在 `.h` 文件中!). 如果直接看 `.cc` 文件, 会看到一些接口实现调用的函数, 而且这些函数会放在接口函数上面, 这样丢掉了重点.

- 关注参数列表的 `const`, 这意味着这些是只读的不会改变!

- 读懂参数的含义是一件费时的事情, 但很多时候费时的地方在弄懂信息的**存储格式**. 比如你看到: 

    ```cpp
    void DepthwiseConvPerChannel(const DeptheiseParam& params,
                                 const int32_t* output_multiplier,
                                 const int32_t* output_shift,
                                 const RuntimeShape& in_shape,
                                 ...)
    ```

    就会很想知道 `params`, `output_multiplier` 等里面到底是怎样的结构. 但请克制自己不要知道, 或者自己随便构思一个结构让自己相信它是对的! 因为这些数据结构的实现非常 ad hoc 而且不重要.

### 一些条件反射

#### 二维数组的全局索引

遇到下面这种形式的代码时, 要瞬间意识到这是在计算**二维数组**的全局索引:

```verilog
lsu_index = i * THREADS_PER_BLOCK + j;
```

#### 正负无穷

涉及最小/最大值初始化. 例如我们要找 `arr` 中的最大值:

```cpp
#include <float.h>   // for FLT_MAX

int main() {
    float arr[] = {3.2, -1.5, 7.8, 0.0, 4.4};
    int n = sizeof(arr) / sizeof(arr[0]);
    float max_val = -FLT_MAX;    // Initialize to -inf
    for (int i = 0; i < n; i++) {
        if (arr[i] > max_val)   max_val = arr[i];
    }
    std::cout << "Max value: " << max_val << std::endl;
    return 0;
}
```

#### 向上取整转为向下取整

可通过 $$\left\lceil \frac{x}{y} \right\rceil = \left\lfloor \frac{x + y - 1}{y} \right\rfloor$$ 实现 (由于整数除法默认向下取整):

```cpp
int ceil_div(int x, int y) {
    return (x + y - 1) / y; // Automatically does floor division
}
```
