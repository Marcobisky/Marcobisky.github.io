---
title: "C 语言编译"
---

- **IR (Intermediate Representation)**: 中间代码的作用: 相当于有一个中间缓冲, 可以看成编译器的前端, 通过增加这一个模块, 可以让编译器的前端和后端解耦, 方便支持多种语言和多种目标架构.

```
             frontend                              backend
           +----------+                        +------------+
      C -> |  Clang   | -+                 +-> |  llvm-x86  | -> x86
           +----------+  |                 |   +------------+
           +----------+  +-> +----------+ -+   +------------+
Fortran -> | llvm-gcc | ---> | llvm-opt | ---> |  llvm-arm  | -> ARM
           +----------+  +-> +----------+ -+   +------------+
           +----------+  |                 |   +------------+
Haskell -> |    GHC   | -+                 +-> | llvm-riscv | -> RISC-V
           +----------+  LLVM IR      LLRM IR  +------------+
```

## 编译过程

- gcc 编译选项:
    - `-E`: 只预处理, 不编译.
    - `-S`: 生成汇编代码 (`.s` 文件)
    - `-c`: 只编译, 不链接. (生成 `.o` 文件)
    - `-o <file>`: 指定输出文件名.
    - `-g`: 在输出的文件中加入支持调试的信息.
    - `-v` (verbose): 显示编译过程中的详细信息.


:::{.column-margin}    
![编译过程](compilation.png)
:::

装好 RISCV 编译工具链, 创建一个简单的 C 语言程序 `hello.c`:

```{.c filename="hello.c"}
{{< include code/hello.c >}}
```

运行:

```bash
riscv32-unknown-elf-gcc -c hello.c -o hello.o # 只编译, 不链接
```

用 `riscv32-unknown-elf-readelf` 查看生成的 `.o` 文件:

```bash
riscv32-unknown-elf-readelf -h hello.o > header_info.log # 查看 Header 信息, 并输出到文件
```

得到:

```{.log filename="header_info.log"}
{{< include code/header_info.log >}}
```

再查看 Section 信息:

```bash
riscv32-unknown-elf-readelf -S hello.o > section_info.log # 查看 Section 信息, 并输出到文件
```

得到:

```{.log filename="section_info.log"}
{{< include code/section_info.log >}}
```

对 `.o` 文件进行反汇编:

```bash
riscv32-unknown-elf-objdump -S hello.o > disassembly.s # 反汇编, 并输出到文件
```

得到:

```{.s filename="disassembly.s"}
{{< include code/disassembly.s >}}
```