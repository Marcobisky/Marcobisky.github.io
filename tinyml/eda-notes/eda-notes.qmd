---
title: "EDA Notes 笔记"
---

## Takeaways

- 处处都是优化问题, 一般的思路就是先 brainstorm 你能想到的**要减小**的「因素[^factors]」, 然后一股脑**全加起来**作为 Loss function. 然后:
    - @liao_2023_dreamplace 给我们的启发就是将这个问题等价变成一个训练神经网络的问题, 利用 `torch` 的生态来并行计算.
    - 如果 Loss function 里有不可微的部分. 两种办法: 
        - 直接分段函数哈哈哈 (反正 `torch` 里面也是用查找表算的梯度, 它也不知道它优化的函数可不可微哈哈, 这个办法在 @liao2023analyticaldietodie3dplacement 叫做 **subgradient**).
        - 用某种平滑的方法来强行可微, 方法很多, 你也可以自己设计.

[^factors]: 要增大的话填负号即可; 当然这些「因素」很多时候是相互冲突的, 而且有些「因素」比较定性, 一时间很难想出清晰的表达式, 即使有清晰的表达式计算量也极其大.

- Net weight @liao_2023_dreamplace 的 idea 告诉我们有些难以单读开一个表达式的「因素」可以融入其它的「因素」里!

- EDA 中很多定义不像数学中那样严谨, 不必深究, 意识到这点即可.
    - 比如 Netlist $(V, E)$, $V$ 在不同上下文中可能代表 pin 集或者 cell/macro 集. 如果是 directed hypergraph, 则 edge 集在数学上表现为比如 $$E = \bigl\{\{(p_1, p_3), (p_2, p_3), \cdots\}, \{(p_4, p_6), (p_5, p_6), \cdots\}, \cdots \bigr\}$$ E.g., $$E \ni e = \{(p_1, p_3), (p_2, p_3), \cdots\}$$ 但实际上我们还是把 $E$ 当作 vertex 的集合来看待 (下文称 "Undirected convention"): $$E \ni e = \{p_1, p_2, p_3\}$$

## Some Terms {#sec-eda-terms}

- **Hypergraph 超图**: 图的一种推广, Netlist 常被建模成 (Directed @liao_2023_dreamplace) hypergraph $(V, E)$ (edge 可以有多个 vertex).
    - $V$: 
        - 如果 $V$ 中的元素的坐标是可以**独立**更新的, 则其中的元素代表 **cell/macro** (统称为 node [@liao2023analyticaldietodie3dplacement; @liao_2023_dreamplace] 或 instance @zhao2024analyticalheterogeneousdietodie3d, 注意不能理解为 pin, 多个 pin 可能属于同一个 cell/macro, 他们的相对位置是固定的不能独立更新).
        - 如果不关心 $V$ 中元素的坐标更新, 有时 $V$ 也代表 **pin** 集.
    - $E$ 有直接连接关系的 node 集合, 其中的元素称为一个 **net**.
        - 在 Timing-driven placement 里, 一般 $E$ 可能仅代表 Timing arc 集合.

    ![Directed Hypergraph $(V, E)$ 的两种意义 (Adapted from @pingali_2018_beyond, 采用 "Undirected convention"); Pin-level 的 $E$ 之间一定没有 intersection; PIs (primary inputs); POs (primary outputs).](hypergraph.png){#fig-hypergraph width=90%}

- **Layout**: 元件或电路的 electric function 的几何图形表示 @phdthesisAlgorithms2019.

- **Standard Cell (std cell) 标准单元**: 一组实现逻辑门的物理单元 (AND, OR, NOT, NAND, etc.) @phdthesisAlgorithms2019. 他们过于基础以至于被称为 "standard".

    ![NOT 和 NAND 的 layout @phdthesisAlgorithms2019](layout.png){#fig-layout width=80%}

:::{.column-margin}
![Std cell height 可以是 row height 的整数倍 @phdthesisAlgorithms2019 (其实 Std cell width 也可以是 site width 的整数倍).](mutideck-std-cell.png){#fig-mutideck-std-cell}
:::

## Placement 布局

### 三个阶段

- **Global (coarse/initial) placement**: 把 cell/macro 粗略地放置在芯片上的过程 (不必对齐 row/site, 单元之间允许重叠, 但其实会尽量避免重叠) @phdthesisAlgorithms2019. 

:::{layout = "[65,35]"}
![Legalization 把 cell/macro 吸附到最近的 row/site 上并推开重叠 @phdthesisAlgorithms2019](legalization.png){#fig-legalization}

![Cell/macro 必须放在 row 上 @phdthesisAlgorithms2019.](rowdemo.png){#fig-rowdemo}
:::

- **Legalization 合法化**: 消除重叠和在**两个**方向对齐的过程 (见 @fig-legalization). Cell/macro 不能随便放置, 而要在两个方向对齐:
    - **Row**: 见 @fig-layout, 每个 std cell 的上下为该 cell 的供电 metal (上 VDD 下 GND), 我们希望每个 std cell 的这两个 metal 共线, 这样才方便提供统一的供电. 自然的, 所有 cell/macro 要在水平方向成一条线, 使得 die 有“一层一层”的概念, **每一层称为一个 row**. Row height 等于 std cell height; Row 分隔线 (见 @fig-sitedemo 的蓝色条) VDD 和 GND 交替.
    - **Site**: Row 引入了「层」, 而 site 给每一层也数字化引入了「门牌号」, 每个 cell/macro 必须对齐到 row 和 site 边界!


    ![Std cell 必须上下对齐 row, 左右对齐 site @phdthesisAlgorithms2019; 且下面一层的 std cell 需要 flip!](sitedemo.png){#fig-sitedemo width=90%}


- **Detailed placement**

### Wirelength Model

![两种估计后续布线时线长的模型: 1. HPWL; 2. 通过构建 RSMT 来计算 @_2024_a7vlsi.](wirelength-model.png){#fig-wirelength-model width=80%}

### Density Model

- **Bin**: 仅仅是为了**方便计算**[^bin]布局的密度 @_2024_83 (即有限元方法), 整个 die 被划分为若干个小的矩形区域 (厚度跟 die 的厚度一样), 每个小区域称为一个 bin @zhao2024analyticalheterogeneousdietodie3d (见 @fig-bindemo). 所有的 bin 组成的集合记作 $B$.

    ![此图中 bin 的高度是 row height 的 $4$ 倍 @phdthesisAlgorithms2019](bindemo.png){#fig-bindemo width=70%}

[^bin]: 注意区分 bin 和 row/site 围成的小方格! 前者是为了计算密度而人为划分的区域, 后者是为了放置 cell/macro 而划分的区域.

### Timing Model

- 现在我们还要考虑 slack 的问题. 由于 slack 跟 wirelength 是有关系的, 将 timing term 与线长解耦是不可能的, 即无法在 Loss function 里单独引入衡量 Timing 的项. @liao_2023_dreamplace 天才般地通过引入 **Net weight** 这个概念将 timing 的信息融合进 wirelength model 里 (Timing-driven placement).
    - 一个自然的想法是

TODO

## References
