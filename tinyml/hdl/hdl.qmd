---
title: "HDL 硬件描述语言"
---

## Change of Mind

- Hardware does not "execute" the lines of code in sequence. 

## Verilog

- `assign`
    - 多个 `assign` 执行**没有顺序**, 同时进行.
    - `assign` 是 "continuous assignment", 右值变化时, 左值跟着变化.

- **Operation 运算符**: `~`, `!` (logical), `&`, `&&` (logical), `|`, `||` (logical), `^` (XOR).


- `if, else if` 是有顺序的!!!

- (procedure 一定要放在 always 块中吗?)


- (为什么 wire 类型不能在 always 里面被赋值?)

- `always` 块中的代码是**顺序执行**的 (但在 `always` 块外的代码是**并行执行**的).

    ```verilog
    module top (input my_in, output reg my_out);
        always @(*) begin
            my_out = 0;
            my_out = 1; // This is valid! (Always block 按顺序执行)
        end
    endmodule
    ```

    - **Latch 推断**: 下面如果 `cpu_overheated = 0` 则默认会让 `shut_off_computer` 保持上一个值, 这就是 latch 推断.

        ```verilog
        always @(*) begin
            if (cpu_overheated)
                shut_off_computer = 1;
        end
        ```
        有时我们就是需要这种推断, 但为了避免, 可以利用always 的顺序性先提前赋值:
        
        ```verilog
        always @(*) begin
            shut_off_computer = 0; // 先提前赋值
            if (cpu_overheated)
                shut_off_computer = 1;
        end
        ```

- **Concatenation**: 

    ```verilog
    assign out = {tmp, {3{3'b100}}}; // Concatenation, out = 0000011 100 100 100
    ```

- index 可以是负数:

    ```verilog
    reg [5:-1] my_reg; // index 可以是负数.
    wire [0:3] my_wire; // Big-endian, mywire[0] is MSB, use my_wire[3:0] later is illegal!
    ```

- `input a` 默认为 `wire`.

- `begin end` 在只有一行代码时可以省略 (相当于 C 中的 `{}`).

- `wire` 不能在 `always` 块中被赋值. `reg` 才能在 `always` 中被赋值.
    
    ```verilog
    wire a;
    always @(*) begin
        assign a = 1; // Error!
    end
    ```
    ```verilog
    wire a;
    always @(*) begin
        a <= 1; // Not an error, `a` is viewed as a reg.
    end
    ```

- **Synchronous and Asynchronous Reset**:

    - synchronous reset: 

        ```verilog
        always @(posedge clk) begin
            if (reset)
                ...
        end
        ```

    - asynchronous reset: 

        ```verilog
        always @(posedge clk or posedge reset) begin
            if (reset)
                ...
        end
        ```

- `or` **只能**在 `always` 块中使用, `if ()` 中要用 `||`.

- **Inference** 和 **Instantiation**:
    - **Inference**: 通过 `always` 块的内容推断出一个模块的功能.
    - **Instantiation**: 显式地实例化一个模块, 通过 `module_name instance_name (port_map)` 的方式.

 - 循环群结构 (Torus, etc) 如果用 `%` 运算符来处理会消耗大量资源, **尽量用 `if` 语句**:

    ```verilog
    if (mm == 8'd59) begin
        mm <= 8'd0;
    end
    ```

    - 如果用 `%` 运算符来处理:
        - `-1 % 16` 的结果是 `-1`, 而不是 `15` (所以 `(a-1)%16` 应该写成 `(a+15)%16`).
        - 1~12 的循环先转换为 0~11 的循环, 再换元.

- **BCD (Binary-Coded Decimal)**: 一种从 0 到 9 的计数器, 输出是四位二进制编码的十进制数.

- **Blocking 和 Non-blocking assignments**:
    - `=`: Blocking assignment, 若在 `always` 块中使用, 则必须按照顺序执行!
    - `<=`: Non-blocking assignment, 在 `always` 块中使用时, 会同时执行所有赋值. (一般 `always` 里面都用这个!)

### Verilog Testbench

```verilog
`timescale 1ns / 1ps // #1 代表 1ns, 最精确可以到 #1.001
`timescale 1ns / 1ns // #1 代表 1ns, #1.01 等是不合法的

$stop //停下来
```


## Chisel

- `+&`: 如果 `io.in_a` 和 `io.in_b` 为 `4.W` 时, 则 `sum` 为 `5.W` (带溢出).

    ```chisel
    val sum = io.in_a +& io.in_b
    ```

- 允许多个 `:=` 赋值到同一个输出:

    ```chisel
    io.out := 0.U
    io.out := 1.U // 覆盖上一个
    ```

- `if` 和 `when` 的区别:
    - `if` 用来在编译阶段决定电路是哪一种
    - `when` 用来生成固定的 verilog 电路, 相当于 verilog 的 `if`.

- `orR`: reduction OR, 对所有位进行 OR 操作.