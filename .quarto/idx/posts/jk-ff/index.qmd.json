{"title":"JK Flip-flop not Behavioral (VHDL version)","markdown":{"yaml":{"author":"Marcobisky","title":"JK Flip-flop not Behavioral (VHDL version)","description":"Easy to write a behavioral description of JK-FF in VHDL, what about writing it in terms of *gates*?","date":"2024-12-08","image":"mio.png","categories":["Hardware"],"format":{"html":{"toc":true,"self-contained":true,"grid":{"margin-width":"350px"}}}},"headingText":"Intro","containsRefs":false,"markdown":"\n\n\nMost online VHDL descriptions of JK flip-flops (FF) are based on \"processes\" or circuit functionality (behavioral). Is it possible to simulate them only by constructing the circuit structure of the JK flip-flop?\n\n## JK FF Review\n\nThe circuit structure is JK FF is very familiar to everybody, which is:\n![](JK_struct.png)\n\nThe corresponding truth table is shown below:\n\n| C    | J | K | Q      | Q̅      |\n|------|---|---|--------|--------|\n| ↑   | 0 | 0 | latch  | latch  |\n| ↑   | 0 | 1 | 0      | 1      |\n| ↑   | 1 | 0 | 1      | 0      |\n| ↑   | 1 | 1 | toggle | toggle |\n| x    | 0 | 0 | latch  | latch  |\n| x    | 0 | 1 | latch  | latch  |\n| x    | 1 | 0 | latch  | latch  |\n| x    | 1 | 1 | latch  | latch  |\n\nwhere \"latch\" represent the `Q` output remembers whatever the last stored value was. \"Toggle\" means to flip `Q`, i.e. 0 -> 1, 1 -> 0. \"↑\" means the clock signal in a leading edge.\n\n## Problem\n\n### First try\n\nWrite the following content in `JKFF.vhdl`:\n\n```vhdl\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\nentity JKFF_nodelay is\n    Port (\n        J : in STD_LOGIC;     -- J input\n        K : in STD_LOGIC;     -- K input\n        clk : in STD_LOGIC;   -- Clock input\n        Q : out STD_LOGIC;    -- Output Q\n        QN : out STD_LOGIC    -- Output QN (complement of Q)\n    );\nend JKFF_nodelay;\n\narchitecture Structural of JKFF_nodelay is\n    -- Internal signals for latch and clock gating\n    signal S, R : STD_LOGIC;    -- Set and Reset inputs for the latch\n    signal Q_int, QN_int : STD_LOGIC := '0'; -- Internal Q and QN for feedback\n\nbegin\n    S <= (J and clk) and QN_int;\n    R <= (K and clk) and Q_int;\n\n    -- NOR gate-based latch\n    Q_int <= not (R or QN_int);\n    QN_int <= not (S or Q_int);\n\n    -- Outputs\n    Q <= Q_int;    -- Main output\n    QN <= QN_int;  -- Complementary output\nend Structural;\n```\n\nThen write a testbench file to test the behavior of this circuit, you will find it will not work well.\n\n### Reason\n\nThe reason (probably, only personal view) is that JK FF have two layers of feedback (instead of SR FF, which just have one), since we loop our output `Q` not only to the NOR gates, but also AND to our initial inputs J and K. This confuse the compiler because the resultant signal changes so fast and maybe not have a stable consequence, so the compiler do not know how to respond to this kind of feedback. \n\nSo we introduce some delay in the gates to simulate the reality closer. \n\n## Solution\n\n### Adding delay in the gates\n\nWe write the following content in another file `JKFF.vhdl`:\n\n```vhdl\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\nentity JKFF is\n    Port (\n        J : in STD_LOGIC;     -- J input\n        K : in STD_LOGIC;     -- K input\n        clk : in STD_LOGIC;   -- Clock input\n        Q : out STD_LOGIC;    -- Output Q\n        QN : out STD_LOGIC    -- Output QN (complement of Q)\n    );\nend JKFF;\n\narchitecture Structural of JKFF is\n    -- Internal signals for latch and clock gating\n    signal S, R : STD_LOGIC;    -- Set and Reset inputs for the latch\n    signal Q_int, QN_int : STD_LOGIC := '0'; -- Internal Q and QN for feedback\n\nbegin\n    S <= (J and clk) and QN_int after 0.1 ns;\n    R <= (K and clk) and Q_int after 0.1 ns;\n\n    -- NOR gate-based latch\n    Q_int <= not (R or QN_int) after 0.2 ns;\n    QN_int <= not (S or Q_int) after 0.2 ns;\n\n    -- Outputs\n    Q <= Q_int;    -- Main output\n    QN <= QN_int;  -- Complementary output\nend Structural;\n```\n\nAnd run the following `JKFF_tb.vhdl`:\n\n```vhdl\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\nentity JKFF_tb is\n-- No ports for testbench\nend JKFF_tb;\n\narchitecture Behavioral of JKFF_tb is\n    -- Component declaration\n    component JKFF\n        Port (\n            J : in STD_LOGIC;\n            K : in STD_LOGIC;\n            clk : in STD_LOGIC;\n            Q : out STD_LOGIC;\n            QN : out STD_LOGIC\n        );\n    end component;\n\n    -- Signals to connect to the JKFF\n    signal J, K, clk : STD_LOGIC := '0';\n    signal Q, QN : STD_LOGIC;\n\nbegin\n    -- Instantiate the JK Flip-Flop\n    uut: JKFF\n        Port Map (\n            J => J,\n            K => K,\n            clk => clk,\n            Q => Q,\n            QN => QN\n        );\n\n    -- Clock generation process\n    clk_gen: process\n    begin\n        for i in 0 to 9 loop -- Generate 10 clock cycles\n            clk <= '0';\n            wait for 9 ns; -- Low for 5 ns\n            clk <= '1';\n            wait for 1 ns; -- High for 5 ns\n        end loop;\n        wait; -- End simulation after clock finishes\n    end process;\n\n    -- Stimulus process to apply test cases\n    stimulus: process\n    begin\n        -- Test Case 1: Hold state (J = 0, K = 0)\n        J <= '0'; K <= '0';\n        wait for 20 ns;\n\n        -- Test Case 2: Set state (J = 1, K = 0)\n        J <= '1'; K <= '0';\n        wait for 20 ns;\n\n        -- Test Case 3: Reset state (J = 0, K = 1)\n        J <= '0'; K <= '1';\n        wait for 20 ns;\n\n        -- Test Case 4: Toggle state (J = 1, K = 1)\n        J <= '1'; K <= '1';\n        wait for 40 ns;\n\n        -- Return to Hold state\n        J <= '0'; K <= '0';\n        wait for 20 ns;\n\n        wait; -- End simulation\n    end process;\nend Behavioral;\n```\n\n### Results\n\nWe will get the following waveform:\n\n![](waveform1.png)\n\nThere are several strange things happen here:\n\n#### What happen before around 30 ns?\n\nThe `Q` and `QN` oscillates at the same pace. Why? It's because both `J` and `K` are zero. For a JK FF, this means to remember the last value. But the last value of `Q` and `QN` are both zero (we initialize them in the `JKFF.vhdl` file):\n\n```vhdl\nsignal Q_int, QN_int : STD_LOGIC := '0'; -- Internal Q and QN for feedback\n```\n\nThis is invalid and unstable! So they oscillates with a period of 0.2 ns, which is exactly the delay time of the NOR gates. \n\n![Locally zoomed in](waveform2.png)\n\nOK, if instead we initialize the `Q` and `QN` a *valid* value, say `Q_int=0` and `QN_int=1` like this (in `JKFF.vhdl` file):\n\n```vhdl\nsignal Q_int : STD_LOGIC := '0'; -- Internal Q for feedback\nsignal QN_int : STD_LOGIC := '1'; -- Internal QN for feedback\n```\n\nSince they are *valid*, hence stable, `Q` and `QN` will not oscillates as expected:\n\n![](waveform3.png)\n\n#### Why not toggle successfully?\n\nAt around $t = 70$ ns, both `J` and `K` are 1. This means at the leading edge of the clock signal `clk`, `Q` and `QN` should both flipped! But according to the waveform, they tried but failed, with a tiny pulse around that time.\n\nI tried several `clk` pulse width and analysed the JK circuit in \"slow-motion\" carefully (Try this! Very surprising!). Finally I figured it out:\n\nIt's because JK FF don't want the `clk` signal be high for too long. This is because if the `clk` line hold high for a sufficient long period, the signal at `Q` and `QN` will \"backpropagate\" (Haha just borrow the term) to the inputs, continue to control whether or not the `J` and `K` signal should come in. If we increase the so-called \"duty-ratio\" of the `clk` signal, we will see these:\n\n![Duty ratio = 0.20](waveform4.png)\n\n![Duty ratio = 0.30](waveform5.png)\n\n![Duty ratio = 0.40](waveform6.png)\n\n![Duty ratio = 0.65](waveform7.png)\n\nSome value of duty ratio (e.g. 0.65) happen to toggle the `Q` successfully, while others do not.\n\nYou can think of what value could the duty ratio be? (Given the clock cycle and the propagation delay of all gates) This is a very intereting yet tedious problem to consider. But as long as you understand why `Q` oscillates, you understand this.\n\nTherefore people say that there are no \"JK *latches*\".\n\n## Conclusion\n\nThe VHDL realization of a JK FF can be achieved by introducing propagation delay to the gates.","srcMarkdownNoYaml":"\n\n## Intro\n\nMost online VHDL descriptions of JK flip-flops (FF) are based on \"processes\" or circuit functionality (behavioral). Is it possible to simulate them only by constructing the circuit structure of the JK flip-flop?\n\n## JK FF Review\n\nThe circuit structure is JK FF is very familiar to everybody, which is:\n![](JK_struct.png)\n\nThe corresponding truth table is shown below:\n\n| C    | J | K | Q      | Q̅      |\n|------|---|---|--------|--------|\n| ↑   | 0 | 0 | latch  | latch  |\n| ↑   | 0 | 1 | 0      | 1      |\n| ↑   | 1 | 0 | 1      | 0      |\n| ↑   | 1 | 1 | toggle | toggle |\n| x    | 0 | 0 | latch  | latch  |\n| x    | 0 | 1 | latch  | latch  |\n| x    | 1 | 0 | latch  | latch  |\n| x    | 1 | 1 | latch  | latch  |\n\nwhere \"latch\" represent the `Q` output remembers whatever the last stored value was. \"Toggle\" means to flip `Q`, i.e. 0 -> 1, 1 -> 0. \"↑\" means the clock signal in a leading edge.\n\n## Problem\n\n### First try\n\nWrite the following content in `JKFF.vhdl`:\n\n```vhdl\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\nentity JKFF_nodelay is\n    Port (\n        J : in STD_LOGIC;     -- J input\n        K : in STD_LOGIC;     -- K input\n        clk : in STD_LOGIC;   -- Clock input\n        Q : out STD_LOGIC;    -- Output Q\n        QN : out STD_LOGIC    -- Output QN (complement of Q)\n    );\nend JKFF_nodelay;\n\narchitecture Structural of JKFF_nodelay is\n    -- Internal signals for latch and clock gating\n    signal S, R : STD_LOGIC;    -- Set and Reset inputs for the latch\n    signal Q_int, QN_int : STD_LOGIC := '0'; -- Internal Q and QN for feedback\n\nbegin\n    S <= (J and clk) and QN_int;\n    R <= (K and clk) and Q_int;\n\n    -- NOR gate-based latch\n    Q_int <= not (R or QN_int);\n    QN_int <= not (S or Q_int);\n\n    -- Outputs\n    Q <= Q_int;    -- Main output\n    QN <= QN_int;  -- Complementary output\nend Structural;\n```\n\nThen write a testbench file to test the behavior of this circuit, you will find it will not work well.\n\n### Reason\n\nThe reason (probably, only personal view) is that JK FF have two layers of feedback (instead of SR FF, which just have one), since we loop our output `Q` not only to the NOR gates, but also AND to our initial inputs J and K. This confuse the compiler because the resultant signal changes so fast and maybe not have a stable consequence, so the compiler do not know how to respond to this kind of feedback. \n\nSo we introduce some delay in the gates to simulate the reality closer. \n\n## Solution\n\n### Adding delay in the gates\n\nWe write the following content in another file `JKFF.vhdl`:\n\n```vhdl\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\nentity JKFF is\n    Port (\n        J : in STD_LOGIC;     -- J input\n        K : in STD_LOGIC;     -- K input\n        clk : in STD_LOGIC;   -- Clock input\n        Q : out STD_LOGIC;    -- Output Q\n        QN : out STD_LOGIC    -- Output QN (complement of Q)\n    );\nend JKFF;\n\narchitecture Structural of JKFF is\n    -- Internal signals for latch and clock gating\n    signal S, R : STD_LOGIC;    -- Set and Reset inputs for the latch\n    signal Q_int, QN_int : STD_LOGIC := '0'; -- Internal Q and QN for feedback\n\nbegin\n    S <= (J and clk) and QN_int after 0.1 ns;\n    R <= (K and clk) and Q_int after 0.1 ns;\n\n    -- NOR gate-based latch\n    Q_int <= not (R or QN_int) after 0.2 ns;\n    QN_int <= not (S or Q_int) after 0.2 ns;\n\n    -- Outputs\n    Q <= Q_int;    -- Main output\n    QN <= QN_int;  -- Complementary output\nend Structural;\n```\n\nAnd run the following `JKFF_tb.vhdl`:\n\n```vhdl\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\nentity JKFF_tb is\n-- No ports for testbench\nend JKFF_tb;\n\narchitecture Behavioral of JKFF_tb is\n    -- Component declaration\n    component JKFF\n        Port (\n            J : in STD_LOGIC;\n            K : in STD_LOGIC;\n            clk : in STD_LOGIC;\n            Q : out STD_LOGIC;\n            QN : out STD_LOGIC\n        );\n    end component;\n\n    -- Signals to connect to the JKFF\n    signal J, K, clk : STD_LOGIC := '0';\n    signal Q, QN : STD_LOGIC;\n\nbegin\n    -- Instantiate the JK Flip-Flop\n    uut: JKFF\n        Port Map (\n            J => J,\n            K => K,\n            clk => clk,\n            Q => Q,\n            QN => QN\n        );\n\n    -- Clock generation process\n    clk_gen: process\n    begin\n        for i in 0 to 9 loop -- Generate 10 clock cycles\n            clk <= '0';\n            wait for 9 ns; -- Low for 5 ns\n            clk <= '1';\n            wait for 1 ns; -- High for 5 ns\n        end loop;\n        wait; -- End simulation after clock finishes\n    end process;\n\n    -- Stimulus process to apply test cases\n    stimulus: process\n    begin\n        -- Test Case 1: Hold state (J = 0, K = 0)\n        J <= '0'; K <= '0';\n        wait for 20 ns;\n\n        -- Test Case 2: Set state (J = 1, K = 0)\n        J <= '1'; K <= '0';\n        wait for 20 ns;\n\n        -- Test Case 3: Reset state (J = 0, K = 1)\n        J <= '0'; K <= '1';\n        wait for 20 ns;\n\n        -- Test Case 4: Toggle state (J = 1, K = 1)\n        J <= '1'; K <= '1';\n        wait for 40 ns;\n\n        -- Return to Hold state\n        J <= '0'; K <= '0';\n        wait for 20 ns;\n\n        wait; -- End simulation\n    end process;\nend Behavioral;\n```\n\n### Results\n\nWe will get the following waveform:\n\n![](waveform1.png)\n\nThere are several strange things happen here:\n\n#### What happen before around 30 ns?\n\nThe `Q` and `QN` oscillates at the same pace. Why? It's because both `J` and `K` are zero. For a JK FF, this means to remember the last value. But the last value of `Q` and `QN` are both zero (we initialize them in the `JKFF.vhdl` file):\n\n```vhdl\nsignal Q_int, QN_int : STD_LOGIC := '0'; -- Internal Q and QN for feedback\n```\n\nThis is invalid and unstable! So they oscillates with a period of 0.2 ns, which is exactly the delay time of the NOR gates. \n\n![Locally zoomed in](waveform2.png)\n\nOK, if instead we initialize the `Q` and `QN` a *valid* value, say `Q_int=0` and `QN_int=1` like this (in `JKFF.vhdl` file):\n\n```vhdl\nsignal Q_int : STD_LOGIC := '0'; -- Internal Q for feedback\nsignal QN_int : STD_LOGIC := '1'; -- Internal QN for feedback\n```\n\nSince they are *valid*, hence stable, `Q` and `QN` will not oscillates as expected:\n\n![](waveform3.png)\n\n#### Why not toggle successfully?\n\nAt around $t = 70$ ns, both `J` and `K` are 1. This means at the leading edge of the clock signal `clk`, `Q` and `QN` should both flipped! But according to the waveform, they tried but failed, with a tiny pulse around that time.\n\nI tried several `clk` pulse width and analysed the JK circuit in \"slow-motion\" carefully (Try this! Very surprising!). Finally I figured it out:\n\nIt's because JK FF don't want the `clk` signal be high for too long. This is because if the `clk` line hold high for a sufficient long period, the signal at `Q` and `QN` will \"backpropagate\" (Haha just borrow the term) to the inputs, continue to control whether or not the `J` and `K` signal should come in. If we increase the so-called \"duty-ratio\" of the `clk` signal, we will see these:\n\n![Duty ratio = 0.20](waveform4.png)\n\n![Duty ratio = 0.30](waveform5.png)\n\n![Duty ratio = 0.40](waveform6.png)\n\n![Duty ratio = 0.65](waveform7.png)\n\nSome value of duty ratio (e.g. 0.65) happen to toggle the `Q` successfully, while others do not.\n\nYou can think of what value could the duty ratio be? (Given the clock cycle and the propagation delay of all gates) This is a very intereting yet tedious problem to consider. But as long as you understand why `Q` oscillates, you understand this.\n\nTherefore people say that there are no \"JK *latches*\".\n\n## Conclusion\n\nThe VHDL realization of a JK FF can be achieved by introducing propagation delay to the gates."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"self-contained":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.41","comments":{"utterances":{"repo":"Marcobisky.github.io"}},"theme":["sandstone","../../_variables.scss"],"author":"Marcobisky","title":"JK Flip-flop not Behavioral (VHDL version)","description":"Easy to write a behavioral description of JK-FF in VHDL, what about writing it in terms of *gates*?","date":"2024-12-08","image":"mio.png","categories":["Hardware"],"grid":{"margin-width":"350px"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}